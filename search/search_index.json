{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hubctl","text":"<p>Hubctl helps to manage your infrastructure as code by allowing to split your infrastructure into reusable components.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Built in support for all popular infrastructure automation tools (such as Terraform, Kustomize, Helm, ARM etc)</li> <li>Supports multiple cloud providers (AWS, Azure, GCP, Kubernetes)</li> <li>Manages, deployments, backups, parameters</li> <li>Extensible with plugins and automation hooks</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install hubctl follow the instructions on the installation page.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>To get started with hubctl, follow the quickstart guide.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Hubctl overview</li> <li>Components</li> <li>Stacks</li> </ul>"},{"location":"install/","title":"Install","text":"<p>This page will show how to install hubctl on your local workstation</p> <p>There are few ways to install hubctl:</p> <ol> <li>Download binary</li> <li>Homebrew Formula</li> </ol>"},{"location":"install/#download-binary","title":"Download Binary","text":"<p>To download the latest of hubctl run the following</p>"},{"location":"install/#curl","title":"cURL","text":"<pre><code>curl -LJ \"https://github.com/epam/hubctl/releases/latest/download/hubctl_$(uname -s)_$(uname -m).tar.gz\" |\\\n  tar xz -C /tmp &amp;&amp; sudo mv /tmp/hubctl /usr/local/bin\n</code></pre>"},{"location":"install/#wget","title":"Wget","text":"<pre><code>wget \"https://github.com/epam/hubctl/releases/latest/download/hubctl_$(uname -s)_$(uname -m).tar.gz\" -O - |\\\n  tar xz -C /tmp &amp;&amp; sudo mv /tmp/hubctl /usr/local/bin\n</code></pre>"},{"location":"install/#homebrew-formula","title":"Homebrew Formula","text":"<pre><code>brew tap epam/tap\nbrew install epam/tap/hubctl\n</code></pre>"},{"location":"install/#extensions","title":"Extensions","text":"<p>Extensions are the plugins for hubctl. It provides additional functionality to hubctl. To install extensions run:</p> <pre><code>hubctl extensions install\n</code></pre> <p>There are few common tools used across all extensions. Other tools are component specific</p> <ul> <li>bash</li> <li>curl</li> <li>jq</li> <li>yq v4</li> </ul>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>Some components and extensions requires additional tools to be installed:</p> <ul> <li>AWS CLI - for components that requires <code>aws</code></li> <li>Azure CLI - for component that requires <code>azure</code></li> <li>Gcloud SDK - for component that requires <code>gcp</code></li> <li>kubectl - for components that requires <code>kubernetes</code></li> <li>Terraform - for components that requires <code>terraform</code></li> <li>Helm - for components that requires <code>helm</code></li> <li>Kustomize*</li> <li>Node.js - to activate <code>hubctl pull</code> extension</li> <li>Docker CLI - to active <code>hubctl toolbox</code> extension</li> </ul> <p>Special note for Kustomize: by default kustomize has been shipped together with kubectl (<code>kubectl -k ...</code>) However if user has a kustomize installed. Hubctl will use it instead.</p>"},{"location":"install/#whats-next","title":"What's Next","text":"<ul> <li>See our Getting Started guide</li> </ul>"},{"location":"use-cases/","title":"When do You Need Hubctl?","text":"<p>When we created a Hubctl we had an idea to promote the best practices for infrastructure as code. We wanted to create a tool that would help us to manage our infrastructure as code in a consistent and repeatable way.</p>"},{"location":"use-cases/#package-manager-for-the-cloud","title":"Package manager for the Cloud","text":"<p>Operating Systems have got a package managers for ages now like <code>homebrew</code> for Mac and <code>choco</code> for Windows. It is able to download and install packages, resolve dependencies etc. But there is no such package manager for the cloud deployments.</p> <p>Today we organize our infrastructure as code in the form of Terraform, Kustomize, Helm, ARM etc. Each of these tools solves solves a specific problem. When you find yourself in the situation when you need to multiple tools for your deployment, you end up with a lot of boilerplate code. Hubctl solves this problem by these integrations and provides a single interface to manage your infrastructure.</p>"},{"location":"use-cases/#break-up-monolithic-deployments","title":"Break-up monolithic deployments","text":"<p>We have seen when application deployment code was 60% of entire codebase. This makes deployment code a biggest component of your entire application. Similar to applications today split into microservices, we can also split our infrastructure into multiple components. This makes it easier to manage and maintain.</p> <p>Hubctl provides mechanisms to manage your deployment as a stack of components. Each component can be deployed and managed independently and can use it's own deployment tool.</p>"},{"location":"use-cases/#ephemeral-environments","title":"Ephemeral Environments","text":"<p>Hubctl gives you a single place to deploy your environments. You can deploy your environments on demand and dispose them when you don't need them. This allows you to save money on your cloud bills.</p>"},{"location":"use-cases/#run-from-automation","title":"Run from Automation","text":"<p>Hubctl is designed to be used in automation. CI/CD pipelines, GitHub Actions, GitLab CI, Jenkins, ArgoCD, FluxCD, Tekton, Spinnaker, you name it. Hubctl can  also send a call backs to your IT Service System so it can track the progress of your deployments.</p>"},{"location":"what-is/","title":"What Is Hubctl","text":"<p>Hubctl does not replaces Infrastructure as Code tools such as Terraform, Kustomize, Helm, ARM etc. Instead it acts as a glue between them. It allows to split your infrastructure into reusable components and manage them as a single stack of components.</p>"},{"location":"what-is/#how-does-it-work","title":"How Does It Work","text":"<p>Each component has a set of expectations <code>requires</code> and provides something for another components <code>provides</code> and has a deployment script that uses one or few Infrastructure as Code technologies. Hubctl uses this information to configure your environment, deploy components in the right order, and carry on parameters between components.</p> <p>The hubctl workflow consists of following steps:</p> <ul> <li> <p>Write: You define components that you want to use in your stack, and what your stack of components will require form the environment. Such as which credentials to use for your Cloud Service Provider, or with Kubernetes cluster. Do you want to use publicly available DNS etc.</p> </li> <li> <p>Configure: Configure your stack before deployment. This means supply all inputs from the environments defined in the previous step. Other input will be provided as components outputs. Hubctl will validate that all required inputs are provided, configure remote state, DNS and other resources.</p> </li> <li> <p>Deploy: Deploy your stack. This will run deployment scripts for each component in the right order and carefully pass inputs from the environment or upstream component.</p> </li> </ul>"},{"location":"what-is/#break-deployments-monolith","title":"Break Deployments Monolith","text":"<p>Hubctl allows to break your deployments into smaller pieces. This allows to reuse components across multiple stacks. For example you can have a component that deploys a Kubernetes cluster and reuse it across multiple stacks. Or you can have a component that deploys a database and reuse it across multiple stacks. More about use cases see in here.</p>"},{"location":"what-is/#see-also","title":"See Also","text":""},{"location":"hubctl/","title":"Overview","text":"<p>Hubctl is stack composition and lifecycle tool:</p> <ul> <li>template and stack creation, stack deploy / undeploy / backup lifecycle;</li> <li>stack and component parameters, output variables, and state;</li> </ul>"},{"location":"hubctl/#components","title":"Components","text":"<p>Hubctl core experience is about connecting various pieces of software - called components into a stack, each component developed independently yet designed to work together, via common set of parameters for inputs and outputs. See more about components here</p>"},{"location":"hubctl/#stacks","title":"Stacks","text":"<p>In real life we rarely deploy just a single component. We usually need to take several components and stack them together into a coherent deployment unit that actually makes sense to deploy</p> <p>To deploy a stack hubctl needs a <code>hub.yaml</code> file that lists the components and parameters that are needed to deploy the stack.</p>"},{"location":"hubctl/cli/","title":"Command <code>hubctl</code>","text":"<p>By default hubctl is a CLI tool that provides a set of commands to manage stacks and deployments</p> Command Description <code>hubctl stack</code> Commands to manage your deployment <code>hubctl show</code> Show parameters of a deployed stack <code>hubctl toolbox</code> Starts a local toolbox container and mounts current file system inside <code>hubctl extensions</code> Manage hubctl extensions <code>hubctl ext</code> Manage hubctl extensions"},{"location":"hubctl/cli/#common-flags","title":"Common Flags","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-ext/","title":"Command: <code>hubctl ext</code>","text":"<p>This is a utility command to manage user defined extensions.</p> <p>By default extensions installed in <code>~/.hub</code>. However this can be any directory available in the PATH.</p> <p>User can define their own extensions and place them in the extensions directory or in the <code>PATH</code>.</p> <pre><code>cat &lt;&lt; EOF &gt; ~/.hub/hub-hello\n#!/bin/sh\necho \"Hello from custom extension\"\nEOF\n\nchmod +x ~/.hub/hub-hello\n\nhubctl ext hello\n# Hello from custom extension\n</code></pre> Flag Description Required <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-ext/#see-also","title":"See Also","text":"<ul> <li><code>hubctl extensions</code></li> <li><code>hubctl</code></li> </ul>"},{"location":"hubctl/cli/hubctl-extensions-install/","title":"Command: <code>hubctl extensions install</code>","text":"<p>Install hubctl extension from repository</p> <p>Repository: https://github.com/epam/hub-extensions</p> <pre><code>hubctl extensions install &lt;dir&gt;\n</code></pre> <p>This command accepts optional positional parameter <code>&lt;dir&gt;</code>, which defaults to <code>~/.hub</code></p> <p>These parameters applies across all extension commands</p> Flag Description Required <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-extensions-install/#dependencies","title":"Dependencies","text":"<p>This command requires git to be installed and available in PATH</p>"},{"location":"hubctl/cli/hubctl-extensions-install/#see-also","title":"See Also","text":"<ul> <li><code>hubctl extensions</code></li> </ul>"},{"location":"hubctl/cli/hubctl-extensions-update/","title":"Command: <code>hubctl extensions update</code>","text":"<p>Update hubctl extension from repository to the latest</p> <p>Repository: https://github.com/epam/hub-extensions</p> <pre><code>hubctl extensions update &lt;dir&gt;\n</code></pre> <p>This command accepts optional positional parameter <code>&lt;dir&gt;</code>, which defaults to <code>~/.hub</code></p> <p>These parameters applies across all extension commands</p> Flag Description Required <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-extensions-update/#dependencies","title":"Dependencies","text":"<p>This command requires git to be installed and available in PATH</p>"},{"location":"hubctl/cli/hubctl-extensions-update/#see-also","title":"See Also","text":"<ul> <li><code>hubctl extensions</code></li> </ul>"},{"location":"hubctl/cli/hubctl-extensions/","title":"Command: <code>hubctl extensions</code>","text":"<p>This command manges hubctl extensions</p> Command Description <code>hubctl extensions install</code> Install hubctl extensions from repository <code>hubctl extensions updates</code> Downloads latest from repository <p>These parameters applies across all extension commands</p> Flag Description Required <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-extensions/#see-also","title":"See Also","text":"<ul> <li><code>hubctl</code></li> </ul>"},{"location":"hubctl/cli/hubctl-show/","title":"Command: <code>hubctl show</code>","text":"<p>Helps to browse parameters for deployment</p>"},{"location":"hubctl/cli/hubctl-show/#parameters","title":"Parameters","text":"Flag Description Required <code>-q  -jq --query</code> Apply a <code>jq</code> style filter query to the command results <code>-o --split</code> By default, input and output parameters of a stack has been merged. If you want to split them into two different group to view specifically input or output parameters, then use this flag <code>-m --machine</code> By default parameters exported in a flat manner as a Key-Value pair. Yet you may want instead to present parameters as a <code>.</code> (dot) delimited objects. This can significantly simplify scripting when you want to wire deployment outputs with your specific automation <code>-c --component</code> Show input and ouptut parameters of a specific component in the stack. <code>--</code> For advanced case: when you want to supply some <code>jq</code> native arguments to the <code>hubctl show</code> command. Check out <code>jq --help</code> for allowed values"},{"location":"hubctl/cli/hubctl-show/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-show/#usage-example","title":"Usage Example","text":"<p>To show all parameters of a stac</p> <pre><code>hubctl show\n</code></pre> <p>To show domain name of a stack</p> <pre><code>hubctl show -q '.parameters.dns.domain'\n</code></pre> <p>To show password of a <code>mysql</code> component in the stack</p> <pre><code>hubctl show -c 'mysql' -q '.outputs.component.mysql.password'\n</code></pre>"},{"location":"hubctl/cli/hubctl-show/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack</code></li> <li><code>hubctl toolbox</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-backup/","title":"Command: <code>hubctl stack invoke</code>","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/cli/hubctl-stack-configure/","title":"Command: <code>hubctl stack configure</code>","text":"<p>Reads configuration information in one or multiple hubfiles referenced by the command <code>hubctl stack init</code> and applies configuration before the stack deployment.</p> <p>When hubfile will require parameter supplied bia environment variable (<code>fromEnv</code>) ,for instance passwords or access credentials, then this command will save value for this variable in <code>.env</code> file. You can change this value later by modifying <code>.env</code> file.</p> <p>Upon completion of configure command execution will ensure that all stack input parameters has been defined.</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#configuration-requirements","title":"Configuration requirements","text":"<p>Input parameters can be supplied by various scripts. Which exactly and it's order has been defined in hubfile via requirements</p> <pre><code>extensions:\n  configure:\n  - env\n  - gcp\n</code></pre> <p>List of supported requirements for configuration</p> Requirement Description <code>gcp</code> Configures stack for deployment to GCP. Will bootstrap a DNS zone (optionally relying to bubble dns service) and a GCS bucket to store state <code>aws</code> Configures stack for deployment to AWS. Will bootstrap a Route53 zone (optionally relying to bubble dns service) and a S3 bucket to store state. This will make sure that credentials has been reachable for the deployment <code>azure</code> Similar to <code>aws</code> and <code>gcp</code> will configure stack for Microsoft Azure Cloud deployment <code>env</code> Ensures that all environment variables (<code>fromEnv</code>) has been defined by the user <code>kubernetes</code> Reserved when user already have got a running Kubernetes cluster. This requirement may conflict if stack will actually deploy a new cluster. This requirement will ensure that kubernetes credentials stored in kubeconfig has been reachable by the kubeconfig by creating py of just one kube-context in <code>.hub/env</code> directory <code>components</code> DEPRECATED. Functionality of this requirement has been moved to  <code>hubctl stack init</code> command <code>backup</code> Activate backup/restore functionality for the stack (note that at least one component should accept verb <code>backup</code>)"},{"location":"hubctl/cli/hubctl-stack-configure/#command-parameters","title":"Command Parameters","text":"<p>These parameters applies across all extension commands. If hubfile contains additional requirements then there may be additional command parameters</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#common-parameters","title":"Common parameters","text":"Flag Description Required <code>-r --requirement &lt;arg&gt;</code> Specific one or multiple (this parameter can repeat) requirements to apply for reconfiguration. If no requirements provided, then this means all requirements as specified in hubfile <code>--profile &lt;arg&gt;</code> Set specific deployment profile <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-configure/#google-cloud-platform","title":"Google Cloud Platform","text":"<p>Flags specific to <code>gcp</code> parameters</p> Flag Description Required <code>--gcp-project-id  &lt;arg&gt;</code> Override project id in <code>.env</code> file <code>--gcs-bucket-name  &lt;arg&gt;</code> Override GCS bucket name (defaults to: <code>gs://&lt;project_id&gt;-superhub</code>) <code>--domain-name &lt;arg&gt;</code> Instructs to use a specific domain name (otherwise will be autogenerated by bubble DNS service)"},{"location":"hubctl/cli/hubctl-stack-configure/#amazon-web-services","title":"Amazon Web Services","text":"<p>Flags specific to <code>aws</code> parameters</p> Flag Description Required <code>--aws-region &lt;arg&gt;</code> Use specific AWS region (otherwise default from AWS profile will be used) <code>--aws-profile &lt;arg&gt;</code> Use specific AWS profile (otherwise current or default profile will be used) <code>--aws-profile &lt;arg&gt;</code> Use specific AWS profile (otherwise current or default profile will be used) <code>--domain-name &lt;arg&gt;</code> Instructs to use a specific domain name (otherwise will be autogenerated by bubble DNS service) <code>--base-domain-aws-profile &lt;arg&gt;</code> To address case when parent hosted zone managed in different AWS account <code>--prefer-local</code> Instructs not to use hubctl state in S3 bucket <code>--dns-update</code> Instructs bubble DNS service to update TTL on existing DNS record (instead of requesting new random record) <code>--bubbles-secret-key &lt;arg&gt;</code> User provides bubble dns secret that will proof his ownership on stack. Otherwise value from .env file will be used"},{"location":"hubctl/cli/hubctl-stack-configure/#microsoft-azure-cloud","title":"Microsoft Azure Cloud","text":"<p>Flags specific to <code>azure</code> parameters</p> Flag Description Required <code>--azure-region &lt;arg&gt;</code> Use specific Azure region (otherwise default from AWS profile will be used) <code>--azure-resource-group &lt;arg&gt;</code> Azure Resource Group (defaults to value from: <code>AZURE_RESOURCE_GROUP_NAME</code>, <code>AZURE_DEFAULTS_GROUP</code> environment variables) <code>--azure-subscription &lt;arg&gt;</code> Azure Resource Group (defaults to value from: <code>AZURE_SUBSCRIPTION_ID</code>) <code>--base-domain-resource-group &lt;arg&gt;</code> and <code>--base-domain-subscription &lt;arg&gt;</code> To address case when parent hosted zone managed in different AWS account <code>--prefer-local</code> Instructs not to use hubctl state in S3 bucket <code>--dns-update</code> Instructs bubble DNS service to update TTL on existing DNS record (instead of requesting new random record) <code>--bubbles-secret-key &lt;arg&gt;</code> User provides bubble dns secret that will proof his ownership on stack. Otherwise value from .env file will be used"},{"location":"hubctl/cli/hubctl-stack-configure/#environment-variables","title":"Environment Variables","text":"<p>Flags specific to <code>env</code> parameters</p> Flag Description Required <code>-f --file &lt;arg&gt;</code> Ask for variables from only specific hubfiles (defaults to <code>HUB_FILES</code> variable in <code>.env</code> file,  can repeat multiple time) <code>--defaults</code> Instructs not to confirm user input for environment variables (reserved for non-interactive usage, such as CI server)"},{"location":"hubctl/cli/hubctl-stack-configure/#kubernetes","title":"Kubernetes","text":"<p>Flags specific to <code>kubernetes</code> parameters</p> Flag Description Required <code>--kubeconfig &lt;arg&gt;</code> Path to kubeconfig. Otherwise <code>KUBECONFIG</code> environment variable will be used. <code>--kubecontext &lt;arg&gt;</code> Use specific context inside kubeconfig. Otherwise current will be used <code>--current-kubecontext</code> or <code>--kubecontext _</code> Explicitly says to use current kube-context <p>Note: If you want to run configure from the pod (inside kubernetes). This extension configure stack to rely on service account of the pod</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#components-deprecated","title":"Components (deprecated)","text":"<p>Please use new command: <code>hubctl stack init</code> instead</p> Flag Description Required <code>-f --file &lt;arg&gt;</code> Instructs to use specific hubfiles (defaults to <code>HUB_FILES</code> variable in <code>.env</code> file,  can repeat multiple time) <code>-c --component &lt;arg&gt;</code> Ask to download a specific component only (can repeat multiple times, defaults to all components defined in hubfiles) <code>--override</code> Write over files if component already exists <p>Note: If you want to run configure from the pod (inside kubernetes). This extension configure stack to rely on service account of the pod</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#dyi-configuration","title":"DYI Configuration","text":"<p>Can I build my own configuration script for my custom case? Or override behavior of existing one? Yes just follow couple of simple steps</p> <ol> <li>Create file: <code>&lt;working-dir&gt;/.hub/&lt;requirement&gt;/configure</code> and add execution rights</li> <li>Write your script using: <code>shell</code> (preferably), <code>bash</code> or general purpose language of your choice.</li> <li>Add reference to the hub.yaml</li> </ol> <pre><code># example\nmkdir -p \".hub/mysuperextension\"\ntouch \".hub/mysuperextension/configure\"\nchmod +x \".hub/mysuperextension/configure\"\n</code></pre> <p>then feel free to add reference that looks like the following to the <code>hub.yaml</code></p> <pre><code>extensions:\n  configure:\n  - mysuperextension\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-configure/#usage-example","title":"Usage Example","text":"<p>Configure stack before deployment</p> <pre><code>hubctl stack configure\n</code></pre> <p>Reload GCP configuration, and refresh TTL for bubble DNS service</p> <pre><code>hubctl stack configure -r \"gcp\"\n</code></pre> <p>Configure refresh kubeconfig for kubernetes cluster (if access rotated)</p> <pre><code>hubctl stack configure -r \"kubernetes\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-configure/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack init</code></li> <li><code>hubctl stack deploy</code></li> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-deploy/","title":"Command: <code>hubctl stack deploy</code>","text":"<p>Runs deployment for entire stack or updates deployment of one or few components</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#command-parameters","title":"Command Parameters","text":"Flag Description Required <code>-c --component &lt;component&gt;</code> Run deployment for one  component or multiple (supplied as comma separated value) <code>-o --offset &lt;component&gt;</code> Start deployment from specific component (handy when you want to restart deployment, and want to skip few from the beginning in the run-list) <code>-l --limit &lt;component&gt;</code> Stop deployment after desired (opposite to <code>--offset</code> flag) <code>--profile</code> Choose a specific deployment provider (defaults to <code>HUB_PROFILE</code> in <code>.env</code> file) <code>--tty</code> or <code>--no-tty</code> Instructs if user wants to group deployment outputs per component"},{"location":"hubctl/cli/hubctl-stack-deploy/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-deploy/#advanced-usage","title":"Advanced usage","text":""},{"location":"hubctl/cli/hubctl-stack-deploy/#hooks-for-before-deployment-and-after-deployment","title":"Hooks for before-deployment and after-deployment","text":"<p>It is possible if user will decide to add one or more deployment hooks. This hooks will be executed before or after the deployment has been done.</p> <p>These deployment hooks has been defined via hubfile</p> <pre><code>extensions:\n  deploy:\n    before:\n    - &lt;extension&gt;\n    after:\n    - &lt;extension&gt;\n</code></pre> <p>example:</p> <pre><code>extensions:\n  deploy:\n    before:\n    - kubernetes\n    after:\n    - inventory-configmap\n</code></pre> <p>Example above will run a kubernetes extension before the deployment to check connectivity to the desired cluster. It will also instruct a <code>hub</code> to save deployment state inside of the Kubernetes cluster as a <code>configmap</code>. This is viable alternative to the object storage and can be handy to store copy of a state for on-prem deployments.</p> <p>At the moment there are few extensions that supports before deployment or after deployemnt</p> Extension Description Before After <code>kubernetes</code> Checks connectivity to existing kubernetes cluster before actual deployment (helps with deployment success rate) x x <code>aws-metering</code> Provides integration to aws marketplace metering x <code>inventory-configmap</code> Save a copy of a deployment state in the configmap of a kubernetes cluster. Adds some extra persistence for on-prem deployments as they might not have object storage bucket access to store state there x"},{"location":"hubctl/cli/hubctl-stack-deploy/#define-run-list","title":"Define run-list","text":"<p>By default run-list has been derived from the components definition following the algorithm:</p> <ol> <li>Component listed as dependency should run before the component that depends on it</li> <li>Component without dependency should run in the order of declaration</li> </ol> <p>However user can overwrite order by defining a custom run-list in the <code>hub.yaml</code> file</p> <p>Component run-list order has been defined in hubfile. It looks like below.  Then the User will maintain run-list order when they add or remove the component</p> <pre><code>lifecycle:\n  order:\n  - component1\n  - component2\n  # ...\n  - componentN\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-deploy/#dyi-deployment-hook","title":"DYI deployment hook","text":"<p>Q: Can I add my own deployment hook? A: Yes, easy!</p> <ol> <li>Create a file in the <code>.hub/&lt;extension&gt;/before-deploy</code> and add execution rights</li> <li>Implement hook using shell (preferably), bash, or language of your choice</li> </ol> <p>Q: Which shell hooks I can build? A: Make sure you follow the naming convention for file name</p> Script Description <code>before-deploy</code> Executed before deployment operation, fail with error code non 0 to stop deployment from happening <code>after-deploy</code> Executed before deployment operation, fail with error code non 0 to mark deployment as failed. Useful when you apply some deployment tests <code>before-undeploy</code> Executed before un-deployment operation, fail with error code non 0 to stop un-deployment from happening <code>after-undeploy</code> Executed before un-deployment operation, fail with error code non 0. Useful if you want to check that all resources has been deleted and grab user attention on some cloud junk"},{"location":"hubctl/cli/hubctl-stack-deploy/#executors","title":"Executors","text":"<p>There are few ways how to run a deployment, It primarilly depends on if this is a desire of the user where they want to have all desired provisioning tools setup and keep updated periodically. User also might  want to run deployment from CI server etc. This is why we have got different deployment profiles</p> <p>Executor has been configured in <code>.env</code> file via environment variable <code>HUB_DEPLOY_PROFILE</code>. This variable has been set during the <code>configure</code> time, but can be changed by editing <code>.env</code> file</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#executor-local","title":"Executor: <code>local</code>","text":"<p>This profile has been preferable when user wants to run all automation from their local workstation. User also have got all provisioning tools required by the stack (such as <code>terraform</code>, <code>helm</code> or <code>kustomize</code>) installed locally. This profile gives fastest feedback if something goes wrong and direct tools to troubleshoot</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#executor-toolbox","title":"Executor: <code>toolbox</code>","text":"<p>If you have a docker locally then you may not want to install all provisioning tools. Instead <code>toolbox</code> profile will run a special Docker container with all tools installed and then mount your working diretory inside. This deployment profile is handy to work in a team and  address works on my workstation issues as every team member will work with exactly the same toolchain that comes with toolbox container</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#executor-pod","title":"Executor: <code>pod</code>","text":"<p>This is evolution of a toolbox profile. Instead, if you have a Kubernetes cluster at your disposal, you may want to run an automation task as a Kubernetes native pod. This pod will do the following</p> <ol> <li>Run a <code>toolbox</code> container in a Kubernetes namespace <code>automation-tasks</code></li> <li>Copy a working directory inside of a <code>pod</code></li> <li>Copy credentials such as <code>aws</code> or <code>kubernetes</code></li> <li>Run automation task</li> <li>Collect the result and store locally state</li> <li>Shut down the container</li> </ol>"},{"location":"hubctl/cli/hubctl-stack-deploy/#diy-executor","title":"DIY executor","text":"<p>If you want to build your own deployment profile, then put a script into the <code>.hub/profiles/&lt;profile-name&gt;</code> directory and add execution rights. Then update environment variable <code>HUB_DEPLOY_PROFILE</code> in the <code>.env</code></p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#usage-example","title":"Usage Example","text":"<p>To deploy all components in the run-list:</p> <pre><code>hubctl stack deploy\n</code></pre> <p>To deploy specific components with order defined in the run-list</p> <pre><code>hubctl stack deploy -c \"external-dns,cert-manager\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-deploy/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack undeploy</code></li> <li><code>hubctl stack configure</code></li> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-elaborate/","title":"Command: <code>hubctl stack elaborate</code>","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/cli/hubctl-stack-init/","title":"Command: <code>hubctl stack init</code>","text":"<p>This command initializes working directory containing a hubfile (<code>hub.yaml</code>). This is the first command that you should run when you start working with a new stack.</p>"},{"location":"hubctl/cli/hubctl-stack-init/#usage","title":"Usage","text":"<p>Depending on your needs there are few ways to initialize a stack in the current directory:</p> <p><code>hubctl stack init [options]</code></p> <p>This command will perform different initialization steps in order to prepare you current working directory for deployment</p>"},{"location":"hubctl/cli/hubctl-stack-init/#download-hubfiles","title":"Download Hubfiles","text":"<p>Activated when flag: <code>-f URL</code> supplied.</p> <p>Hubctl will download a hubfile referenced with <code>-f</code> flag and save it to the current directory. Then it will download any other parameters file referenced in the hubfile and save it to the current directory.</p> <pre><code># hub.yaml\nextensions:\n  include:\n  - params.yaml\n</code></pre> <p>Example above shows a <code>parameter.yaml</code> referenced in hubfile. It will be downloaded and saved to the current directory. URL of this file will be interpreted as relative to the URL of the hubfile.</p> <p>If you have multiple hubfiles but you don't want to keep a direct reference in <code>hub.yaml</code> (when you have parameter files per environment, or your environments have different components). Then use flag <code>-f &lt;hubfile or URL&gt;</code> multiple times</p>"},{"location":"hubctl/cli/hubctl-stack-init/#download-configuration-scripts","title":"Download Configuration Scripts","text":"<p>In a similar way hubctl will download a deployment hooks referenced in the hubfile</p> <pre><code>extensions:\n  init:\n  - bin/my-init-script.sh\n  configure:\n  - bin/my-configure-script.sh\n  deploy:\n    before:\n    - bin/my-before-deploy-script.sh\n    after:\n    - bin/my-after-deploy-script.sh\n  undeploy:\n    before:\n    - bin/my-before-undeploy-script.sh\n    after:\n    - bin/my-cleanup-script.sh\n</code></pre> <ol> <li>Download init scripts referenced in the hubfile</li> <li>Download configure scripts referenced in the hubfile</li> <li>Download before and after deploy (undeploy)</li> </ol>"},{"location":"hubctl/cli/hubctl-stack-init/#download-deployment-hooks","title":"Download Deployment Hooks","text":"<pre><code>components:\n- name: external-dns\n  source:\n    dir: components/external-dns\n  hooks:\n  - file: bin/do-something\n    triggers:\n    - pre-deploy\n    - post-undeploy\n</code></pre> <p>When hubfile refers component deployment hooks, hubctl will download them and save to the current directory</p>"},{"location":"hubctl/cli/hubctl-stack-init/#download-component-sources","title":"Download Component Sources","text":"<p>Next steps hubctl will download components if directory referenced in the hubfile does not exist.</p> <pre><code>components:\n- name: external-dns\n  source:\n    dir: components/external-dns\n    git:\n      remote: https://github.com/epam/hub-kubeflow-components.git\n      ref: develop\n      subDir: external-dns\n</code></pre> <p>For more details see Components Reference.</p>"},{"location":"hubctl/cli/hubctl-stack-init/#initialize-from-remote-state","title":"Initialize from Remote State","text":"<p>There is an option to initialize stack from remote state. This is useful when you do not have state locally or it has been deployed by someone else.</p> <p>Run the command:</p> <pre><code>hubctl stack init \"&lt;remote-state-url&gt;\"\n</code></pre> <p>This command will download remote state and initialize <code>.env</code> variables from parameters listed in the state. Then you should be able to interact with the stack or it's components as usual.</p>"},{"location":"hubctl/cli/hubctl-stack-init/#stack-name-and-domain-names","title":"Stack Name and Domain Names","text":"<p>When you initialize a stack, hubctl will generate a random stack name unless hubfile contains exact value of stack name. When stack is using a publicly available domain name, then hubctl will use it as a stack name.</p> <p>See on how to autogenerate domain names here: Domain Names</p>"},{"location":"hubctl/cli/hubctl-stack-init/#command-parameters","title":"Command Parameters","text":"Flag Description Required <code>-f --file &lt;hubfile&gt;</code> path (or URL) to hubfile with stack definitions. This argument can repeat multiple times x <code>-s --state &lt;statefile&gt;</code> Path or URL to <code>--force</code> Specify this fag if current stack has been already initialized. This flag will overwrite existing configuration"},{"location":"hubctl/cli/hubctl-stack-init/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-init/#usage-example","title":"Usage Example","text":"<p>Example on how to initialize a new stack to deploy a GKE cluster</p> <pre><code>hubctl stack init -f \"https://hubctl.io/tutorials/020-shell-component/hub.yaml\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-init/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack configure</code></li> <li><code>hubctl stack</code></li> <li>Domain Names</li> </ul>"},{"location":"hubctl/cli/hubctl-stack-invoke/","title":"Command: <code>hubctl stack invoke</code>","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/cli/hubctl-stack-ls/","title":"Command: <code>hubctl stack ls</code>","text":"<p>Useful command when you have deployment multiple stacks from the one working directory it will help you to navigate across them</p> <p>It prints stack domain name as an identifier and marks which has been set as a active with the <code>*</code> symbol</p> <p>See example below</p> <pre><code>hubctl stack ls\n# ACTIVE  STACK                 STATUS      TIMESTAMP\n# *       disastrous-lundy-871  undeployed  2023-04-13T13:11:50\n#         funny-ray-ray-795     deployed    2023-04-13T13:09:14\n</code></pre> <p>Most likely the stack has been initialized with <code>hubctl stack init</code> command however not yet configured (<code>hubctl stack configure</code>)</p>"},{"location":"hubctl/cli/hubctl-stack-ls/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack use</code></li> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-rm/","title":"Command: <code>hubctl stack rm</code>","text":"<p>This command is basically deletes stack configuration created via <code>hubctl stack init</code> or <code>hubctl stack configure</code> commands.</p> <p>This command won't undeploy a stack if it has been deployed</p> <p>Common usage scenario is actually a clean up your working directory from stacks that has been previously undeployed and you don't have use of them anymore</p>"},{"location":"hubctl/cli/hubctl-stack-rm/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-undeploy/","title":"Command: <code>hubctl stack undeploy</code>","text":"<p>Reverse deployment operation for entire stack or particular components</p> <p>Because <code>undeploy</code> is a reverse operation to <code>deploy</code>, you might want to check out article for <code>hubctl stack deploy</code> sections about executors and deployment hooks.</p>"},{"location":"hubctl/cli/hubctl-stack-undeploy/#command-parameters","title":"Command Parameters","text":"Flag Description Required <code>-c --component &lt;component&gt;</code> Start un-deployment for one  component or multiple (supplied as comma separated value) <code>-o --offset &lt;component&gt;</code> Start un-deployment from specific component (handy when you want to restart un-deployment, and want to skip few from the beginning in the run list) <code>-l --limit &lt;component&gt;</code> Stop un-deployment after desired (opposite to <code>--offset</code> flag) <code>--profile</code> Choose a specific un-deployment provider (defaults to <code>HUB_PROFILE</code> in <code>.env</code> file) <code>--tty</code> or <code>--no-tty</code> Instructs if user wants to group outputs per component"},{"location":"hubctl/cli/hubctl-stack-undeploy/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-undeploy/#usage-example","title":"Usage Example","text":"<p>To un-deploy all components in the run-list:</p> <pre><code>hubctl stack undeploy\n</code></pre> <p>To un-deploy specific components with order defined in the run-list</p> <pre><code>hubctl stack undeploy -c \"external-dns,cert-manager\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-undeploy/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack deploy</code></li> <li><code>hubctl stack rm</code></li> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-use/","title":"Command: <code>hubctl stack use</code>","text":"<p>Set stack by it's name as a current.</p> <p>Example</p> <pre><code>hubctl stack ls\n# ACTIVE  STACK                 STATUS      TIMESTAMP\n# *       disastrous-lundy-871  undeployed  2023-04-13T13:11:50\n#         funny-ray-ray-795     deployed    2023-04-13T13:09:14\n\nhubctl stack use \"funny-ray-ray-795\"\n\nhubctl stack ls\n# ACTIVE  STACK                 STATUS      TIMESTAMP\n#         disastrous-lundy-871  undeployed  2023-04-13T13:11:50\n# *       funny-ray-ray-795     deployed    2023-04-13T13:09:14\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-use/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack ls</code></li> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack/","title":"Command: <code>hubctl stack</code>","text":"<p>Helps you to manage your stack deployments</p>"},{"location":"hubctl/cli/hubctl-stack/#sub-commands","title":"Sub-commands","text":"<p>Extensions provides following commands:</p> Command Description <code>hubctl stack init</code> Initialise a new stack deployment in the working directory <code>hubctl stack configure</code> Manage configuration before the deployment <code>hubctl stack deploy</code> Apply deployment to target infrastructure <code>hubctl stack undeploy</code> Reverse deployment action <code>hubctl stack ls</code> See other stacks that has been initialized for the working directory <code>hubctl stack use</code> Change a different current stack <code>hubctl stack rm</code> Delete configuration of a stack from working directory. This commands is non-reversible, and doesn't run <code>undeploy</code>"},{"location":"hubctl/cli/hubctl-stack/#advanced-commands","title":"Advanced Commands","text":"<p>These commands intended for advanced usage</p> Command Description <code>hubctl stack backup</code> Stack backup/restore management (*if \"backup\" verb supported by at least one component in the stack) <code>hubctl stack elaborate</code> Reconcile defined parameters and a state <code>hubctl stack invoke</code> Execute other verb rather than <code>deploy</code>, <code>undeploy</code> or <code>backup</code>. (*if verb supported by at least one component in the stack) <code>hubctl stack explain</code> Command reserved for state and parameters diagnostics"},{"location":"hubctl/cli/hubctl-stack/#common-flags","title":"Common Flags","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack/#see-also","title":"See Also","text":"<ul> <li><code>hubctl</code></li> </ul>"},{"location":"hubctl/cli/hubctl-toolbox/","title":"Command: <code>hubctl toolbox</code>","text":"<p>This command will run a toolbox container in interactive mode and will let you to deploy stack without having to install all necessary tools besides a docker</p> <p>Actually this command performs the following actions</p> <ol> <li>Pull a docker image</li> <li>Use current directory as a working directory inside of the image</li> <li>Run a toolbox in interactive shell</li> </ol>"},{"location":"hubctl/cli/hubctl-toolbox/#command-parameters","title":"Command Parameters","text":"Flag Description Default <code>-i --toolbox-image &lt;docker-image&gt;</code> Use docker image for a docker toolbox var: <code>HUB_TOOLBOX_IMAGE</code> or <code>ghcr.io/epam/hub-toolbox:base</code>"},{"location":"hubctl/cli/hubctl-toolbox/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-toolbox/#usage-example","title":"Usage Example","text":"<p>To start a toolbox container and run a deployment from inside</p> <pre><code>hubctl toolbox\n# wait a docker pull\n# see a docker shell instead\nhubctl stack deploy\nexit\n</code></pre>"},{"location":"hubctl/cli/hubctl-toolbox/#see-also","title":"See also","text":"<ul> <li><code>hubctl</code></li> </ul>"},{"location":"hubctl/design-and-architecture/","title":"Design and Architecture","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/extensions/","title":"Extensions","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/hooks/","title":"Hooks","text":"<p>Lorem ipsum...</p>"},{"location":"reference/","title":"Hubfile","text":"<p>Hubfiles defines a stack, parameters and components. Each component has it's own manifest. </p> <ul> <li>Stack manifest file <code>hub.yaml</code> and optional <code>param.yaml</code> defined on the top level. </li> <li>Components are defined in the <code>components</code> directory. Each have a hubfile <code>hub-component.yaml</code> that defines the structure of the component and rules how to deploy it. </li> </ul>"},{"location":"reference/#directory-structure","title":"Directory Structure","text":"<p>While directory structure has not been fixed. yet we recommend the following:</p> <pre><code>\u251c\u2500\u2500 bin\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 deployment-hook.sh       \n\u251c\u2500\u2500 components\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 component1\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 hub-component.yaml\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 deploy.sh\n\u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 undeploy.sh\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 component2\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 hub-component.yaml\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 main.tf\n\u251c\u2500\u2500 hub.yaml\n\u2514\u2500\u2500 params.yaml\n</code></pre> <p>In this example the<code>component1</code> uses shell to deploy. It <code>deploy.sh</code> and <code>undeploy.sh</code>. </p> <p>The <code>component2</code> is using Terraform, and contains <code>*.tf</code> file (or files)</p> <p>Hubfile <code>hub.yaml</code> can define a deployment hooks, something that needs to be executed before or after individual component deployment. This webhook has been placed in the <code>bin</code> directory.</p>"},{"location":"reference/#see-also","title":"See Also","text":"<ul> <li>Hubfiles</li> <li>Hubctl Components</li> </ul>"},{"location":"reference/components/","title":"Components","text":"<p>Component is a piece of software that can be deployed and undeployed that actually makes sense. Components could be anything - hubctl is not tied to any particular automation technology the only requirements are:</p> <ul> <li>Automation code that hubctl knows how to deploy. This can be as simple as shell script or more advanced such as ARM template or Terraform.</li> <li><code>hub-component.yaml</code> that describes component requirements, input and output parameters. Parameters can be passed to the automation code via environment variables or via templates.</li> </ul> <p>Optionally component could have:</p> <ul> <li><code>Template</code> - probably  way how to inject parameters from <code>hub-componet.yaml</code> to automation. Hubctl supports both string replacement and go-templates.</li> <li><code>pre-deploy</code> and <code>post-deploy</code> hooks - scripts that will be executed before and after component deployment.</li> </ul>"},{"location":"reference/components/#automation-code","title":"Automation Code","text":"<p>By design hubctl is not tied to any particular automation technology. However we have got prebuilt support for most popular automation tools</p>"},{"location":"reference/components/#shell-script","title":"Shell Script","text":"<p>Most flexible way and the most simple one. You only need to define a two scripts and pass parameters via environment variables.</p> <ul> <li><code>deploy.sh</code> - script that will be executed during component deployment</li> <li><code>undeploy.sh</code> - script that will reverse deployment. Every component should have undeploy script.</li> </ul> <p>Configuration can be passwd via environment variables defined in <code>hub-component.yaml</code> file. Hubctl will not pass any arguments to the scripts</p>"},{"location":"reference/components/#helm","title":"Helm","text":"<p>Helm is a package manager for Kubernetes. Hubctl will automatically detect Helm charts when component contains a <code>values.yaml</code> file.</p>"},{"location":"reference/components/arm/","title":"ARM Deployment Template","text":"<p>ARM templates are used to deploy resources to Azure. They are written in JSON and can be used to deploy a single resource or a set of resources. They can be used to deploy resources to a new resource group or to an existing resource group. They can be used to deploy resources to a new subscription or to an existing subscription.</p> <p>Hubctl can deploy ARM templates as a component. Hubctl will use the Azure CLI to deploy the ARM template.</p>"},{"location":"reference/components/arm/#arm-conventions","title":"ARM Conventions","text":"<p>To enable hubctl to recognize component as an ARM deployment component, User should add <code>arm</code> requirements to <code>hub-component.yaml</code> file:</p> <pre><code>requires:\n- azure\n- arm\n</code></pre>"},{"location":"reference/components/arm/#input-parameters","title":"Input parameters","text":"<p>There are number of well-known parameters that can be used to configure ARM deployment. These parameters are defined in <code>hub-component.yaml</code> file. Today there is no strict convention for parameter names. User is free to choose any parameter name they like, however these parameters should be bound to the specific environment variables.</p> Variable Description Required Passed from <code>.env</code> <code>ARM_TEMPLATE</code> Local file or URI to the ARM Deployment Template. If not set then hubctl will try to find deployment template by schema in component directory <code>ARM_DEPLOYMENT_NAME</code> Name associated to the ARM Deployment. If not set then name of the component will be used <code>ARM_PARAMETER_FILES</code> Space separated list to ARM Deployment Parameter files. If file cannot be found it will be ignored <code>ARM_PARAMETER_paramName</code> Hubctl will read all environment variables prefixed with <code>ARM_PARAMETERS_</code> to set ARM deployment parameters. In this example hubctl will set a parameter <code>parameterName</code> with the value of environment variable <code>ARN_PARAMETER_paramName</code> <code>ARM_PARAM_paramName</code> Same as <code>ARM_PARAMETER_paramName</code> <code>AZURE_RESOURCE_GROUP_NAME</code> Name of the target resource group. If not set then resource group defined during <code>hub stack configure -r \"azure\"</code> will be used <p>Note: <code>ARM_PARAMETER_</code> and <code>ARM_PARAM_</code> are aliases for the same parameter. User can use either one of them. These environment variables works similar to well known Terraform variables <code>TF_VAR_</code>.</p>"},{"location":"reference/components/arm/#deployment-hooks","title":"Deployment Hooks","text":"<ul> <li><code>pre-deploy</code> to trigger action before ARM Deployment template will be created</li> <li><code>post-deploy</code> to trigger action after ARM Deployment template will be created</li> <li><code>pre-undeploy</code> to trigger action before ARM Deployment template will be deleted</li> <li><code>post-undeploy</code> to trigger action before ARM Deployment template will be deleted</li> </ul> <p>Note: pre and post deployment scripts should have execution rights</p>"},{"location":"reference/components/arm/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> </ul>"},{"location":"reference/components/helm/","title":"Helm Component","text":"<p>Helm is a popular packaging technology for Kubernetes applications. We do provide our own opinionated way how to deploy helm components.</p>"},{"location":"reference/components/helm/#component-conventions","title":"Component Conventions","text":"<p>If component follows the conventions below, then hubctl will know how to deploy it.</p>"},{"location":"reference/components/helm/#helm-detection","title":"Helm Detection","text":"<p>When you want to use helm deployment add the following definition to the <code>hub-component.yaml</code></p> <pre><code>requires:\n- kubernetes\n- helm\n</code></pre> <p>and place one one of the following files in the component directory: <code>values.yaml</code>, <code>values.yaml.template</code> or <code>values.yaml.gotemplate</code></p> <p>Then hubctl will be able detect this component as helm component and call provisioning script: helm-component-deploy .</p>"},{"location":"reference/components/helm/#input-parameters","title":"Input parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required <code>DOMAIN_NAME</code> FQDN of a stack. We use this parameter as a natural id of the deployment (defaults to implicit variable <code>HUB_DOMAIN_NAME</code>). Usage of this variables requires user to define a parameter <code>dns.domain</code> in <code>hub-component.yaml</code>. Yet we advice to use instead an implicit variable <code>HUB_DOMAIN_NAME</code> instead <code>COMPONENT_NAME</code> Corresponds to parameter <code>hub.componentName</code> parameter, however can be overriden in <code>hub-component.yaml</code>. Hub will use this variable as a helm release name x <code>NAMESPACE</code> Target kubernetes namespace x <code>HELM_CHART</code> This can have multiple values, that corresponds to the helm chart location. Corresponds to the helm chart tar url, tarball, directory or a chart name in the repository x <code>HELM_REPO</code> Instructs hubctl to download helm chart from the helm repository <code>HELM_CHART_VERSION</code> Addes a version constraint to the helm chart install. This variable works in conjunction with <code>HELM_REPO</code> <code>HELM_CHART_USERNAME</code> and <code>HELM_CHART_PASSWORD</code> Username and password for helm chart repository basic auth <code>CHART_VALUES_FILE</code> Instructs hubctl that it must use concrete values file inside of the helm chart as the base and only override with parameters from <code>values.yaml</code> in the component root directory. Alternatively if this variable has prefix <code>http</code> or <code>https</code> then the file. Additional values files can be referenced by adding a whitespace (or new line) separated reference <code>CRD</code> URL or local path to the CRD file (if not located in <code>&lt;component root&gt;/crds</code> directory) <code>HELM_OPTS</code> Helm command arguments, defautls to <code>--create-namespace --wait</code>"},{"location":"reference/components/helm/#environment-variable-helm_chart","title":"Environment variable: <code>HELM_CHART</code>","text":"<p>Helm chart which user wants to deploy can be resolved via variable <code>HELM_CHART</code>. This variable corresponds to the following value:</p> <ul> <li>Path to the local directory with the helm chart (relative to the <code>&lt;component root&gt;</code> or <code>&lt;component root&gt;/charts</code> directory)</li> <li>Path to the local directory with the helm chart (relative to the <code>&lt;component root&gt;</code> or <code>&lt;component root&gt;/charts</code> directory )</li> <li>Name of the helm chart in the helm repository (requires user to define: <code>HELM_REPO</code> and <code>HELM_CHART_VERSION</code>)</li> </ul>"},{"location":"reference/components/helm/#deployment-hooks","title":"Deployment hooks","text":"<p>User can define pre and post deployment</p> <ul> <li><code>pre-deploy</code> or <code>pre-deploy.sh</code> to trigger action before helm install</li> <li><code>post-deploy</code> or <code>post-deploy.sh</code> to trigter action after successful helm install</li> <li><code>pre-undeploy</code> or <code>pre-undeploy.sh</code> to trigger action before helm delete</li> <li><code>post-undeploy</code> or <code>post-undeploy.sh</code> to trigger action after helm successful delete</li> </ul> <p>Note: pre and post deployment scripts should have execution rights</p>"},{"location":"reference/components/helm/#custom-resources","title":"Custom Resources","text":"<p>We do advise not to deploy CRD with the helm chart. Because component <code>undeploy</code> (and <code>helm delete</code> correspondingly) will also delete CRDs. Deletion of CRD will also delete custom resources that may have been deployed by the user after this component has been deployed. Instead we advise to put your CRDs in to the <code>&lt;component root&gt;/crds</code> directory. In this case, CRDs will be managed separately from the helm chart</p> <ol> <li>CRDs will be deploymed before the helm chart</li> <li>CRDs will not be deleted after component will be undeployed. Which means you can redeploy the component without dropping user custom resources</li> </ol>"},{"location":"reference/components/helm/#examples","title":"Examples","text":"<p>Nginx web server example. This is an example of a <code>hub-component.yaml</code> that will install a helm chart without any modifications. Complete code for nginx component can be found here</p> <pre><code>---\nversion: 1\nkind: component\nrequires:\n  - kubernetes\n  - helm\nprovides:\n  - nginx\n  - ingress\nparameters:\n  - name: ingress.namespace\n    value: ingress\n    env: NAMESPACE\n  - name: ingress.class\n    value: nginx\n  - name: helm\n    parameters:\n      - name: chart\n        value: nginx-ingress\n        env: HELM_CHART\n      - name: repo\n        value: https://helm.nginx.com/stable\n        env: HELM_REPO\n      - name: version\n        value: 0.13.2\n        env: HELM_CHART_VERSION\ntemplates:\n  files:\n    - values.yaml.template\n</code></pre> <p>Note: helm chart parameters values must be defined in the <code>values.yaml.template</code> alternatively you can run <code>values.yaml.gotemplate</code> file</p>"},{"location":"reference/components/helm/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> <li>Kubernetes Configuration</li> </ul>"},{"location":"reference/components/kubernetes/","title":"Kubernetes Component","text":"<p>Kubenretes is a far popular technology to run containers. We do love Kubernetes and provide  first class support with the <code>hubctl</code>. So <code>hubctl</code> will manage access credentials and provide naming conventions for Kubernetes.</p>"},{"location":"reference/components/kubernetes/#when-component-requires-kubenretes","title":"When component requires kubenretes","text":"<p>Here we provide conventions required for component if it requires kubenretes. These conventions repeat conventions for helm extensions and kustomize extensions</p> <p>File <code>hub-component.yaml</code> of the component should require <code>kubernetes</code> and expose few of the parameters as the environment variabels</p> <pre><code>requires:\n- kubernetes\nparameters:\n- name: dns.domain\n  env: HUB_DOMAIN_NAME\n- name: kubernetes.namespace # this parameter name can be anything\n  value: kube-system         # this is example of kubenretes namespace\n  env: NAMESPACE\n</code></pre> <p>More about required parameters has been described below</p> <p>Note: kubeconfig should exist before, kubernetes cluster context should match to the <code>dns.domain</code> of your stack</p>"},{"location":"reference/components/kubernetes/#input-parameters","title":"Input parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required Passed from <code>.env</code> <code>HUB_DOMAIN_NAME</code> Hub naming convention requires <code>dns.domain</code> parameter to match to kubeconfig context that corresponds to the stack, fallbacks to legacy <code>DOMAIN_NAME</code> env var. If not defined in <code>hub-component.yaml</code> manifest will be derived from stack x <code>NAMESPACE</code> Target kubernetes namespace x <p>There are additional environment variables, depends on your cloud type</p>"},{"location":"reference/components/kubernetes/#kubeconfig-helper-script","title":"Kubeconfig helper script","text":"<p>Because components de-facto has been deployed by the shell scripts. So it is natural to provide helper functionality for Kubernetes in the form of script as well.</p> <p><code>bin/kubeconfig</code> is a script that helps with kubeconfig management. This sript has been available in the <code>PATH</code> of every component that has been deployed.</p> <ul> <li><code>kubeconfig cp</code> - writes to stdout (or file) the extracted copy of a one context and user credentials. It will rename to the value of (<code>HUB_STACK_DOMAIN</code>) to follow to the <code>hubctl</code> conventions for kubernetes.</li> <li><code>kubeconfig test</code> - will test connectivity to the kubernetes cluster</li> </ul>"},{"location":"reference/components/kubernetes/#when-component-provides-kubenretes","title":"When component provides kubenretes","text":"<p>This is useful when component actually deploys a new instance of the Kubenretes cluster. Then the component has been responsible to provide outputs of a kubenretes cluster in a standard form (standard output parameters and kubeconfig). So, this can be used by following components in the runlist that requires kubernetes. This is a bit of extra effort but it will also ensure that component that requires kubernetes (and possible written by someone else) will know how to get deployed into the Kubenretes cluster providen by your component</p> <p>There are various ways how Kubenretes cluster can be deployed. So, information in the <code>hub-component.yaml</code> file will be different</p>"},{"location":"reference/components/kubernetes/#example-for-gke","title":"Example for <code>GKE</code>","text":"<p>The minimalistic GKE cluster should provide following</p> <pre><code>provides:\n- kubernetes\noutputs:\n  - name: dns.domain\n  - name: kubernetes.gke.cluster\n  - name: kubernetes.api.endpoint\n</code></pre>"},{"location":"reference/components/kubernetes/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> <li>Component Helm</li> <li>Component Kustomize</li> </ul>"},{"location":"reference/components/kustomize/","title":"Kustomize Component","text":"<p>Kustomize is a popular packaging technology for Kubernetes applications. It relies on the series of patches. Hub can provide some additional templatng capabilities as well as some smarter resource creation capabilities</p>"},{"location":"reference/components/kustomize/#component-conventions","title":"Component Conventions","text":""},{"location":"reference/components/kustomize/#kustomize-detection","title":"Kustomize Detection","text":"<p>Because kustomize has been part of <code>kubectl -k ...</code> this compoenent doesn't require any specific configuration besides just a kubernetes. So hubfile should have</p> <pre><code>requires:\n- kubernetes\n</code></pre> <p>Kustomize component has been detected by hubctl if component has following files in it's root directory:  <code>kustomization.yaml</code>, <code>kustomization.yaml.template</code> or <code>kustomization.yaml.gotemplate</code></p> <p>Then hubctl will be able detect this component as helm component and call provisioning script: hub-component-kustomize</p>"},{"location":"reference/components/kustomize/#input-parameters","title":"Input parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required <code>DOMAIN_NAME</code> FQDN of a stack. We use this parameter as a natural id of the deployment (defaults to implicit variable <code>HUB_DOMAIN_NAME</code>). Usage of this variables requires user to define a parameter <code>dns.domain</code> in <code>hub-component.yaml</code>. Yet we advice to use instead an implicit variable <code>HUB_DOMAIN_NAME</code> instead <code>NAMESPACE</code> Target kubernetes namespace x <code>HUB_KUSTOMIZE_TARBALL_URL</code> Download kustomize base from the tarball. It will unpack tarball into <code>&lt;component root&gt;/kustomize</code> directory. Then you can refer resources or bases from this directory in your <code>kustomization.yaml</code> file <code>HUB_KUSTOMIZE_TARBALL_SUBPATH</code> Works in conjuction with <code>HUB_KUSTOMIZE_TARBALL_URL</code>, it instructs to unpack to the <code>&lt;component root&gt;/kustomize</code> a subpath inside the tarball <code>HUB_KUSTOMIZE_RESOURCES</code> Necessary when resources referenced in <code>kustomize.yaml</code> file must be downloaded before deployment. This variable contains whitespace separted list of URI or local file locations <code>CRD</code> URL or local path to the CRD file (if not located in <code>&lt;component root&gt;/crds</code> directory)"},{"location":"reference/components/kustomize/#deployment-hooks","title":"Deployment hooks","text":"<p>User can define pre and post deployment</p> <ul> <li><code>pre-deploy</code> to trigger action before helm install</li> <li><code>post-deploy</code> to trigter action after successful helm install</li> <li><code>pre-undeploy</code> to trigger action before helm delete</li> <li><code>post-undeploy</code> to trigger action after helm successful delete</li> </ul> <p>Note: pre and post deployment scripts should have execution rights</p>"},{"location":"reference/components/kustomize/#custom-resources","title":"Custom Resources","text":"<p>We do advise not to deploy CRD with the helm chart. Because component <code>undeploy</code> (and <code>helm delete</code> correspondingly) will also delete CRDs. Deletion of CRD will also delete custom resources that may have been deployed by the user after this component has been deployed. Instead we advise to put your CRDs in to the  <code>&lt;component root&gt;/crds</code> directory. In this case, CRDs will be managed separately from the helm chart</p> <ol> <li>CRDs will be deploymed before the helm chart</li> <li>CRDs will not be deleted after component will be undeployed. Which means you can redeploy the component without dropping user custom resources</li> </ol>"},{"location":"reference/components/kustomize/#examples","title":"Examples","text":"<p><code>//TODO</code></p>"},{"location":"reference/components/kustomize/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> <li>Kubernetes Configuration</li> </ul>"},{"location":"reference/components/lifecycle/","title":"Section <code>lifecycle</code>","text":"<pre><code>lifecycle:\n  verbs:  # add custom verbs for `hub invoke`\n  - deploy\n  - undeploy\n  bare: true  # set to allow components without deploy or undeploy implementation\n              # usefull for creating synthetic outputs\n  readyConditions:\n  - dns: api.${dns.domain}              # resolvable\n    url:  https://api.${dns.domain}/v1  # returns something other than HTTP 500\n    waitSeconds: 600  # how long to wait for the condition\n    pauseSeconds: 0   # pause before starting poll loop\n  options:\n    random:\n      bytes: 128  # see Manifest &gt; Outputs &gt; Securing outputs\n</code></pre>"},{"location":"reference/components/makefile/","title":"Makefile Component","text":"<p>Lorem ipsum...</p>"},{"location":"reference/components/shell/","title":"Shell Component","text":"<p>Shell component is a component that can be deployed using shell scripts. This is the easiest and most flexible way how to deploy a component.</p> <p>Minimal component structure would look liek the following</p> <pre><code>./\n\u251c\u2500\u2500 hub-component.yaml  # component manifest\n\u251c\u2500\u2500 deploy.sh           # shell script to deploy the component\n\u2514\u2500\u2500 undeploy.sh         # shell script to undeploy the component\n</code></pre>"},{"location":"reference/components/shell/#conventions","title":"Conventions","text":"<p>There are no specific variables that are expected to be passed to the shell script.</p> <p>Scripts expected:</p> <ul> <li><code>deploy.sh</code> - script to deploy the component (mandatory)</li> <li><code>undeploy.sh</code> - script to undeploy the component (mandatory)</li> <li><code>&lt;verb&gt;.sh</code> - any other script that can be used to perform any other action</li> </ul> <p>You can define additional variables in the <code>hub-component.yaml</code> file.</p> <pre><code>lifecycle:\n    verbs:\n    - deploy\n    - undeploy\n    - bar-verb\n</code></pre> <p>You can call this verb by running the following command</p> <pre><code>hubctl stack invoke \"foo-component\" \"bar-verb\"\n</code></pre>"},{"location":"reference/components/shell/#best-practices","title":"Best practices","text":"<p>Component should always have a <code>undeploy.sh</code> script. Good design says the deployment of any component should be revertible (verb: undeploy)</p> <p>Parametrise your shell scripts via environment variables. You can define environment variables in the <code>hub-component.yaml</code> file.</p> <p>Parametrsise your configuration via templates.</p>"},{"location":"reference/components/shell/#see-also","title":"See Also","text":"<ul> <li>hub stack</li> <li>hub stack invoke</li> </ul>"},{"location":"reference/components/terraform/","title":"Terraform Component","text":"<p>Terraform is a popular infrastruture as code technology often used to deploy cloud resources. We do provide our own opinionated way how to deploy Terraform. In this case you can follow simple conventions and you don't require to write a deployment scripts</p>"},{"location":"reference/components/terraform/#component-conventions","title":"Component Conventions","text":"<p>If component follows the conventions below, then hubctl will know how to deploy it.</p> <p>Minimalistic terraform component will look like this:</p> <p>Hubctl will automatically detect Terraform code when component contains one or more <code>*.tf</code> files.</p> <pre><code>./\n\u251c\u2500\u2500 hub-component.yaml  # component manifest\n\u2514\u2500\u2500 main.tf             # terraform code\n</code></pre>"},{"location":"reference/components/terraform/#configuration","title":"Configuration","text":"<p>Terraform variables can be supplied in two ways:</p> <ol> <li>Terraform variables can be defined by component parameter and exported as <code>TF_VAR_*</code> environment variable (recommended way)</li> <li>Terraform variables can be defined in <code>*.tfvars</code> or <code>*.tfvars.template</code> file</li> </ol>"},{"location":"reference/components/terraform/#parameters","title":"Parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required Passed from <code>.env</code> <code>COMPONENT_NAME</code> Corresponds to parameter <code>hub.componentName</code> parameter, however can be overriden in <code>hub-component.yaml</code>. Hub will use this variable as a helm release name x <code>HUB_DOMAIN_NAME</code> FQDN of a stack. We use this parameter as a natural id of the deployment x x <code>HUB_CLOUD_PROVIDER</code> Tells hubctl to use different backends for terraform. We currently support: <code>aws</code>, <code>azure</code> or <code>gcp</code> x x <code>HUB_STATE_BUCKET</code> Object storage bucket to be be used for terraform state x x <code>HUB_STATE_REGION</code> Region for terraform state bucket x x <p>There are additional environment variables, depends on your cloud type</p>"},{"location":"reference/components/terraform/#aws-specific-variables","title":"AWS specific variables","text":"<p>These variables has been set during <code>hubctl stack configure</code> state and defined in <code>.env</code> file. You don't have to refer it for your component, however you can overwrite.</p> Variable Description Required <code>AWS_PROFILE</code> AWS name of the profile. Referenced from <code>.env</code> file. However you can override it in <code>hub-component.yaml</code> file x"},{"location":"reference/components/terraform/#azure-specific-variables","title":"Azure specific variables","text":"<p>These variables has been set during <code>hubctl stack configure</code> state and defined in <code>.env</code> file. These are the minimum viable variables expected by our terraform deploymenet script</p> Variable Description Required <code>ARM_CLIENT_ID</code> The client(application) ID of an App Registration in the tenant <code>ARM_CLIENT_SECRET</code> A client secret that was generated for the App Registration <code>ARM_SUBSCRIPTION_ID</code> Access an Azure subscription value from within a Terraform script <code>ARM_TENANT_ID</code> ARM Tenant id <p>Full list of environment variables for azure can be found here</p>"},{"location":"reference/components/terraform/#gcp-specific-variables","title":"GCP specific variables","text":"Variable Description Required <code>GOOGLE_APPLICATION_CREDENTIALS</code> Default applicaiton credentials (ADC) see details here <code>GOOGLE_PROJECT</code> For to refer google project ID. See details here <p>Full reference of supported variables available here</p>"},{"location":"reference/components/terraform/#deployment-hooks","title":"Deployment hooks","text":"<p>User can define pre and post deployment</p> <ul> <li><code>pre-deploy</code> to trigger action before helm install</li> <li><code>post-deploy</code> to trigter action after successful helm install</li> <li><code>pre-undeploy</code> to trigger action before helm delete</li> <li><code>post-undeploy</code> to trigger action after helm successful delete</li> <li><code>import</code> a special script that to import existing resources into Terraform state.</li> </ul> <p>Note: <code>import</code> maybe a necessary step to allow manage non-idempotent resources such as AWS S3 bucket. Before running terraform deployment that will fail you may want to import bucket if it already exists. Note: deployment hooks should have execution rights</p>"},{"location":"reference/components/terraform/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> </ul>"},{"location":"reference/design/","title":"Key Concepts","text":""},{"location":"reference/design/#component","title":"Component","text":"<p>A component is a single service or application that makes sense to deploy on its own. It can be a database, a web server, a queue, a cache, or anything else that is a single unit of deployment.</p> <p>Key characteristics of a component: - It is a reusable unit of deployment - It is idempotent. Which means if the component has been already deployed, it will not be deployed again however no error will be raised</p> <p>Every component should support at least two operations - <code>deploy</code> - deploy the component - <code>undeploy</code> - reverse the deployment</p> <p>Every component can be deployed with a set of parameters. Parameters are used to configure the component. For example a database component can be configured with a database name, username, password, and other parameters. A web server component can be configured with a port number, a domain name, and other parameters. Parameters let's user to abstract component configuration from the component itself.</p> <p>Components can be written in any language and can be deployed with any tool. However, it is recommended to use one of the following tools:</p> <ul> <li><code>terraform</code></li> <li><code>helm</code></li> <li><code>kustomize</code></li> <li><code>shell</code></li> <li><code>Makefile</code></li> <li><code>Azure ARM template</code></li> </ul>"},{"location":"reference/design/#stack","title":"Stack","text":"<p>In real life a single component is not enough to run as a service. Usually it requires other components to be deployed as well. For example a web server requires a database to store data. A queue requires a database to store messages. A cache requires a database to store cached data.</p> <p>This means component can import parameters either from environment or from the other components. This is where stack comes into play. Stack is a collection of components that are deployed together. Stack defines the order of deployment and parameters that are passed to the components.</p> <p>Stack can be deployed in three steps</p> <ol> <li><code>init</code> - initialize the stack, download components, hooks and other artifacts</li> <li><code>configure</code> - configures stack requirements such as environment, access credentials, user input, etc. Anything that is required to deploy the stack</li> <li><code>deploy</code> - deploys the stack. You can also deploy series of individual components</li> </ol>"},{"location":"reference/design/#parameters","title":"Parameters","text":"<p>Parameters are used to configure components. Parameters can be passed to the component from environment or from the other components. Parameters are a simple key value pairs and defined component level and overriden by the stack or upstream components. See more details in the parameters configuration.</p>"},{"location":"reference/design/#templates","title":"Templates","text":"<p>Templates are used to generate configuration files for the components. Before individual component will be deployed a template will be rendered with the parameters and the result will be passed to the component. See more details in the template configuration.</p>"},{"location":"reference/design/#deployment-hooks","title":"Deployment Hooks","text":"<p>Hooks are used to execute custom logic before or after deployment of the component or a stack. Hooks are defined on the stack level. See more details in the hooks configuration.</p>"},{"location":"reference/design/#toolbox","title":"Toolbox","text":"<p>Both hubctl and components requires tools to be installed on a machine. This makes it hard to standartize the tool chain across all members of the team. Toolbox is a docker container that contains all required tools to run hubctl and components.</p> <p>See how to run toolbox by running <code>hubctl toolbox</code>.</p>"},{"location":"reference/design/#dns-bubbles","title":"DNS Bubbles","text":"<p>DNS names has been supplied from: epam.devops.delivery</p> <p>After stack has been deployed user will want to access it. The most straightforward way is to use a DNS name. To access it with DNS name.</p> <p>DNS Bubbles is a web service that can grant a temporary random DNS name. These domain names are garbage collected every 72 hours unless refreshed. This makes it useful for ephemeral environments. Environment that user will discard after they do not need it anymore. Development or test environments are perfect examples of such environments.</p> <p>See more on how to configure DNS Bubbles in the DNS Bubbles configuration.</p>"},{"location":"reference/design/aws/","title":"Amazon Web Services","text":"<p>In order to deploy Hubctl components using AWS, you'll need to meet the following prerequisites:</p> <ul> <li>AWS account</li> <li>AWS Profile with S3 Read/Write access, if hubctl deployment state is preferred to be stored remotely</li> <li>AWS Profile with Route53 Read/Write access, if domain name registration is required</li> </ul>"},{"location":"reference/design/aws/#parameters","title":"Parameters","text":"<p>Table below lists all the parameters and environment variables that can be used to configure.</p> Environment Variable Description <code>HUB_DOMAIN_NAME</code> Domain name of the stack. <code>HUB_STACK_NAME</code> Name of the stack. Prefix part of  <code>dns.domain</code> <code>AWS_REGION</code> AWS Region, default <code>us-east-1</code> <code>AWS_PROFILE</code> AWS Profile"},{"location":"reference/design/aws/#hubctl-steps","title":"Hubctl steps","text":"<p>In order to use AWS configuring scripts, in <code>hub.yaml</code> at <code>extensions</code> defining of steps is required.</p> <pre><code>extensions:\n  init:\n    - aws\n  configure:\n    - aws\n</code></pre>"},{"location":"reference/design/aws/#hubctl-init","title":"Hubctl init","text":"<p>Hubctl aws init checks if AWS profile configured. Defines AWS profile and region for stack.</p> <p>See more about <code>init</code></p>"},{"location":"reference/design/aws/#hubctl-configure","title":"Hubctl configure","text":"<p><code>hubctl stack configure</code> works with parameters listed in table below</p> Configure parameters Environment Variable Description --aws-region <code>AWS_REGION</code> AWS Region (defaults to value from: AWS_REGION) --aws-profile <code>AWS_PROFILE</code> AWS Profile (defaults to value from: AWS_PROFILE) --domain-name <code>HUB_DOMAIN_NAME</code> Custom DNS domain name under existing base domain --base-domain-aws-profile <code>HUB_BASE_DOMAIN_AWS_PROFILE</code> AWS Profile for base domain (in case base domain hosted zone is located in another AWS account) --bubbles-secret-key <code>HUB_DOMAIN_SECRET</code> DNS manager secret --dns-update <code>DNS_ACTION</code> Action request to DNS manager --prefer-local <code>PREFER_LOCAL_STATE</code> Save deployment state locally only --output <code>DOT_ENV</code> Environment variables file --dry-run <code>DRY_RUN</code> Do not deploy cloud resources, show what will happen <code>HUB_STATE_BUCKET</code> Name of the bucket for hub state store <code>ZONE_ID</code> AWS zone for configured domain <code>HUB_CLOUD_PROVIDER</code> Tells hubctl to use different backends for terraform. Here will be set: <code>aws</code> <p>Configuring uses AWS profile and region that were defined at init phase\\ If the <code>HUB_STATE_BUCKET</code> variable is not defined, S3 bucket with name the AWS account ID and suffix <code>.superhub.io</code> will be created. In case local storing preference isn't true, hubctl state will be located in that S3 bucket.</p> <p>For DNS accessibility configures Route53 by checking for the presence of the hosted zone specified in <code>HUB_DOMAIN_NAME</code>. If it is not found, by default deploys it using Bubbles DNS manager. This web service able to provide ephemeral environments for temporary usage. Otherwise, if <code>DNS_MANAGER</code> is \"user\", checks for the presence of the parent domain and its hosted zone. If the parent hosted zone is found, updates the nameservers for the child domain. If neither the parent nor the child hosted zone is found, exits with an error message.</p> <p>See more on how to configure DNS Bubbles in the DNS Bubbles configuration.</p> <p>See more about <code>configure</code></p>"},{"location":"reference/design/dns/","title":"Domain Name Configuration","text":"<p>When user declares they want to use a domain name associated with the deployment, we treat it as an identifier of the stack. This makes it easier to manage multiple deployments from the same working directory.</p>"},{"location":"reference/design/dns/#configuration","title":"Configuration","text":"<p>Domain name defined on a stack level. It can be configured in two ways: 1. Well known parameters  2. Well known environment variable s(overrides the parameter name)</p> <p>Table below lists all the parameters and environment variables that can be used to configure domain name.</p> Parameter Environment Variable Description <code>dns.domain</code> <code>HUB_DOMAIN_NAME</code> Domain name of the stack. <code>dns.name</code> <code>HUB_STACK_NAME</code> Name of the stack. Prefix part of  <code>dns.domain</code> <code>dns.baseDomain</code> <code>N/A</code> Base domain name of the stack. Suffix part of <code>dns.domain</code>"},{"location":"reference/design/dns/#autogenerated-domain-name","title":"Autogenerated Domain Name","text":"<p>Name associated with the deployment (both fixed and autogenerated) has been defined when the stack has been initialized with<code>hubctl stack init</code>.</p> <p>When user will run the <code>hubctl stack configure</code> command, then the name will be propagated to the DNS configuration. Following extensions support this operations</p> <ul> <li><code>aws</code> - This extension will register Route53 hosted zone</li> <li><code>gcp</code> - This extension will register Cloud DNS managed zone</li> <li><code>azure</code> - This extension will register Azure DNS zone</li> </ul> <p>Let us now if you need more by raising and up-voting issue in https://github.com/epam/hub-extensions/issues</p>"},{"location":"reference/design/dns/#example","title":"Example","text":""},{"location":"reference/design/dns/#fixed-domain-name","title":"Fixed Domain Name","text":"<p>User defines a domain name as <code>example.com</code>. This stack can use one and only one domain name</p> <pre><code>parameters:\n- name: dns.domain\n  value: example.com\n</code></pre>"},{"location":"reference/design/dns/#autogenerated-domain-name_1","title":"Autogenerated Domain Name","text":"<p>User declares <code>dns.domain</code> parameter must be sources from <code>HUB_DOMAIN_NAME</code> environment variable. In this case <code>hubctl</code> will supply autogenerated domain name.</p> <pre><code>parameters:\n- name: dns.domain\n  fromEnv: HUB_DOMAIN_NAME\n</code></pre>"},{"location":"reference/design/dns/#no-domain-name","title":"No Domain Name","text":"<p>In this case just skip declaration of <code>dns.domain</code> parameter. Hub will use a random name as the deployment</p> <p>User can map capture the autogenerated name associated with the deployment by sourcing parameter value from environment variable <code>HUB_STACK_NAME</code></p> <pre><code>parameters:\n- name: dns.name\n  fromEnv: HUB_STACK_NAME\n</code></pre> <p>or fixed name</p> <pre><code>parameters:\n- name: dns.name\n  value: foo-bar\n</code></pre> <p>Note: As a technical detail we will still generate <code>HUB_DOMAIN_NAME</code> variable equal to <code>HUB_STACK_NAME</code>. This will keep some compatibility with the components that expects this variable to be defined.</p>"},{"location":"reference/design/env/","title":"Environment Configuration","text":"<p>Values in hubfile can be stored in the version control system such as git. However not all parameter should be available in the repository. For example, credentials should be stored in a secure place. Hubctl allows to store values in environment variables.</p> <p>Environment configuration is a perfect example. Cloud credentials, Kubernetes, etc are the good examples</p> <p>Passwords and other Secrets is another example of such parameters. Passwords should not be committed to the repository. Instead they should be passed in a separate way to the users. Don't store keys from the front door under the mat.</p>"},{"location":"reference/design/env/#configuration","title":"Configuration","text":"<p>Environment variables are not stored in the hubfile. Instead they are stored in the <code>.env</code> file. This file is a symlink to the <code>.hub/&lt;deployment-name&gt;.env</code> file. This way allows to switch between different deployments of a stack and use different environment variables.</p> <ol> <li>To initialize such configuration run</li> </ol> <pre><code>hubctl stack init\n</code></pre> <p>Or if current directory already have an initialized stack. This is extra protection from accidentally overwriting existing configuration.</p> <pre><code>hubctl stack init --help\n</code></pre> <ol> <li>To configure environment variables run</li> </ol> <pre><code>hubctl stack configure\n</code></pre> <p>Or if you want to trigger only environment variables checks run the following command</p> <pre><code>hubctl stack configure -r \"env\"\n</code></pre> <p>Command above will check all parameters marked with <code>fromEnv</code> and will ask user to provide values for them. Hubctl will see if variable is not exist in <code>.env</code> file and prompt user. Hubctl will also provide convenience suggestion to the user based on the following algorithm</p> <ol> <li>If environment variable is defined, then use it</li> <li>If environment variable is not defined, then use <code>default</code> value</li> <li>If parameter has <code>empty: allow</code> then use empty value</li> <li>Use previously provided value from the same environment variable</li> <li>Use random value</li> </ol> <p>You can change the value prompted by the hubctl.</p> <p>Note: After value has been set, you can always change it in <code>.env</code> file.</p>"},{"location":"reference/design/env/#how-to-switch-between-configurations","title":"How to Switch Between Configurations","text":"<p>Hubctl allows to switch between different configurations. For example, you can have different configurations for different environments.</p> <pre><code>hubctl stack ls # list all available stacks\nhubctl stack use &lt;stack-name&gt; # use the stack for the current directory\n</code></pre>"},{"location":"reference/design/env/#configure-programmatically","title":"Configure Programmatically","text":"<p>Hubctl extensions contains a <code>.env</code> parser written in bash. It has been available in <code>~/.hub/bin/dotenv</code> and automatically added to the <code>PATH</code> during the <code>hubctl stack &lt;any&gt;</code> command. You can use it to parse or set environment variables from your deployment hooks</p> <p>For more details check</p> <pre><code>~/.hub/bin/dotenv --help\n</code></pre> <p>Note: <code>dotenv</code> parser maybe in the different if you decided to install hubctl extensions in the different location</p>"},{"location":"reference/design/env/#see-also","title":"See Also","text":"<ul> <li>hubctl stack command</li> <li>Parameters - reference guide</li> <li>Hubctl Key Concepts</li> </ul>"},{"location":"reference/manifests/","title":"Hubfile","text":"<p>Sometimes called as hub manifest. is a YAML file that describes a stack or a component. It is a source of truth for hubctl deployment. We will use both names interchangeably.</p> <p>There are two types of manifests:</p>"},{"location":"reference/manifests/#component-manifest","title":"Component manifest","text":"<p>Defined as <code>hub-component.yaml</code></p> <p>Located in the component directory. This file has the following structure:</p> <ul> <li>Requirements, that the component expects from environment or another (upstream) component</li> <li>What are the component input and output parameters</li> <li>Additional verbs (besides <code>deploy</code> and <code>undeploy</code>) that can be executed on the component</li> <li>Describes templates used by the component</li> </ul> <p>See more about component manifest in here.</p>"},{"location":"reference/manifests/#stack-manifest","title":"Stack manifest","text":"<p>Defined as: <code>hub.yaml</code>, <code>params.yaml</code>, <code>params-*.yaml</code>. </p> <p>Stack manifest describes how one or multiple components are deployed together. It has the following structure:</p> <ul> <li>Requirements from environment</li> <li>Defines components list and dependencies between them</li> <li>Defines stack input and output parameters</li> <li>Defines deployment hooks</li> </ul> <p>See more about stack manifest in here.</p>"},{"location":"reference/manifests/#split-parameters-into-separate-files","title":"Split Parameters into Separate Files","text":"<p>This considered as a good practice for Stack Manifests.</p> <p>Parameter definitions for entire stack can be quite large. For convenience parameters of the stack into the <code>params.yaml</code> or in the group of <code>params-*.yaml</code> files. Then you can refer additional files in the <code>hub.yaml</code> as the following:</p> <pre><code>extension:\n  include:\n  - params.yaml\n</code></pre> <p>See more in hubctl extensions</p> <p>Note: this is a good practice to split parameters from <code>hub.yaml</code> into it's own file <code>params.yaml</code> or even a series of <code>params.yaml</code> files. The parameter files can be referenced in <code>hub.yaml</code> as the following</p>"},{"location":"reference/manifests/#see-also","title":"See Also","text":"<ul> <li>Component manifest</li> <li>Stack manifest</li> </ul>"},{"location":"reference/manifests/component/","title":"Hubfile Reference","text":"<p>On top level stack manifest contains following sections:</p> <pre><code>kind: component                            # mandatory, defines a component manifest\nversion: 1                                 # mandatory, manifest schema version\nmeta:                                      # optional, see Meta\n  name: foo-component                      # optional, component name\n  brief: Foo component                     # optional, brief description of the component\n  license: Apache 2.0                      # optional, license applied to component distribution\nrequires:                                  # optional, list of requirements for component can be provided by environment (stack), or another component\n- gcp                                      # example of component requirement\n- terraform                                # example of component requirement\nprovides:                                  # optional, list of capabilities provided by component\n- bucket                                   # example of component capability\nparameters:\n- name: hub.componentName                  # optional, special parameter that always bounds to component name defined in `hub.yaml`\n- name: bucket.name                        # mandatory, parameter name\n  value: ${hub.componentName}              # example, shows how to default\n  env: TF_VAR_name                         # optional, mapping to environment variable for use deployment script\n- name: bucket.region                      # example, shows mandatory paramer that have now default value\n- name: gcp.serviceAccount\n  empty: allow                             # example shows optional parameter that ca nbe empty\noutputs:                                   # optional, list of outputs provided by component\n- name: bucket.endpoint                    # mandatory, output name\n  value: https://storage.googleapis.com    # example, shows predefined output, parameter interpolation syntax is supported\n  breif: Well-knows GCP bucket endpoint    # optional, brief description for output\n- name: bucket.region\n  fromTfVar: location                      # example, shows how to map output to terraform variable\n- name: bucket.accessKey\n  fromTfVar: sensitive_access_key_id       # example, shows how to map output to sensitive variable\n- name: bucket.name                        # example, shows how to forward component parameter to output\ntemplates:                                 # optional, list of templates provided by component\n  kind: curly                              # mandatory, other values [mustache, go]\n  files:                                   # mandatory, list of template files, supports globs\n  - \"*.template\"                           # example of template files in current\nlifecycle:\n  verbs:                                   # optional, add custom verbs for `hub invoke`. Defaults to [deploy, undeploy]\n  - deploy\n  - undeploy\n  - backup\n  bare: true                                # optional, instruction to allow component without deploy or undeploy implementation\n  readyConditions:                          # optional, conditions to check before declaring component deployed\n  - dns: api.${dns.domain}                  # optional, checks if dns name has been resolved\n    url:  https://api.${dns.domain}/v1      # optional, uses http ping GET to check if url is available\n    pauseSeconds: 0                         # optional, pause in seconds before starting poll loop\n\n</code></pre>"},{"location":"reference/manifests/component/#component-manifest","title":"Component manifest:","text":"<p>Component manifest section described on more details</p> <ul> <li>meta: name, description, version, etc.</li> <li>requires</li> <li>provides</li> <li>parameters: inputs, defaults, mapping to OS environment</li> <li>outputs</li> <li>templates: where are the templates</li> <li>lifecycle: verbs, fine-tuning for hubctl</li> </ul>"},{"location":"reference/manifests/component/#see-also","title":"See Also","text":"<ul> <li>Stack Manifest</li> </ul>"},{"location":"reference/manifests/component/lifecycle/","title":"Section <code>lifecycle</code>","text":"<p>Lifecycle, is a set of instructions to hubctl to control component deployment</p> <pre><code>lifecycle:\n  verbs:                                # optional, add custom verbs for `hub invoke`. Defaults to [deploy, undeploy]\n  - deploy\n  - undeploy\n  bare: true                            # optional, instruction to allow component without deploy or undeploy implementation\n  readyConditions:                      # optional, conditions to check before declaring component deployed\n  - dns: api.${dns.domain}              # optional, checks if dns name has been resolved\n    url:  https://api.${dns.domain}/v1  # optional, uses http ping GET to check if url is available\n    pauseSeconds: 0                     # optional, pause in seconds before starting poll loop\n  options:                              # optional\n    random:                             # optional\n      bytes: 128                        # optional, see Manifest &gt; Outputs &gt; Securing outputs\n</code></pre>"},{"location":"reference/manifests/component/lifecycle/#see-also","title":"See Also","text":"<ul> <li>Component Manifest</li> </ul>"},{"location":"reference/manifests/component/meta/","title":"Section: <code>meta</code>","text":"<p>This section defines metadata for the component manifest. Metadata can be captured by automation tools</p> <pre><code>version: 1                            # mandatory, component manifest schema version\nkind: component                       # mandatory, defines a component manifest\nmeta:                                 # optional, metadata for the component\n  name: happy-meal                    # optional human readable name\n  brief: Happy Meal                   # optional, brief description of the component\n  license: Apache 2.0                 # optional, license applied to component distribution\n</code></pre> <p>Every component must define at least manifest <code>version</code> and <code>kind</code>. Other fields are optional.</p> <p>We took inspiration for manifest design from Kubernetes resources. However we do not enforce mandatory <code>metadata.name</code>. Everything besides <code>metadata</code> is optional and intended to be used by automation tools.</p>"},{"location":"reference/manifests/component/meta/#see-also","title":"See Also:","text":"<ul> <li>Component manifest</li> <li>Parameters</li> </ul>"},{"location":"reference/manifests/component/outputs/","title":"Section <code>outputs</code>","text":"<p>To bind input parameters of the <code>pgweb</code> to specific PostgreSQL, use <code>depends</code>:</p> <pre><code>outputs:\n- name: ingress.hosts                     # mandatory, name of output parameter\n  brief: Ingress FQDN                     # optional, propagated to stack level outputs\n  value: ${dns.name}.${dns.baseDomain}    # optional, either `value` or `fromTfVar` must be defined\n  fromTfVar: fqdn                         # optional, either `value` or `fromTfVar` must be defined\n  kind: secret/token                      # optional, secret/&lt;kind&gt; is the only supported variation\n</code></pre> <p>When more than a single instance of the same component is deployed in the stack - think two PostgreSQL databases, then there is an ambiguity because both components provides same outputs, ie. <code>endpoint</code> and <code>password</code>.</p> <p>Where <code>brief</code> and <code>kind</code> will be propagated to stack level outputs if component:output syntax is used on hub.yaml level.</p>"},{"location":"reference/manifests/component/outputs/#computed-outputs","title":"Computed Outputs","text":"<p>When you need to output parameters from the deployment script (<code>deploy.sh</code>). Use the following syntax:</p> <pre><code>\ncat &lt;&lt; EOF\n\nOutputs:\nserver_uptime = $(uptime)\n\nEOF\n</code></pre> <p>And then link this with the <code>hub-component.yaml</code>:</p> <pre><code>outputs:\n- name: message.uptime\n  fromTfVar: server_uptime\n</code></pre> <p>Hubctl component deployment reads stdout for a specific Terraform like pattern. Once detected, it will capture response.</p>"},{"location":"reference/manifests/component/outputs/#outputs-from-file","title":"Outputs from File","text":"<p>To read outputs from a file use the following syntax, where parameter value prefixed with <code>file://</code>. See example below:</p> <pre><code>outputs:\n- name: message.uptime\n  fromFile: file://uptime.txt\n</code></pre>"},{"location":"reference/manifests/component/outputs/#see-also","title":"See Also","text":"<ul> <li>Component Manifest</li> <li>Stack Outputs</li> </ul>"},{"location":"reference/manifests/component/parameters/","title":"Section <code>parameters</code>","text":"<p>Parameters are used to configure stack and components in both stack manifest (<code>hub.yaml</code>) and component manifest (<code>hub-component.yaml</code>).</p> <p>Parameters have a tree-like structure where leafs have values and nodes should have nested parameters:</p> <pre><code>parameters:\n- name: cloud.kind\n  value: aws                          # set to value provided by user\n- name: cloud.regions                 # this parameter is only set for component `foo`\n  component: foo\n  value: [us-east-1, us-east-2]\n- name: kubernetes                    # nested parameters for kubernetes\n  parameters:\n  - name: worker.size\n    fromEnv: KUBERNETES_WORKER_SIZE   # Source value form environment variable\n    default: m5.large                 # Use default if value not provided\n</code></pre> <p>Native YAML syntax could be used to short-circuit nested declarations. The above is effectively flattened into list of parameters:</p> <pre><code>cloud.kind\ncloud.regions\nkubernetes.worker.size\n</code></pre> <p>The values are in most cases plain text / scalar type, yet we support arrays and maps - data types native to JSON and YAML.</p>"},{"location":"reference/manifests/component/parameters/#resolve-parameter-value","title":"Resolve parameter value","text":"<p>Here we specify parameter types and their interpretation.</p> <p>This is the most common type of parameter. It is used to set parameter value to a literal:</p> <pre><code>parameters:\n- name: kubernetes.namespace\n  value: kube-system\n</code></pre> <p>with interpolation</p> <pre><code>parameters:\n- name: dns.domain\n  value: example.com\n- name: ingress.hosts\n  value: www.${dns.domain}\n  # resolves to: www.example.com\n</code></pre> <p>or multiline parameters</p> <pre><code>parameters:\n- name: ingress.hosts\n  value: |\n    example.com\n    www.example.com\n</code></pre>"},{"location":"reference/manifests/component/parameters/#parameter-fromenv","title":"Parameter <code>fromEnv</code>","text":"<p>Stack Level only</p> <p>This parameter only forks for stack manifests (<code>hub.yaml</code> and <code>params-*.yaml</code>). It allows to set parameter value from environment variable:</p> <pre><code>parameters\n- name: kubernetes.namespace\n  fromEnv: NAMESPACE\n  default: kube-system\n</code></pre> <p>Parameter above will set value of parameter <code>kubernetes.namespace</code> to value of environment variable <code>NAMESPACE</code></p> <p>During <code>hubctl stack configure</code> user will be prompted to provide value for parameter <code>kubernetes.namespace</code> with default value <code>kube-system</code>.</p>"},{"location":"reference/manifests/component/parameters/#parameter-env","title":"Parameter <code>env</code>","text":"<p>Component Level only</p> <p>This parameter only works for component manifests (<code>hub-component.yaml</code>). It allows to set environment variables from parameter value:</p> <pre><code>parameters:\n- name: kubernetes.namespace\n  env: NAMESPACE\n  value: kube-system\n</code></pre> <p>Parameter above will define environment variable <code>NAMESPACE</code> with value <code>kube-system</code> as a default (unless stack will provide different name)</p>"},{"location":"reference/manifests/component/parameters/#parameter-fromfile","title":"Parameter <code>fromFile</code>","text":"<p>Parameter value could be read from file <code>fromFile: config/stage/password</code>.</p>"},{"location":"reference/manifests/component/parameters/#cel-expressions","title":"CEL expressions","text":"<p>Parameter <code>value</code> support CEL expressions enclosed in <code>#{}</code> such as:</p> <pre><code>parameters:\n- name: cloud.availabilityZones\n- name: cloud.availabilityZones.count\n  value: \"#{len(cloud.availabilityZones)}\"\n</code></pre> <p>CEL has some unexpected results for corner cases, use <code>hubctl cel</code> to debug.</p>"},{"location":"reference/manifests/component/parameters/#parameter-kind","title":"Parameter <code>kind</code>","text":"<p>All parameters can be derived from primarily from values or other components. These parameters resolved during the deployment. Until you are not care for specific parameter kind then leave it out.</p> <p>However there are special case parameters. In this case you define a special attribute <code>kind</code> to specify how parameter should be resolved.</p>"},{"location":"reference/manifests/component/parameters/#parameter-kind-user","title":"Parameter <code>kind: user</code>","text":"<p>There are high-level user-provided parameters - the facts <code>user</code> do care about: which cloud and cloud account to use, what region to deploy to, etc.</p>"},{"location":"reference/manifests/component/parameters/#parameter-kind-link","title":"Parameter <code>kind: link</code>","text":"<p>In general, preferred approach to resolve parameters provided as outputs from the component is through <code>components.depends</code> attribute. However sometimes you need to change parameter name as they are not match.</p> <p>To map output to a different name use <code>kind: link</code> parameter. The interpretation of <code>value</code> will be deferred until parameter is used:</p> <pre><code>parameters:\n- name: backend.image\n  value: ${ecr:docker.image}\n  kind: link\n</code></pre> <p><code>ecr</code> is a component deployed prior to <code>backend</code>. There are several ECRs thus output is fully qualified.</p>"},{"location":"reference/manifests/component/parameters/#see-also","title":"See also","text":"<ul> <li>Stack Manifest</li> <li>Component Manifest</li> <li>CEL expressions</li> </ul>"},{"location":"reference/manifests/component/provides/","title":"Section <code>provides</code>","text":"<p>This is a high level instruction to broadcast to the other components that after this component has been deployed, there is a new capability (or capabilities).</p> <pre><code>provides:     # optional\n- bucket      # example of provided capability\n</code></pre> <p>Capability is an arbitrary string. This string will be recognized by the other component in requires section.</p>"},{"location":"reference/manifests/component/provides/#access-provides-from-component","title":"Access Provides from Component","text":"<p>When component wants to check capabilities provided by environment or by other component. It can use:</p> <ul> <li>Well-known environment variable <code>HUB_PROVIDES</code> - same format as above.</li> <li>Well-known parameter <code>hub.provides</code> - whitespace separated list of capabilities</li> </ul> <p>Where parameter is a good choice for <code>deploy.sh</code> or <code>pre-deploy.sh</code>, or deployment hooks scripts. While parameter can be checked for instance by <code>gotemplate</code></p>"},{"location":"reference/manifests/component/provides/#best-practice","title":"Best Practice","text":"<p>Both <code>provides</code> and <code>requires</code> component maintainers agree on the exact capability string. They also agree on well-defined <code>outputs</code> which component will provide together with the capability. In the other words <code>requires</code> and <code>provides</code> defines mutual contract between components on what parameters to expect from each other.</p> <p>For instance, when component provides capability <code>bucket</code> it should also provide following outputs:</p> <pre><code>outputs:\n- name: bucket.endpoint\n- name: bucket.region\n- name: bucket.name\n- name: bucket.accessKey\n- name: bucket.secretKey\n</code></pre> <p>This will make such components as minio and gsbucket virtually interchangeable.</p> <p>There are a lot of parameters. You don't need all of them to output. Some parameters can be consumed by the input. However, component that will require either <code>minio</code> or <code>gsbucket</code>, it may expect these parameters will be provided.</p>"},{"location":"reference/manifests/component/provides/#see-also","title":"See Also","text":"<ul> <li>Requires</li> <li>Component Manifest</li> </ul>"},{"location":"reference/manifests/component/requires/","title":"Section <code>requires</code>","text":"<pre><code>requires:\n- aws\n- kubernetes\n</code></pre> <p>Component does not live in the vacuum. Some components expects certain capabilities provided by the upstream component or the environment</p> <p>Built-in requirements:</p> <ul> <li><code>aws</code></li> <li><code>azure</code></li> <li><code>gcp</code></li> <li><code>kubernetes</code></li> <li><code>helm</code></li> <li><code>terraform</code></li> </ul> <p>Component can define a requirement provided by another component. These requirements are not limited to the list above</p>"},{"location":"reference/manifests/component/templates/","title":"Section <code>templates</code>","text":"<pre><code>templates:\n  kind: curly                         # mandatory, mustache go\n  directories:                        # optional, list of directories to search for templates\n  - config                            # example of directory name\n  files:                              # mandatory, list of template files, supports globs\n  - \"*.template\"                      # example of template files in current component directory\n  extra:                              # optional, to support multiple template kinds\n  - kind: mustache                    # optional, additional template kind\n    files:                            # mandatory, list of template files, supports globs\n    - terraform/*.tfvars.template     # example of Terraform variable templates in directory `terraform`\n  - kind: go                          # example of Go template\n    files:                            \n    - helm/values*.yaml.gotemplate    # example of Helm values template\n</code></pre> <p>Note: either <code>directory</code> or <code>files</code> must be specified</p>"},{"location":"reference/manifests/component/templates/#template-kind","title":"Template Kind","text":"<p>Hubctl supports several kinds of templates</p> <ul> <li><code>curly</code> - String replacement template with format <code>${param}</code> in the file. This is the default template kind.</li> <li><code>mustache</code> - String replacement template with format <code>{{param}}</code></li> <li><code>go</code> - Go template with format <code>{{.param}}</code></li> </ul>"},{"location":"reference/manifests/component/templates/#kind-curly","title":"Kind: <code>curly</code>","text":"<p>A simple syntax where parameter name for substitution is included between curly brackets <code>${}</code>, ie. <code>${kubernetes.api.endpoint}</code>.</p> <p>Substitution may include encoding function <code>${param/encoding}</code> where <code>encoding</code> is one of:  <code>json</code>, <code>yaml</code>, <code>bcrypt</code>, <code>base64</code>. Multiple encodings are supported, processed in the order above: <code>${dex.passwordDb.password/bcrypt/base64}</code>.</p>"},{"location":"reference/manifests/component/templates/#kind-mustache","title":"Kind: <code>mustache</code>","text":"<p>Parameter name enclosed in <code>{{}}</code>. Because of conflict with <code>.</code> special meaning in mustache, it must be replaced with <code>_</code>, for example <code>{{component_cert-manager_issuerEmail}}</code>.</p>"},{"location":"reference/manifests/component/templates/#kind-go","title":"Kind: <code>go</code>","text":"<p>Full-featured Golang templates with <code>-</code> in parameter name replaced with <code>_</code>, for example <code>{{.cert_manager.issuerEmail}}</code>.</p> <p>Note: parameter name starts with <code>.</code> symbol</p> <p>Sprig Functions are available for use in go templates.</p>"},{"location":"reference/manifests/component/templates/#best-practice","title":"Best practice","text":"<ul> <li>Use <code>template</code> file extension for <code>curly</code> or <code>mustache</code> templates</li> <li>Use <code>gotemplate</code> file extension for <code>go</code> templates</li> </ul> <p>Before deployment, Hubctl will subtract template file extension and use the rest as a destination file name.</p>"},{"location":"reference/manifests/component/templates/#see-also","title":"See Also","text":"<ul> <li>Parameters</li> <li>Component manifest</li> <li>Golang templates</li> <li>Sprig Functions</li> </ul>"},{"location":"reference/manifests/stack/","title":"Stack Manifest","text":"<p>Stack manifest describes how one or multiple components are deployed together. It a either a <code>hub.yaml</code> file or combination of <code>hub.yaml</code> and <code>parameter-*.yaml</code> files.</p> <p>Below you will find compolete stack manifest example</p> <pre><code>meta:\n  kind: stack                                                 # mandatory, defines a stack manifest\n  version: 1                                                  # stack manifest schema version\nrequires:                                                     # optional, list of requirements form environment\n- kubernetes                                                  # example of stack requires\ncomponents:                                                   # mandatory, list of components\n- name: cert-manager                                          # mandatory, name of the component\n  source:                                                     # mandatory, component source\n    dir: components/cert-manager                              # mandatory, local path where to find component\n- name: knative-serving\n    source:\n      dir: components/knative-serving\n    git:                                                      # optional, git source to download component from\n      remote: https://github.com/epam/kubeflow-components.git # mandatory, git repository remote url\n      subDir: knative-serving                                 # mandatory, subdirectory in the repository\n      ref: develop                                            # optional, git reference (branch, tag, commit)\n    depends:                                                  # optional, component dependency\n    - cert-manager                                            # example of upstream dependency\nlifecycle:                                                    # optional, lifecycle verbs\n  verbs:                                                      # optional, list of verbs component supports (by default: deploy, undeploy)\n  - deploy                                                    # mandatory, deploy verb\n  - undeploy                                                  # mandatory, undeploy verb\n  - custom-verb                                               # optional, custom verb\n  order:                                                      # optional, order of deployment\n  - cert-manager                                              # example of deployment order, if not defined then deployment order derived from components definitions\n  - knative-serving\nparameters:                                                   # optional, stack input parameters (best practice, split to separate file or files)\n- name: dns.domain                                            # mandatory, parameter name\n  value: localhost                                            # optional, value for parameter\n- name: certmanager.namespace\n  component: cert-manager                                     # optional, component name, if not defined then parameter is global for all components\n  default: v1.11.0                                            # optional, default value for parameter\n  fromEnv: CERTMANAGER_NAMESPACE                              # optional, parameter value is taken from environment variable, this approach allows not to store exact value in version control. Useful for sensitive parameters.\n- name: ingress.hosts\n  empty: allow                                                # optional, to highlight parameter that can be empty\n  fromEnv: INGRESS_HOSTS                                      # good idea to pass value for empty parameters from environment variable\n  brief: Lorem ipsum                                          # optional, brief description for parameter\noutputs:                                                      # optional, stack output parameters\n- name: foo                                                   # mandatory, output name\n  value: http://localhost:${pgweb.port}                       # mandatory, output value, supports interpolation\n  brief: Lorem ipsum                                          # optional, brief description for output\n</code></pre> <p>Note: if optional section defined, it may have mandatory attributes</p> <p>Follow each section separately to get more details:</p> <ul> <li>meta: name, brief</li> <li>components references: what and where are the components</li> <li>requires and provides</li> <li>parameters: stack inputs, mappings</li> <li>outputs of a stack</li> <li>lifecycle: verbs, optional and mandatory components, conditional deployment</li> <li>extensions: verbs, optional and mandatory components, conditional deployment</li> </ul>"},{"location":"reference/manifests/stack/#see-also","title":"See Also","text":"<ul> <li>Component Manifest</li> </ul>"},{"location":"reference/manifests/stack/components/","title":"Section <code>components</code>","text":"<pre><code>components:\n- name: external-dns\n  source:\n    dir: components/external-dns\n    git:\n      remote: https://github.com/epam/hub-kubeflow-components.git\n      ref: main\n      subDir: external-dns\n  depends:\n  - cert-manager\n</code></pre> <p>Above you can see <code>external-dns</code> component sources are under <code>./components/external-dns/</code> directory.</p> <p>Section <code>components.source.git</code> section is optional. If not specified then <code>hubctl stack init</code> will not pull the component from git repository if this component does not exist. This operation happens during <code>hubctl stack init</code></p> <p>Section <code>components.depends</code> defines dependency between components. This takes effect on the:</p> <ul> <li>Components deployment run-list <code>hubctl</code> will schedule component deployment in the order of dependency and then in order of declaration. User can overwrite order by declaring section <code>lifecycle.order</code> in stack manifest.</li> <li>Parameters resolution. Let's say there are two components who output the same parameter. Section <code>depends</code> will tell to <code>hubctl</code> which component parameters must be taken as input.</li> </ul>"},{"location":"reference/manifests/stack/components/#component-deployment-hooks","title":"Component Deployment Hooks","text":"<p>Sometimes before or after a component deployment, User need to perform an action that extends the component and often is environment or context-specific. To achieve that component lifecycle hooks were introduced. This approach allows keeping components KISS and if-less. Please refer to the example below:</p> <pre><code>components:\n- name: external-dns\n  source:\n    dir: components/external-dns\n  hooks:                                # optional\n  - file: bin/do-something              # rmandatory, relative to stack manifest file\n    brief: Some description of my hook  # optional, brief description for hook\n    error: ignore                       # optional, default is `error: fail`\n    triggers:                           # mandatory, when hook should be triggered. Accepts wildcards sich as `*-deploy` or `post-*`\n    - pre-deploy\n    - post-undeploy\n</code></pre> <p>There are 2 hooks in the example:</p> <ul> <li>File <code>pre-deploy-hook</code> from the <code>.hub</code> directory relative to the directory where the Hub manifest file is located (<code>hub.yaml</code>) will be executed BEFORE <code>external-dns</code> component is deployed. <code>error: ignore</code> means that stack deployment will continue even if there is an error in the hook (it exits with non 0 exit code)</li> <li>File <code>post-deploy-hook</code> from the <code>.hub</code> directory relative to the directory where the Hub manifest file is located (<code>hub.yaml</code>) will be executed AFTER <code>external-dns</code> component is deployed.</li> </ul> <p>Additionally,</p> <ul> <li><code>triggers</code> array also supports regular expressions, such as <code>*-deploy</code> or <code>post-*</code></li> <li>All hooks matching the expression will be executed, and hook order from the <code>hooks</code> list will be maintained.</li> </ul>"},{"location":"reference/manifests/stack/extensions/","title":"Section <code>extension</code>","text":"<p>This section is not exposed into parameters</p> <p>This section will has been dedicated to various hubctl extensions. Hubctl will ignore syntax checks inside of this section. However various extensions may require a specific structure.</p> <pre><code>extensions:                               # optional\n  include:                                # optional, additional parameter files         \n  - params.yaml \n  - params-env.yaml\n  init:                              # optional, steps activated during `hubctl stack init`\n  - bin/my-custom-init.sh            # example, you can define custom scripts here\n  configure:                              # optional, steps activated during `hubctl stack configure`\n  - aws\n  - kubernetes\n  - bin/my-custom-configure.sh            # example, you can define custom scripts here\n  deploy:\n    before:\n    - kubernetes                          # optional, steps activated on `hubctl stack deploy` but before actual deployment of components\n    - bin/my-custom-pre-deploy.sh         # example, you can define custom scripts here\n    after:                                # optional, steps activated on `hubctl stack deploy` but after actual deployment of components\n    - inventory-configmap               \n  undeploy:                               # optional, steps activated during `hubctl stack undeploy`\n    before:\n    - bin/my-custom-pre-undeploy.sh\n    after:\n    - bin/my-custom-post-undeploy.sh\n</code></pre>"},{"location":"reference/manifests/stack/extensions/#referring-another-stack-manifest-file","title":"Referring another stack manifest file","text":"<p>Note: This is a good practice to split parameters from hub.yaml into it's own file params.yaml or even a series of params.yaml files. The parameter files can be referenced in hub.yaml as the following</p> <pre><code>extension:\n  include:\n  - params.yaml\n</code></pre>"},{"location":"reference/manifests/stack/lifecycle/","title":"Section <code>lifecycle</code>","text":"<pre><code>lifecycle:                             # optional\n  verbs:                               # optional, verbs supported by stack (if omited, then limited to verbs deploy and undeploy)\n  - deploy          \n  - undeploy\n  order:                               # optional, user defined order of components in which it must be deployed. If omitted then order will be derived form component dependencies followed by component order in stack manifest\n  - kubernetes                         # example names of components\n  - traefik\n  - kube-dashboard\n  mandatory:                           # optional, list of mandatory components. by default all components are optional\n  - kubernetes\n  optional:                             # optional, list of optional components. by default all components are optional\n  - kube-dashboard\n  requires:                             # optional, section to define optional rquirements\n    optional:                           # see Lifecycle &gt; Deploy &gt; Optional requirements\n    - vault\n  readyConditions:                      # optional, list of conditions to check before component is considered ready\n  - dns: api.${dns.domain}              # resolvable\n    url:  https://api.${dns.domain}/v1  # returns something other than HTTP 500\n    waitSeconds: 600                    # how long to wait for the condition\n    pauseSeconds: 0                     # pause before starting poll loop\n</code></pre>"},{"location":"reference/manifests/stack/meta/","title":"Section: <code>meta</code>","text":"<p>This section defines metadata for the stack manifest. Metadata can be captured by automation tools</p> <pre><code>version: 1                            # mandatory, stack manifest schema version\nkind: stack                           # mandatory, defines a stack manifest\nmeta:                                 # optional\n  name: happy-meal                    # optional human readable name\n  brief: Happy Meal                   # optional, brief description of the stack\n  fromStack: ../../stacks/base-stack  # optional, see FromStack\n  license: Apache 2.0                 # optional, license applied to stack distribution\n</code></pre> <p>Every stack must define at least manifest <code>version</code> and <code>kind</code>. Other fields are optional.</p> <p>Section <code>meta.fromStack</code> can enable inheritance of stack manifest from another stack. This will enable stack to inherit parameters values from another stack.</p>"},{"location":"reference/manifests/stack/meta/#see-also","title":"See Also","text":"<ul> <li>Stack Manifest</li> </ul>"},{"location":"reference/manifests/stack/outputs/","title":"Section <code>outputs</code>","text":"<p>Stack outputs can be defined as the following</p> <pre><code>outputs:\n- name: ingress.hosts                     # mandatory, name of output parameter\n  brief: Ingress FQDN                     # optional, meaningful description\n  value: ${dns.name}.${dns.baseDomain}    # mandatory, output of a stack\n</code></pre>"},{"location":"reference/manifests/stack/outputs/#see-also","title":"See Also","text":"<ul> <li>Stack Manifest</li> <li>Component Outputs</li> </ul>"},{"location":"reference/manifests/stack/parameters/","title":"Section <code>parameters</code>","text":"<p>Parameters are used to configure stack and components in both stack manifest (<code>hub.yaml</code>) and component manifest (<code>hub-component.yaml</code>).</p> <p>Parameters have a tree-like structure where leafs have values and nodes should have nested parameters:</p> <pre><code>parameters:\n- name: cloud.kind\n  value: aws                          # set to value provided by user\n- name: cloud.regions                 # this parameter is only set for component `foo`\n  component: foo\n  value: [us-east-1, us-east-2]\n- name: kubernetes                    # nested parameters for kubernetes\n  parameters:\n  - name: worker.size\n    fromEnv: KUBERNETES_WORKER_SIZE   # Source value form environment variable\n    default: m5.large                 # Use default if value not provided\n</code></pre> <p>Native YAML syntax could be used to short-circuit nested declarations. The above is effectively flattened into list of parameters:</p> <pre><code>cloud.kind\ncloud.regions\nkubernetes.worker.size\n</code></pre> <p>The values are in most cases plain text / scalar type, yet we support arrays and maps - data types native to JSON and YAML.</p>"},{"location":"reference/manifests/stack/parameters/#resolve-parameter-value","title":"Resolve parameter value","text":"<p>Here we specify parameter types and their interpretation.</p> <p>This is the most common type of parameter. It is used to set parameter value to a literal:</p> <pre><code>parameters:\n- name: kubernetes.namespace\n  value: kube-system\n</code></pre> <p>with interpolation</p> <pre><code>parameters:\n- name: dns.domain\n  value: example.com\n- name: ingress.hosts\n  value: www.${dns.domain}\n  # resolves to: www.example.com\n</code></pre> <p>or multiline parameters</p> <pre><code>parameters:\n- name: ingress.hosts\n  value: |\n    example.com\n    www.example.com\n</code></pre>"},{"location":"reference/manifests/stack/parameters/#parameter-fromenv","title":"Parameter <code>fromEnv</code>","text":"<p>Stack Level only</p> <p>This parameter only forks for stack manifests (<code>hub.yaml</code> and <code>params-*.yaml</code>). It allows to set parameter value from environment variable:</p> <pre><code>parameters\n- name: kubernetes.namespace\n  fromEnv: NAMESPACE\n  default: kube-system\n</code></pre> <p>Parameter above will set value of parameter <code>kubernetes.namespace</code> to value of environment variable <code>NAMESPACE</code></p> <p>During <code>hubctl stack configure</code> user will be prompted to provide value for parameter <code>kubernetes.namespace</code> with default value <code>kube-system</code>.</p>"},{"location":"reference/manifests/stack/parameters/#parameter-env","title":"Parameter <code>env</code>","text":"<p>Component Level only</p> <p>This parameter only works for component manifests (<code>hub-component.yaml</code>). It allows to set environment variables from parameter value:</p> <pre><code>parameters:\n- name: kubernetes.namespace\n  env: NAMESPACE\n  value: kube-system\n</code></pre> <p>Parameter above will define environment variable <code>NAMESPACE</code> with value <code>kube-system</code> as a default (unless stack will provide different name)</p>"},{"location":"reference/manifests/stack/parameters/#parameter-fromfile","title":"Parameter <code>fromFile</code>","text":"<p>Parameter value could be read from file <code>fromFile: config/stage/password</code>.</p>"},{"location":"reference/manifests/stack/parameters/#cel-expressions","title":"CEL expressions","text":"<p>Parameter <code>value</code> support CEL expressions enclosed in <code>#{}</code> such as:</p> <pre><code>parameters:\n- name: cloud.availabilityZones\n- name: cloud.availabilityZones.count\n  value: \"#{len(cloud.availabilityZones)}\"\n</code></pre> <p>CEL has some unexpected results for corner cases, use <code>hubctl cel</code> to debug.</p>"},{"location":"reference/manifests/stack/parameters/#parameter-kind","title":"Parameter <code>kind</code>","text":"<p>All parameters can be derived from primarily from values or other components. These parameters resolved during the deployment. Until you are not care for specific parameter kind then leave it out.</p> <p>However there are special case parameters. In this case you define a special attribute <code>kind</code> to specify how parameter should be resolved.</p>"},{"location":"reference/manifests/stack/parameters/#parameter-kind-user","title":"Parameter <code>kind: user</code>","text":"<p>There are high-level user-provided parameters - the facts <code>user</code> do care about: which cloud and cloud account to use, what region to deploy to, etc.</p>"},{"location":"reference/manifests/stack/parameters/#parameter-kind-link","title":"Parameter <code>kind: link</code>","text":"<p>In general, preferred approach to resolve parameters provided as outputs from the component is through <code>components.depends</code> attribute. However sometimes you need to change parameter name as they are not match.</p> <p>To map output to a different name use <code>kind: link</code> parameter. The interpretation of <code>value</code> will be deferred until parameter is used:</p> <pre><code>parameters:\n- name: backend.image\n  value: ${ecr:docker.image}\n  kind: link\n</code></pre> <p><code>ecr</code> is a component deployed prior to <code>backend</code>. There are several ECRs thus output is fully qualified.</p>"},{"location":"reference/manifests/stack/parameters/#see-also","title":"See also","text":"<ul> <li>Stack Manifest</li> <li>Component Manifest</li> <li>CEL expressions</li> </ul>"},{"location":"reference/manifests/stack/requires/","title":"Section <code>requires</code>","text":"<pre><code>requires:\n- aws\n- kubernetes\n</code></pre> <p>Stack does not live in the vacuum. There are certain capabilities it requires from the environment before it ca nbe deployed.</p> <p>Some examples of requirements:</p> <ul> <li><code>aws</code></li> <li><code>azure</code></li> <li><code>gcp</code></li> <li><code>kubernetes</code></li> </ul> <p>This list is not fixed we work on continuously expanding it.</p>"},{"location":"reference/manifests/stack/requires/#see-also","title":"See Also","text":"<ul> <li>Stack Manifest</li> <li>Component Requires</li> </ul>"},{"location":"stacks/","title":"Stacks","text":"<p>Lorem ipsum...</p>"},{"location":"tutorials/","title":"Getting Started","text":"<p>Got hubctl installed? Great! Now let's get started with a quick tutorial.</p>"},{"location":"tutorials/#deployment-basics","title":"Deployment Basics","text":"<p>These tutorials describes how to use hubctl to deploy a stack and manage its configuration. These tutorials are deploying a simple <code>shell</code> component</p>"},{"location":"tutorials/#your-first-deployment","title":"Your First Deployment","text":"<p>Let's start with first deployment. We'll deploy a stack with one \"hello, world\" component.</p>"},{"location":"tutorials/#control-multiple-deployments","title":"Control Multiple Deployments","text":"<p>This tutorial explains how to manage multiple deployment of the same stack with different configurations.</p>"},{"location":"tutorials/#manage-multiple-deployments","title":"Manage Multiple Deployments","text":"<p>This tutorial explains how to manage multiple deployment with different configuration parameters.</p>"},{"location":"tutorials/#create-your-first-component","title":"Create Your First Component","text":"<p>Here we learn how to create a first component using most simple component type: shell.</p>"},{"location":"tutorials/#kubernetes-tutorials","title":"Kubernetes Tutorials","text":"<p>This is a set of tutorials that describes how to use hubctl to deploy a stack on existing Kubernetes cluster.</p>"},{"location":"tutorials/#create-your-first-component_1","title":"Create Your First Component","text":"<p>Here we learn how to configure component for deployment on Kubernetes. </p>"},{"location":"tutorials/#terraform-tutorials","title":"Terraform Tutorials","text":"<p>This guide will help you set up a component to create an Amazon S3 bucket using Terraform.</p>"},{"location":"tutorials/010-hubctl-stack-init/","title":"First Deployment","text":"<p>This tutorial will show you how hubctl works with a simple example. We will simply initialize and deploy hubctl with one pre-configured component.</p>"},{"location":"tutorials/010-hubctl-stack-init/#about","title":"About","text":"<p>At the first, let's understand what is the minimum configuration for hubctl.</p> <pre><code>\n\u251c\u2500\u2500 components                           # Directory with components\n\u2502    \u2514\u2500\u2500 hello-hubctl                    # Directory with configurations\n\u2502        \u251c\u2500\u2500 hub-component.yaml          # Component manifest\n\u2502        \u251c\u2500\u2500 deploy.sh                   # Shell script to deploy the component\n\u2502        \u2514\u2500\u2500 undeploy.sh                 # Shell script to undeploy the component\n\u2514\u2500\u2500 hub.yaml                             # Stack manifest\n</code></pre> <ul> <li>A specific configuration defining a stack manifest in <code>hub.yaml</code> is the first thing needed. Such a file describes the components and options for deployment.</li> </ul> <pre><code>kind: stack                                                                   # mandatory, defines a stack manifest\nversion: 1                                                                    # stack manifest schema version\nmeta:                                                                         # optional\n  name: My first deployment                                                   # optional human readable name\n\ncomponents:                                                                   # mandatory, list of components\n  - name: hello-hubctl                                                        # mandatory, name of the component\n    source:                                                                   # mandatory, component source\n      dir: components/hello-hubctl                                            # mandatory, local path where to find component\n      git:                                                                    # optional, git source to download component from\n        remote: https://github.com/epam/hubctl.io.git                         # mandatory, git repository remote url\n        subDir: docs/tutorials/010-hubctl-stack-init/components/hello-hubctl  # mandatory, subdirectory in the repository\n        ref: main                                                             # optional, git reference (branch, tag, commit)\n\n</code></pre> <p><code>hub.yaml</code> file has <code>components</code> field where you describe your components.</p> <ul> <li>You will also need <code>hub-component.yaml</code>, this is a reusable component, it is generic and provides an abstraction with dependencies needed for deployment.</li> </ul> <pre><code>kind: component                                     # mandatory, defines a component manifest\nversion: 1                                          # mandatory, manifest schema version\n\nparameters:\n  - name: message                                   # mandatory, parameter name\n    value: foo                                      # optional, value for parameter\n    env: MESSAGE                                    # optional, mapping to environment variable for use deployment script\n\n</code></pre> <p><code>hub-component.yaml</code> contains the <code>parameters</code> field for your configuration.</p> <p>Parameters are used to configure stack and components in both stack manifest <code>hub.yaml</code> and component manifest <code>hub-component.yaml</code>.</p> <p>If you are deploying using shell scripts, you need to create the expected scripts in the component folder: <code>deploy.sh</code></p> <pre><code>#!/bin/sh -e\n\necho \"Component $HUB_COMPONENT is saying: $MESSAGE\"\necho \"Component $HUB_COMPONENT deployed successfully!\"\n</code></pre> <p>and <code>undeploy.sh</code></p> <pre><code>#!/bin/sh -e\n\necho \"Component $HUB_COMPONENT undeployed successfully!\"\n</code></pre> <p>Make sure the <code>deploy.sh</code>, <code>undeploy.sh</code> are executable <code>chmod +x deploy.sh</code>, <code>chmod +x undeploy.sh</code>. Read more details here.</p> <p>So, if you have a ready-made configuration with customized components, how can you launch them? The following commands are used for this:</p> <ul> <li><code>hubctl stack init</code> - this command initializes the working directory with the <code>hub.yaml</code> file.</li> <li><code>hubctl stack configure</code> - stack configuration before deployment</li> <li><code>hubctl stack deploy</code> - Runs a deployment for the entire stack, or updates the deployment of one or more components.</li> </ul>"},{"location":"tutorials/010-hubctl-stack-init/#initialization","title":"Initialization","text":"<p>Now let's try to run simple example with a ready-made configuration that contains one component.</p> <p>Before you start you need initialize your stack. Download the minimal component from github to a your local directory and run the following command:</p> <pre><code>hubctl stack init\n</code></pre> <p>or without download folders you can initialize the following command</p> <pre><code>hubctl stack init -f \"https://raw.github.com/epam/hubctl.io/tree/main/docs/tutorials/010-hubctl-stack-init/hub.yaml\"\n</code></pre> <p>Read more about <code>hubctl stack init</code> here</p>"},{"location":"tutorials/010-hubctl-stack-init/#update-configuration","title":"Update configuration","text":"<p>This step is to update your configuration with the following command:</p> <pre><code>hubctl stack configure\n</code></pre>"},{"location":"tutorials/010-hubctl-stack-init/#deployment","title":"Deployment","text":"<p>The next step is to run the deployment using the following command:</p> <pre><code>hubctl stack deploy\n</code></pre> <p>Read more about the command <code>hubctl stack deploy</code> here</p> <p>If you did everything correctly, the deployment worked without errors, then the command returns the name of the component that was deployed.</p> <pre><code>## --- File: deploy.sh\n# Component hello-hubctl is saying: foo\n# Component hello-hubctl deployed successfully!\n</code></pre> <p>This command returns the name of the component <code>hello-hubctl</code> and the parameter with the value of the message <code>foo</code>.</p>"},{"location":"tutorials/010-hubctl-stack-init/#undeploy","title":"Undeploy","text":"<p>You can also run undeploy with the following command:</p> <pre><code>hubctl stack undeploy\n</code></pre> <p>Read more about the command <code>hubctl stack undeploy</code> here</p> <p>The command returns the name of the component <code>hello-hubctl</code> that was undeploy.</p> <pre><code>## --- File: undeploy.sh\n# Component hello-hubctl undeployed successfully!\n</code></pre>"},{"location":"tutorials/010-hubctl-stack-init/#conclusions","title":"Conclusions","text":"<p>Using a simple example with a ready-made configuration for the <code>hub.yaml</code> and <code>hub-component.yaml</code> files, you learned what the minimum configuration for hubctl consists of, as well as how hubctl can be used. Go ahead.</p>"},{"location":"tutorials/010-hubctl-stack-init/#whats-next","title":"What's Next?","text":"<p>You can change the hubctl config and deploy it with your parameters. Next, you will look at how to do this. Go to the next tutorial</p>"},{"location":"tutorials/015-hubctl-stack-configure/","title":"Multiple Components","text":"<p>This tutorial will show you how to configure hubctl with your simple component options.</p>"},{"location":"tutorials/015-hubctl-stack-configure/#in-this-tutorial","title":"In This Tutorial","text":"<p>This tutorials covers the following topics:</p> <ul> <li>How to add parameters of stack and components</li> <li>How to deploy a stack with multiple components</li> <li>How to apply different configuration per component</li> </ul>"},{"location":"tutorials/015-hubctl-stack-configure/#about","title":"About","text":"<p><code>hub.yaml</code> file has <code>components</code> and <code>parameters</code> fields where you describe your options.</p> <pre><code>kind: stack                                                                   # mandatory, defines a stack manifest\nversion: 1                                                                    # stack manifest schema version\nmeta:                                                                         # optional\n  name: My second deployment                                                  # optional human readable name\n\ncomponents:                                                                   # mandatory, list of components\n  - name: my-first-component                                                  # mandatory, name of the first component\n    source:                                                                   # mandatory, component source\n      dir: components/hello-hubctl                                            # mandatory, local path where to find component\n      git:                                                                    # optional, git source to download component from\n        remote: https://github.com/epam/hubctl.io.git                         # mandatory, git repository remote url\n        subDir: docs/tutorials/010-hubctl-stack-init/components/hello-hubctl  # mandatory, subdirectory in the repository\n        ref: main                                                             # optional, git reference (branch, tag, commit)\n  - name: my-second-component                                                 # mandatory, name of the second component\n    source:                                                                   # mandatory, component source\n      dir: components/hello-hubctl                                            # mandatory, local path where to find component\n\nparameters:                                                                   # optional, stack input parameters (best practice, split to separate file or files)\n  - name: message                                                             # mandatory, parameter name\n    value: baz                                                                # optional, value for parameter\n  - name: message                                                             # mandatory, parameter name\n    component: my-first-component                                             # optional, special parameter that always bounds to component name defined in `hub.yaml`\n    value: baz-first                                                          # optional, value for parameter\n</code></pre>"},{"location":"tutorials/015-hubctl-stack-configure/#deploy-stack-with-one-component","title":"Deploy Stack with one Component","text":"<p>Similar to the tutorial the previous tutorial, we will deploy a stack with one component.</p> <ul> <li> <p>Create an empty directory and change your working directory to it.</p> </li> <li> <p>Initialize a stack with <code>hubctl stack init</code> command.</p> </li> </ul> <pre><code>hubctl stack init -f \"https://raw.githubusercontent.com/epam/hubctl.io/main/docs/tutorials/015-hubctl-stack-configure/hub.yaml\"\n</code></pre> <p>Wait when stack will be initialized and component will be downloaded in the directory <code>components/hello-hubctl</code></p> <ul> <li>Now let's update the configuration and deploy this stack with the following commands:</li> </ul> <pre><code>hubctl stack configure\n</code></pre> <pre><code>hubctl stack deploy\n</code></pre> <ul> <li>You can confirm stack has been deployed with command</li> </ul> <pre><code>hubctl show\n## ...\n##   hub.stackName: My first deployment\n##   message: baz-first\n## status:\n##   status: deployed\n</code></pre> <p>As a result, you will see the deployment components with parameters and status. The <code>my-first-component</code> message is \"base-first\" because \"hub.yaml\" has a special message parameter for the <code>my-first-component</code> component.</p>"},{"location":"tutorials/015-hubctl-stack-configure/#add-a-new-component","title":"Add a New Component","text":"<ul> <li>Let's open the hubfile \"hub.yaml\" and add following to <code>components</code> field:</li> </ul> <pre><code> -  name: my-second-component\n    source:\n        dir: components/hello-hubctl\n</code></pre> <ul> <li>Let's update the configuration and deploy the second component. Run the following commands:</li> </ul> <pre><code>hubctl stack configure\n</code></pre> <pre><code>hubctl stack deploy\n</code></pre> <p>As a result, you will see the deployment components <code>my-first-component</code> and <code>my-second-component</code>.</p> <pre><code>## --- File: deploy.sh\n# Component my-first-component is saying: baz-first\n# Component my-first-component deployed successfully!\n\n# Component my-second-component is saying: baz\n# Component my-second-component deployed successfully!\n</code></pre> <ul> <li>Let's create a special parameter for the <code>my-second-component</code> component. To do this, add the following to the <code>parameters</code> field of the hub file \"hub.yaml\":</li> </ul> <pre><code> -  name: message\n    component: my-second-component\n    value: baz-second\n</code></pre> <ul> <li>Update the configuration and deployment:</li> </ul> <pre><code>hubctl stack configure\n</code></pre> <pre><code>hubctl stack deploy\n</code></pre> <p>As you can see, the <code>message</code> parameter has changed for the <code>my-second-component</code> component</p> <pre><code>## --- File: deploy.sh\n# Component my-second-component is saying: baz-second\n# Component my-second-component deployed successfully!\n</code></pre> <ul> <li>Inspect parameters for both components. Run the following commands:</li> </ul> <pre><code>hubctl show -c \"my-first-component\"\n</code></pre> <pre><code>hubctl show -c \"my-second-component\"\n</code></pre> <ul> <li>Now let's undeploy the second component and run the echo command. To start undeploying for one or more components (provided as a comma-separated value), run the following command.</li> </ul> <pre><code>hubctl stack undeploy -c \"my-second-component\"\n</code></pre> <p>Read more about undeploy here</p> <ul> <li>Observe the result</li> </ul> <pre><code>hubctl show\n## ...\n# status: incomplete\n</code></pre> <p>After we undeploy a second component, the stack status is changed from <code>deployed</code> to <code>incomplete</code>. This means one or more components are not deployed.</p> <p>Note: on the contrary, status <code>deployed</code> means all components of a stack are deployed.</p>"},{"location":"tutorials/015-hubctl-stack-configure/#conclusions","title":"Conclusions","text":"<p>In this tutorial, we added our own parameters and deployed a new configuration. We made sure that the new component was deployed and the next step was to undeploy this component.</p>"},{"location":"tutorials/015-hubctl-stack-configure/#whats-next","title":"What's Next?","text":"<p>Next, we will create a component from scratch, digging into hubctl and its additional features. Go to the next tutorial</p>"},{"location":"tutorials/017-hubctl-stack-ls/","title":"Manage Multiple Deployments","text":"<p>This tutorial explains how to manage multiple deployment of the same stack with different configurations.</p>"},{"location":"tutorials/017-hubctl-stack-ls/#in-this-tutorial","title":"In This Tutorial","text":"<p>This tutorial covers the following topics:</p> <ul> <li>How to deploy a several stacks </li> <li>How to inspect configuration of the stack</li> <li>How to deploy switch between stacks</li> </ul>"},{"location":"tutorials/020-shell-component/","title":"Create Your First Component","text":"<p>This tutorial will show you how to create a component from scratch. We will start with a minimalistic component and then we will add more features to it.</p> <p>Component is the minimal deployment unit that hubctl can manage. Good component should have few properties:</p> <ul> <li>Idenmpotent - component with the same parameters can be deployed with the same result multiple times. If component has been deployed, then it can be deployed again without any side effects.</li> <li>Generic - good component reusable this means generic enough. <code>hub-component.yaml</code> provides such abstraction. Then specific configuration will be defined via <code>hub.yaml</code> or <code>parameters.yaml</code> file on the stack level.</li> </ul> <p>Stack consists of one or multiple components. Good stack defines</p> <ul> <li>Components definition and deployment order</li> <li>Parameters that are passed to the components from environment</li> <li>Parameters that are passed between components</li> <li>Optional deployment hooks that can be used to execute custom logic before or after deployment of the component or a stack</li> </ul>"},{"location":"tutorials/020-shell-component/#component-structure","title":"Component structure","text":"<p>Each component knows how to deploy itself and export facts about deployment configuration in the well-known form of parameters. So other component would use this as an input.</p> <p>Hub component contains the following:</p> <ol> <li><code>hub-component.yaml</code> - file with input and output parameters</li> <li><code>deploy</code> and <code>undeploy</code> provisioning scripts. This however optional if component is using well known deployment tool such as <code>terraform</code>, <code>helm</code> or <code>kustomize</code>.</li> </ol> <p>In the nutshell - parameters defined in <code>hub-component.yaml</code> abstracts user from concrete provisioning technology and allows maintainer of the component improve or even change provisioning technology without breaking compatibility with the other components.</p>"},{"location":"tutorials/020-shell-component/#deploy-a-minimalistic-component","title":"Deploy a minimalistic component","text":"<ol> <li>Create a new directory <code>components/hello-shell</code></li> <li>Create a file <code>components/hello-shell/hub-component.yaml</code> and add minimalistic content</li> </ol> <pre><code>kind: component\nversion: 1\nparameters:\n- name: hub.componentName\n  env: COMPONENT_NAME\n</code></pre> <ol> <li>Create a <code>deploy.sh</code> file and add execution rights to it. Here is an example</li> </ol> <pre><code>cat &lt;&lt; EOF &gt; `components/hello-shell/deploy.sh`\n#!/bin/sh\necho \"Component $COMPONENT_NAME deployed successfully!\"\nEOF\nchmod +x `components/hello-shell/deploy.sh`\n</code></pre> <ol> <li>Create deployment reverse script: <code>undeploy.sh</code></li> </ol> <pre><code>cat &lt;&lt; EOF &gt; `components/hello-shell/undeploy.sh`\n#!/bin/sh\necho \"Component: $COMPONENT_NAME has been successfully undeployed\"\nEOF\nchmod +x `components/hello-shell/undeploy.sh`\n</code></pre> <ol> <li>Add a component reference to Hubfile (<code>hub.yaml</code>)</li> </ol> <pre><code>kind: stack\nversion: 1\ncomponents:\n- name: hello-shell\n  source:\n    dir: components/hello-shell\n</code></pre> <ol> <li>And we are ready to deploy</li> </ol> <pre><code>hubctl stack init -f `hub.yaml`\nhubctl stack deploy\n</code></pre>"},{"location":"tutorials/020-shell-component/#add-a-parameter","title":"Add a parameter","text":"<ol> <li>Add new parameter to the <code>components/hello-shell/hub-component.yaml</code></li> </ol> <pre><code>kind: component\nversion: 1\nparameters:\n- name: hub.componentName\n  env: COMPONENT_NAME\n- name: message\n  value: foo\n  env: MESSAGE\n</code></pre> <ol> <li>Modify <code>components/hello-shell/deploy.sh</code> script. You should get something like</li> </ol> <pre><code>#!/bin/sh\necho \"Component $COMPONENT_NAME is saying: $MESSAGE\"\necho \"Component $COMPONENT_NAME deployed successfully!\"\n</code></pre> <ol> <li>Add parameters to the hubfile (<code>hub.yaml</code>) to include parameter</li> </ol> <pre><code>kind: stack\nversion: 1\nmeta:\n  name: My first deployment\ncomponents:\n- name: my-first-component\n  source:\n    dir: components/hello-shell\nparameters:\n- name: message\n  value: bar\n</code></pre> <ol> <li>Run a deployment</li> </ol> <pre><code>hubctl stack deploy\n#\n# Component my-first-component is saying: bar\n# Component my-first-component deployed successfully!\n</code></pre>"},{"location":"tutorials/020-shell-component/#add-a-second-component-and-override-the-parameter","title":"Add a second component and override the parameter","text":"<p>Modify a hubfile so it would look as the following:</p> <pre><code>kind: stack\nversion: 1\nmeta:\n  name: My first deployment\ncomponents:\n- name: my-first-component\n  source:\n    dir: components/hello-shell\n- name: my-second-component\n  source:\n    dir: components/hello-shell\nparameters:\n- name: message\n  value: bar\n- name: message\n  component: my-second-component\n  value: baz\n</code></pre> <ol> <li>Run deployment</li> </ol> <pre><code>hubctl stack deploy\n# Component my-first-component is saying: bar\n# Component my-first-component deployed successfully!\n# Component my-second-component is saying: baz\n# Component my-second-component deployed successfully!\n</code></pre>"},{"location":"tutorials/020-shell-component/#add-a-template-to-the-component","title":"Add a template to the component","text":"<ol> <li>Add a file that would look like the following</li> </ol> <pre><code>cat &lt;&lt; EOF &gt; `components/hello-shell/message.txt.template`\nThe cryptic message says: ${message}\nEOF\n</code></pre> <ol> <li>Update <code>components/hello-shell/hub-component.yaml</code> so it would look like:</li> </ol> <pre><code>kind: component\nversion: 1\nparameters:\n- name: hub.componentName\n  env: COMPONENT_NAME\n- name: message\n  value: foo\n  env: MESSAGE\ntemplates:\n  files:\n  - \"*.template\"\n</code></pre> <ol> <li>Modify <code>components/hello-shell/deploy.sh</code> so it would look like the following</li> </ol> <pre><code>#!/bin/sh\necho \"Component $COMPONENT_NAME is saying: $MESSAGE\"\n# here we interact with template file... it has been already rendered\ncat \"message.txt\"\n\necho \"Component $COMPONENT_NAME deployed successfully!\"\n</code></pre> <ol> <li>Deploy the stack</li> </ol> <pre><code>hubctl stack deploy\n# Component my-first-component is saying: bar\n# The cryptic message says: bar\n# Component my-first-component deployed successfully!\n# Component my-second-component is saying: baz\n# The cryptic message says: baz\n# Component my-second-component deployed successfully!\n</code></pre>"},{"location":"tutorials/020-shell-component/#technology-specific-components","title":"Technology specific components","text":"<p>This article is not a reference guide, we do skip many things... Now we will jump into the more advanced topics. Until then we were writing a sudo component using a free form. Now we will use arguably oppinionated deployment steps however, you don't required to write your own deployment script</p> <p>At present we support following technologies</p> <ul> <li>Component Helm</li> <li>Component Kustomize</li> <li>Component Terraform</li> <li>Component ARM Deployment Template</li> </ul>"},{"location":"tutorials/030-kubernetes-rancher-desktop/","title":"Kubernetes Tutorials","text":"<p>This is a set of tutorials that describes how to use hubctl to deploy a stack on existing Kubernetes cluster.</p>"},{"location":"tutorials/030-kubernetes-rancher-desktop/#in-this-tutorial","title":"In This Tutorial","text":"<p>This tutorials covers the following topics:</p> <ul> <li>How to install and use Rancher Desktop Kubernetes</li> <li>How to use hubctl to deploy a stack on existing Kubernetes cluster</li> </ul>"},{"location":"tutorials/030-kubernetes-rancher-desktop/#install-rancher-desktop","title":"Install Rancher Desktop","text":"<p>Rancher Desktop is an app that provides container management and Kubernetes on the desktop. It is available for Mac (both on Intel and Apple Silicon), Windows, and Linux. You can read the full documentation about Rancher Desktop here.</p> <p>An open-source desktop application for Mac, Windows and Linux. Rancher Desktop runs Kubernetes and container management on your desktop. You can choose the version of Kubernetes you want to run. Each component knows how to deploy itself and export facts about deployment configuration in the well-known form of parameters. So other component would use this as an input.</p> <p>How to install and configure Rancher Desktop on Windows OS:</p> <ol> <li>Open link with Rancher Desktop documentation</li> <li>You need to upgrate WSL2 version on your computer. Manual installation steps</li> <li>Install Ubuntu</li> <li>Download and install Rancher Desktop https://rancherdesktop.io/</li> <li>Check your Rancher Desktop settings \"Preferences\"-&gt; WSL. WSL has to a checkbox with Ubuntu.</li> <li>Open Windows PowerShell as Administration and run</li> </ol> <pre><code>wsl -l -v\n</code></pre> <p>Rancher-desktop and Ubuntu have to \"Running\" states.</p> <ul> <li>Open Ubuntu terminal and run commands</li> </ul> <pre><code>docker\n</code></pre> <pre><code>sudo apt-get update\n\nsudo apt install docker.io\n</code></pre> <ul> <li>Check the version of the docker</li> </ul> <pre><code>docker version\n</code></pre> <pre><code>docker ps\n</code></pre> <p>You have to see all containers related to rancher-desktop kubernetes. And  if you have a message \"Got permission denied while trying to connect to the Docker ...\" something needs to be done so $USER always runs in group <code>docker</code> on the <code>Ubuntu</code> WSL</p> <pre><code>sudo addgroup --system docker\n</code></pre> <pre><code>sudo adduser $USER docker\n</code></pre> <ul> <li>Install kuberctl. To test connectivity to a kubernetes cluster,    open <code>Ubuntu terminal</code> and run commands</li> </ul> <pre><code>kuberctl version\n</code></pre> <p>How to use hubctl to deploy a stack on existing Kubernetes cluster: 1. Run the commands and test your Rancher Desktop Kubernetes:</p> <pre><code>rdctl version\n</code></pre> <pre><code>docker images\n</code></pre> <ol> <li>To run hubctl the use following commands:</li> </ol> <pre><code>hubctl stack init\n</code></pre> <pre><code>hubctl stack deploy\n</code></pre> <p>How to install hubctl on your local workstation you can find here</p>"},{"location":"tutorials/035-redis-component/","title":"Create Helm Component","text":"<p>This tutorial will guide you through the process of creating a Helm component. You will use Redis, an in-memory data store, as an example.</p>"},{"location":"tutorials/035-redis-component/#stack-structure","title":"Stack structure","text":"<p>The stack and component directory structure is as follows:</p> <pre><code>.\n\u251c\u2500\u2500 components                           # Directory with components\n\u2502    \u2514\u2500\u2500 redis                           # Directory with Redis-related configurations\n\u2502        \u251c\u2500\u2500 hub-component.yaml          # Component manifest\n\u2502        \u2514\u2500\u2500 values.yaml.template        # Base helm values template\n\u2514\u2500\u2500  hub.yaml                            # Stack manifest\n\n</code></pre>"},{"location":"tutorials/035-redis-component/#component-structure","title":"Component structure","text":"<p>Each component has to know how to deploy itself and export facts about deployment configuration in the well-known form of parameters. So other component would use this as an input.</p> <p>Hubctl component contains the following:</p> <ol> <li><code>hub-component.yaml</code> - file with input and output parameters</li> <li>As you are going to use <code>helm</code> you don't have to provide provisioning script <code>deploy</code> and <code>undeploy</code>.</li> </ol> <p>In the nutshell - parameters defined in <code>hub-component.yaml</code> abstracts user from concrete provisioning technology and allows maintainer of the component improve or even change provisioning technology without breaking compatibility with the other components.</p>"},{"location":"tutorials/035-redis-component/#deploy-a-minimalistic-component","title":"Deploy a minimalistic component","text":"<ol> <li>Create a new directory <code>components/redis</code></li> <li>Create a file <code>components/redis/hub-component.yaml</code></li> <li>In order to use helm we have to specify requirements: <code>helm</code> and <code>kubernetes</code></li> <li>Then you have to specify kubernetes namespace, for example: <code>redis</code></li> <li>Specifying component-specific parameters, for Redis in minimalistic way you set username/password</li> <li>For Helm you point out repository, chart version and values you want to use</li> </ol> <pre><code>kind: component                                                # mandatory, defines a component manifest\nversion: 1                                                     # mandatory, manifest schema version\n\nrequires:                                                     # optional, list of environment requirements\n  - kubernetes\n  - helm\n\nparameters:\n  - name: redis                                               # parameter name of redis\n    parameters:\n      - name: namespace                                       # redis parameter name of namespace [redis.namespace]\n        value: redis                                          # value for namespace parameter\n        env: NAMESPACE                                        # environment variable of namespace\n      - name: port                                            # redis parameter name of port [redis.port]\n        value: 6379                                           # value for port parameter\n      - name: username                                        # redis parameter name of username [redis.username]\n        fromEnv: REDIS_USER                                   # optional, parameter value is taken from environment variable, this approach allows not to store exact value in version control.\n      - name: password                                        # redis parameter name of password [redis.password]\n        fromEnv: REDIS_PASSWORD                               # if the variable does not exist in the .env file and Hubctl prompts the user to enter a value and will save it in .env file.\n  - name: helm                                                # parameter name of helm\n    parameters:\n      - name: repo                                            # helm parameter name of repo [helm.repo]\n        value: https://charts.bitnami.com/bitnami             # instructs hubctl to download helm chart from the helm repository\n        env: HELM_REPO                                        # environment variable HELM_REPO\n      - name: chart                                           # helm chart resolved via variable HELM_CHART\n        value: redis                                          # this can have multiple values, that corresponds to the helm chart location\n        env: HELM_CHART                                       # environment variable HELM_CHART\n\n\ntemplates:\n  files:                                                      # mandatory, list of template files, supports globs\n    - \"*.template\"                                            # template files in current component directory\n</code></pre> <p>Read more about Helm here</p> <ol> <li>Add a component reference to Hubfile (<code>hub.yaml</code>)</li> <li>Set required technologies, parameters and extensions</li> </ol> <pre><code>kind: stack                                                 # mandatory, defines a stack manifest\nversion: 1                                                  # stack manifest schema version\n\nrequires:                                                   # optional, list of environment requirements\n  - kubernetes\n  - helm\n\ncomponents:                                                 # mandatory, list of components\n  - name: redis                                             # mandatory, name of the component\n    source:                                                 # mandatory, component source\n      dir: components/redis                                 # mandatory, local path where to find component\n\nparameters:                                                 # optional, stack input parameters (best practice, split to separate file or files)\n  - name: kubernetes.context                                # mandatory, parameter name [kubernetes.context]\n    value: rancher-desktop                                  # optional, value of parameter\n\nextensions:                                                 # optional\n  configure:                                                # optional, steps activated during `hubctl stack configure`\n    - kubernetes\n    - env\n</code></pre> <p>You are now ready to run a deployment from the directory where hub.yaml is located. The following commands are used for this:</p> <ul> <li><code>hubctl stack init</code> - this command initializes the working directory with the <code>hub.yaml</code> file.</li> </ul> <pre><code>hubctl stack init\n</code></pre> <ul> <li><code>hubctl stack configure</code> - stack configuration before deployment</li> </ul> <pre><code>hubctl stack configure\n</code></pre> <ul> <li><code>hubctl stack deploy</code> - Runs a deployment for the entire stack, or updates the deployment of one or more components.</li> </ul> <pre><code>hubctl stack deploy\n</code></pre> <p>If the deployment status is deployed and the <code>redis</code> component is completed, you can to list of the namespaced objects, such as our pod <code>redis</code>. To do this, run the following command:</p> <pre><code>kubectl get pods --namespace=redis\n</code></pre> <p>You can see 4 redis pods with 1 master and 3 replicas have been created:</p> <pre><code># NAME               READY   STATUS\n# redis-master-0     1/1     Running\n# redis-replicas-2   1/1     Running\n# redis-replicas-1   1/1     Running\n# redis-replicas-0   1/1     Running\n</code></pre>"},{"location":"tutorials/035-redis-component/#conclusions","title":"Conclusions","text":"<p>In this tutorial, you created the Helm component. You configure the minimalistic component with using Redis, an in-memory data store, as an example. You deployed it and made sure the new component was done.</p>"},{"location":"tutorials/040-aws-component/","title":"Create Amazon S3 component with Terraform","text":"<p>This tutorial shows you how to create an Amazon S3 bucket hubctl component using Terraform.</p>"},{"location":"tutorials/040-aws-component/#in-this-tutorial","title":"In This Tutorial","text":"<p>The tutorial covers the following topics:</p> <ul> <li>How to configure the simple Amazon S3 hubctl component</li> <li>How to configure Terraform for this AWS component</li> <li>How to deploy the stack with Amazon S3 components using Terraform</li> </ul>"},{"location":"tutorials/040-aws-component/#about","title":"About","text":"<p>At the first, let's understand what is the minimum configuration for Amazon S3 component with Terraform.</p> <pre><code>\n\u251c\u2500\u2500 components                           # Directory with components\n\u2502    \u2514\u2500\u2500 s3-bucket                       # Directory with configurations\n\u2502        \u251c\u2500\u2500 hub-component.yaml          # Component manifest\n\u2502        \u251c\u2500\u2500 import                      # Special script that to import existing resources into Terraform state\n\u2502        \u2514\u2500\u2500 main.tf                     # Terraform code\n\u2514\u2500\u2500 hub.yaml                             # Stack manifest\n</code></pre> <p>Read more about Terraform Component here</p> <ul> <li>A specific configuration defining a stack manifest in <code>hub.yaml</code> is the first thing needed. Such a file describes the components and options for deployment.</li> </ul> <pre><code>kind: stack                                               # mandatory, defines a stack manifest\nversion: 1                                                # stack manifest schema version\n\nrequires:                                                 # optional, list of environment requirements\n  - aws\n\ncomponents:                                               # mandatory, list of components\n  - name: my-awshubctl-component                          # mandatory, name of the component\n    source:                                               # mandatory, component source\n      dir: components/s3-bucket                           # mandatory, local path where to find component\n\nextensions:\n  init:                                                   # optional, steps activated during `hubctl stack init`\n    - aws\n  configure:                                              # optional, steps activated during `hubctl stack configure`\n    - aws\n    - env\n  deploy:                                                 # optional, steps activated during `hubctl stack deploy\n    before:                                               # optional, steps activated on `hubctl stack deploy` but before actual deployment of components\n    - aws\n  undeploy:                                               # optional, steps activated during `hubctl stack undeploy\n    after:                                                # optional, steps activated on `hubctl stack undeploy` but after actual undeploy of components\n    - aws\n\n</code></pre> <p><code>hub.yaml</code> file has <code>components</code> field where you describe your components.</p> <ul> <li>You will also need <code>hub-component.yaml</code>, this is a reusable component, it is generic and provides an abstraction with dependencies needed for deployment.</li> </ul> <pre><code>kind: component                                     # mandatory, defines a component manifest\nversion: 1                                          # mandatory, manifest schema version\n\nrequires:\n  - aws\n  - terraform\n\nparameters:\n  - name: hub.stackName                              # parameter of the stack name\n    fromEnv: HUB_STACK_NAME                          # environment variable HUB_STACK_NAME is a name of the stack. It is an unique stack identifier\n  - name: bucket.name                                # parameter of the bucket name\n    value: \"${hub.stackName}\"                        # value for the S3 bucket name parameter from hub stack name. This name must be unique for S3\n    env: TF_VAR_name                                 # TF_VAR_* environment variable (recommended way), mapping to environment variable for use deployment script\n  - name: bucket.acl                                 # parameter of the Access control list (ACL) of the bucket\n    value: \"private\"                                 # default value is private\n    env: TF_VAR_acl                                  # Terraform environment variable for the acl\n  - name: cloud.region                               # parameter of the AWS region\n    value: \"eu-central-1\"                            # default value is region\n    fromEnv: AWS_REGION                              # environment variable AWS_REGION. It is an unique stack identifier\n  - name: cloud.profile                              # parameter of the specific AWS profile\n    value: \"default\"                                 # the default profile name is default\n    fromEnv: AWS_PROFILE                             # environment variable AWS_PROFILE. It is an unique stack identifier\n  - name: bucket.region                              # parameter of the AWS bucket region\n    value:  ${cloud.region}                          # value for the S3 bucket regin parameter from the cloud region\n    env: TF_VAR_bucket_region                        # Terraform environment variable for the bucket region\n  - name: aws.serviceAccount                         # parameter of the service account\n    env: TF_VAR_service_account_name                 # Terraform environment variable of the service account name\n    empty: allow\n\noutputs:\n  - name: bucket.kind\n    value: s3\n  - name: bucket.region\n    value: ${cloud.region}\n    brief: Amazon S3 bucket region\n\n</code></pre> <p>You can provide Terraform variables in two ways. Read more about it here</p> <p>Hubctl will automatically detect Terraform code when component contains one or more *.tf files. Terraform configuration with <code>main.rf</code> file:</p> <pre><code># Create a name variable\nvariable \"name\" {\n  type = string\n}\n\n# Create a service_account_name variable\nvariable \"service_account_name\" {\n  type    = string\n  default = \"\"\n}\n\n# Create a acl variable\nvariable \"acl\" {\n  type = string\n  description = \"S3 bucket ACL\"\n}\n\n# Create a region variable\nvariable \"bucket_region\" {\n  type = string\n  description = \"s3 bucket region\"\n}\n\n# Configure private bucket with versioning enabled, tags and website\nmodule \"s3_bucket\" {\n  source = \"terraform-aws-modules/s3-bucket/aws\"\n\n  bucket = var.name\n  acl    = var.acl\n\n  control_object_ownership = true\n  object_ownership         = \"ObjectWriter\"\n\n  website = {\n    index_document = \"index.html\"\n    error_document = \"error.html\"\n  }\n\n  versioning = {\n    enabled = false\n  }\n\n  tags = {\n    Name        = \"Hubctl bucket\"\n    Environment = \"Dev\"\n  }\n}\n</code></pre> <p>The <code>import</code> file is a necessary step to allow manage resources such as AWS S3 bucket. It is a special script that to import existing resources into Terraform state.</p> <pre><code>#!/bin/sh -e\n# shellcheck disable=SC2154\n\nif gsutil -q ls -b \"gs://$TF_VAR_name\" &gt; /dev/null 2&gt;&amp;1; then\n  terraform import 'aws_storage_bucket._' \"$TF_VAR_name\" || true\nfi\n\n</code></pre>"},{"location":"tutorials/040-aws-component/#deploy-stack-with-amazon-s3-component","title":"Deploy Stack with Amazon S3 Component","text":"<p>You are now ready to run a deployment from the directory where hub.yaml is located. The following commands are used for this:</p> <ul> <li><code>hubctl stack init</code> - this command initializes the working directory with the <code>hub.yaml</code> file.</li> </ul> <pre><code>hubctl stack init\n</code></pre> <ul> <li><code>hubctl stack configure</code> - stack configuration before deployment</li> </ul> <pre><code>hubctl stack configure\n</code></pre> <ul> <li><code>hubctl stack deploy</code> - Runs a deployment for the entire stack, or updates the deployment of one or more components.</li> </ul> <pre><code>hubctl stack deploy\n</code></pre> <p>As a result, you could see the Amazon S3 bucket with the following command:</p> <pre><code>aws s3 ls\n</code></pre>"},{"location":"tutorials/040-aws-component/#add-terraform-outputs","title":"Add Terraform Outputs","text":"<p>Create a file called <code>outputs.tf</code> in your components/s3-bucket directory. Add the configuration below to outputs.tf to define outputs for your S3 bucket's ID, Region, Website Endpoint and Website Domain .</p> <pre><code>output \"s3_bucket_name\" {\n  value       = module.s3_bucket.s3_bucket_id\n  description = \"The name of the bucket.\"\n}\n\noutput \"s3_bucket_region\" {\n  value       = module.s3_bucket.s3_bucket_region\n  description = \"The AWS region this bucket resides in.\"\n}\n\noutput \"s3_bucket_website_endpoint\" {\n  value       = module.s3_bucket.s3_bucket_website_endpoint\n  description = \"The website endpoint, if the bucket is configured with a website. If not, this will be an empty string.\"\n}\n\noutput \"s3_bucket_website_domain\" {\n  value       = module.s3_bucket.s3_bucket_website_domain\n  description = \"Name of the website bucket\"\n}\n</code></pre> <ul> <li>Inspect output values   Terraform stores output values in the configuration's state file. In order to see these outputs, you need to update the state by applying this new configuration, even though the infrastructure will not change. Deploy your infrastructure with following commands:</li> </ul> <pre><code>hubctl stack configure\n</code></pre> <pre><code>hubctl stack deploy\n</code></pre> <p>Notice the output after the apply:</p> <pre><code>##Outputs:\n\n# s3_bucket_name = \"unique-bucket-name\"\n# s3_bucket_region = \"eu-central-1\"\n# s3_bucket_website_domain = \"s3-website.eu-central-1.amazonaws.com\"\n# s3_bucket_website_endpoint = \"unique-bucket-name.s3-website.eu-central-1.amazonaws.com\"\n</code></pre> <p>You can destroy your infrastructure with following commands:</p> <pre><code>hubctl stack undeploy\n</code></pre>"},{"location":"tutorials/040-aws-component/#conclusions","title":"Conclusions","text":"<p>In this tutorial, you create the simple Amazon S3 bucket hubctl. Use Terraform to configure this AWS component.</p>"},{"location":"tutorials/040-aws-component/#see-also","title":"See also","text":"<ul> <li>Terraform Component</li> <li>Article about AWS Components</li> </ul>"}]}