{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hubctl","text":"<p>Hubctl helps to manage your infrastructure as code by allowing to split your infrastructure into reusable components.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Built in support for all popular infrastructure automation tools (such as Terraform, Kustomize, Helm, ARM etc)</li> <li>Supports multiple cloud providers (AWS, Azure, GCP, Kubernetes)</li> <li>Manages, deployments, backups, parameters</li> <li>Extensible with plugins and automation hooks</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install hubctl follow the instructions on the installation page.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>To get started with hubctl, follow the quickstart guide.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Hubctl overview</li> <li>Components</li> <li>Stacks</li> <li>Extensions</li> <li>Toolbox</li> <li>Hooks</li> </ul>"},{"location":"install/","title":"Install","text":""},{"location":"install/#installation","title":"Installation","text":"<p>This page will show how to install hubctl on your local workstation</p> <p>There are few ways to install hubctl:</p> <ol> <li>Download binary</li> <li>Homebrew Formula</li> </ol>"},{"location":"install/#download-binary","title":"Download binary","text":"<p>To download the latest of hubctl run the following </p>"},{"location":"install/#curl","title":"cURL","text":"<pre><code>curl -LJ \"https://github.com/epam/hubctl/releases/latest/download/hubctl_$(uname -s)_$(uname -m).tar.gz\" \\|\n  tar xz -C /tmp &amp;&amp; sudo mv /tmp/hubctl /usr/local/bin\n</code></pre>"},{"location":"install/#wget","title":"Wget","text":"<pre><code>wget \"https://github.com/epam/hubctl/releases/latest/download/hubctl_$(uname -s)_$(uname -m).tar.gz\" -O - |\\\n  tar xz -C /tmp &amp;&amp; sudo mv /tmp/hubctl /usr/local/bin\n</code></pre>"},{"location":"install/#homebrew-formula","title":"Homebrew Formula","text":"<pre><code>brew tap epam/tap\nbrew install epam/tap/hubctl\n</code></pre>"},{"location":"install/#extensions","title":"Extensions","text":"<p>Extensions are the plugins for hubctl. It provides additional functionality to hubctl. To install extensions run:</p> <pre><code>hubctl extensions install\n</code></pre> <p>There are few common tools used across all extensions. Other tools are component specific </p> <ul> <li>bash</li> <li>curl</li> <li>jq</li> <li>yq v4</li> </ul>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>Some components and extensions requires additional tools to be installed:</p> <ul> <li>AWS CLI - for components that requires <code>aws</code> </li> <li>Azure CLI - for component that requires <code>azure</code></li> <li>Gcloud SDK - for component that requires <code>gcp</code></li> <li>kubectl - for components that requires <code>kubernetes</code></li> <li>Terraform - for components that requires <code>terraform</code></li> <li>Helm - for components that requires <code>helm</code></li> <li>Kustomize*</li> <li>Node.js - to activate <code>hubctl pull</code> extension</li> <li>[Docker CLI] - to active <code>hubctl toolbox</code> extension</li> </ul> <p>Special note for Kustomize: by default kustomize has been shipped together with kubectl (<code>kubectl -k ...</code>) However if user has a kustomize installed. Hubctl will use it instead.</p>"},{"location":"install/#whats-next","title":"What's Next","text":"<ul> <li>See our Getting Started guide</li> </ul>"},{"location":"use-cases/","title":"When do you need hubctl?","text":"<p>When we created a Hubctl we had an idea to promote the best practices for infrastructure as code. We wanted to create a tool that would help us to manage our infrastructure as code in a consistent and repeatable way.</p>"},{"location":"use-cases/#package-manager-for-the-cloud","title":"Package manager for the Cloud","text":"<p>Operating Systems have got a package managers for ages now like <code>homebrew</code> for Mac and <code>choco</code> for Windows. It is able to download and install packages, resolve dependencies etc. But there is no such package manager for the cloud deployments. </p> <p>Today we organize our infrastructure as code in the form of Terraform, Kustomize, Helm, ARM etc. Each of these tools solves solves a specific problem. When you find yourself in the situation when you need to multiple tools for your deployment, you end up with a lot of boilerplate code. Hubctl solves this problem by these integrations and provides a single interface to manage your infrastructure.</p>"},{"location":"use-cases/#break-up-monolithic-deployments","title":"Break-up monolithic deployments","text":"<p>We have seen when application deployment code was 60% of entire codebase. This makes deployment code a biggest component of your entire application. Similar to applications today split into microservices, we can also split our infrastructure into multiple components. This makes it easier to manage and maintain.</p> <p>Hubctl provides mechanisms to manage your deployment as a stack of components. Each component can be deployed and managed independently and can use it's own deployment tool.</p>"},{"location":"use-cases/#disposable-infrastructure","title":"Disposable Infrastructure","text":"<p>Hubctl provides you with a single place where you can deploy multiple environments for your application and dispose it when you don't need it. </p>"},{"location":"hubctl/","title":"Overview","text":"<p>Hubctl is stack composition and lifecycle tool:</p> <ul> <li>template and stack creation, stack deploy / undeploy / backup lifecycle;</li> <li>stack and component parameters, output variables, and state;</li> </ul>"},{"location":"hubctl/#components","title":"Components","text":"<p>Hubctl core experience is about connecting various pieces of software - called components into a stack, each component developed independently yet designed to work together, via common set of parameters for inputs and outputs. See more about components here</p>"},{"location":"hubctl/#stacks","title":"Stacks","text":"<p>In real life we rarely deploy just a single component. We usually need to take several components and stack them together into a coherent deployment unit that actually makes sense to deploy</p> <p>To deploy a stack hubctl needs a <code>hub.yaml</code> file that lists the components and parameters that are needed to deploy the stack. </p>"},{"location":"hubctl/cli/","title":"Command <code>hubctl</code>","text":"<p>By default hubctl is a CLI tool that provides a set of commands to manage stacks and deployments</p> Command Description <code>hubctl stack</code> Commands to manage your deployment <code>hubctl show</code> Show parameters of a deployed stack <code>hubctl toolbox</code> Starts a local toolbox container and mounts current file system inside <code>hubctl state</code> Helps you to manage stacks states"},{"location":"hubctl/cli/#common-flags","title":"Common Flags","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-show/","title":"Command: <code>hubctl show</code>","text":"<p>Helps to browse parameters for deployment</p>"},{"location":"hubctl/cli/hubctl-show/#parameters","title":"Parameters","text":"Flag Description Required <code>-q  -jq --query</code> Apply a <code>jq</code> style filter query to the command results <code>-o --split</code> By default, input and output parameters of a stack has been merged. If you want to split them into two different group to view specifically input or output parameters, then use this flag <code>-m --machine</code> By default parameters exported in a flat manner as a Key-Value pair. Yet you may want instead to present parameters as a <code>.</code> (dot) delimited objects. This can significantly simplify scripting when you want to wire deployment outputs with your specific automation <code>-c --component</code> Show input and ouptut parameters of a specific component in the stack. <code>--</code> For advanced case: when you want to supply some <code>jq</code> native arguments to the <code>hubctl show</code> command. Check out <code>jq --help</code> for allowed values"},{"location":"hubctl/cli/hubctl-show/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-show/#usage-example","title":"Usage Example","text":"<p>To show all parameters of a stac</p> <pre><code>hubctl show\n</code></pre> <p>To show domain name of a stack</p> <pre><code>hubctl show -q '.parameters.dns.domain'\n</code></pre> <p>To show password of a <code>mysql</code> component in the stack</p> <pre><code>hubctl show -c 'mysql' -q '.outputs.component.mysql.password'\n</code></pre>"},{"location":"hubctl/cli/hubctl-show/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack</code></li> <li><code>hubctl toolbox</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-configure/","title":"Command: <code>hubctl stack configure</code>","text":"<p>Reads configuration information in one or multiple hubfiles referenced by the command <code>hubctl stack init</code> and applies configuration before the stack deployment.</p> <p>When hubfile will require parameter supplied bia environment variable (<code>fromEnv</code>) ,for instance passwords or access credentials, then this command will save value for this variable in <code>.env</code> file. You can change this value later by modifying <code>.env</code> file.</p> <p>Upon completion of configure command execution will ensure that all stack input parameters has been defined.</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#configuration-requirements","title":"Configuration requirements","text":"<p>Input parameters can be supplied by various scripts. Which exactly and it's order has been defined in hubfile via requirements</p> <pre><code>extensions:\n  configure:\n  - env\n  - gcp\n</code></pre> <p>List of supported requirements for configuration</p> Requirement Description <code>gcp</code> Configures stack for deployment to GCP. Will bootstrap a DNS zone (optionally relying to bubble dns service) and a GCS bucket to store state <code>aws</code> Configures stack for deployment to AWS. Will bootstrap a Route53 zone (optionally relying to bubble dns service) and a S3 bucket to store state. This will make sure that credentials has been reachable for the deployment <code>azure</code> Similar to <code>aws</code> and <code>gcp</code> will configure stack for Microsoft Azure Cloud deployment <code>env</code> Ensures that all environment variables (<code>fromEnv</code>) has been defined by the user <code>kubernetes</code> Reserved when user already have got a running Kubernetes cluster. This requirement may conflict if stack will actually deploy a new cluster. This requirement will ensure that kubernetes credentials stored in kubeconfig has been reachable by the kubeconfig by creating py of just one kube-context in <code>.hub/env</code> directory <code>components</code> DEPRECATED. Functionality of this requirement has been moved to  <code>hubctl stack init</code> command <code>backup</code> Activate backup/restore functionality for the stack (note that at least one component should accept verb <code>backup</code>"},{"location":"hubctl/cli/hubctl-stack-configure/#command-parameters","title":"Command Parameters","text":"<p>These parameters applies across all extension commands. If hubfile contains additional requirements then there may be additional command parameters</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#common-parameters","title":"Common parameters","text":"Flag Description Required <code>-r --requirement &lt;arg&gt;</code> Specific one or multiple (this parameter can repeat) requirements to apply for reconfiguration. If no requirements provided, then this means all requirements as specified in hubfile <code>--profile &lt;arg&gt;</code> Set specific deployment profile <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-configure/#google-cloud-platform","title":"Google Cloud Platform","text":"<p>Flags specific to <code>gcp</code> parameters</p> Flag Description Required <code>--gcp-project-id  &lt;arg&gt;</code> Override project id in <code>.env</code> file <code>--gcs-bucket-name  &lt;arg&gt;</code> Override GCS bucket name (defaults to: <code>gs://&lt;project_id&gt;-superhub</code>) <code>--domain-name &lt;arg&gt;</code> Instructs to use a specific domain name (otherwise will be autogenerated by bubble DNS service)"},{"location":"hubctl/cli/hubctl-stack-configure/#amazon-web-services","title":"Amazon Web Services","text":"<p>Flags specific to <code>aws</code> parameters</p> Flag Description Required <code>--aws-region &lt;arg&gt;</code> Use specific AWS region (otherwise default from AWS profile will be used) <code>--aws-profile &lt;arg&gt;</code> Use specific AWS profile (otherwise current or default profile will be used <code>--aws-profile &lt;arg&gt;</code> Use specific AWS profile (otherwise current or default profile will be used <code>--domain-name &lt;arg&gt;</code> Instructs to use a specific domain name (otherwise will be autogenerated by bubble DNS service) <code>--base-domain-aws-profile &lt;arg&gt;</code> To address case when parent hosted zone managed in different AWS account <code>--prefer-local</code> Instructs not to use hubctl state in S3 bucket <code>--dns-update</code> Instructs bubble DNS service to update TTL on existing DNS record (instead of requesting new random record) <code>--bubbles-secret-key &lt;arg&gt;</code> User provides bubble dns secret that will proof his ownership on stack. Otherwise value from .env file will be used"},{"location":"hubctl/cli/hubctl-stack-configure/#microsoft-azure-cloud","title":"Microsoft Azure Cloud","text":"<p>Flags specific to <code>azure</code> parameters</p> Flag Description Required <code>--azure-region &lt;arg&gt;</code> Use specific Azure region (otherwise default from AWS profile will be used) <code>--azure-resource-group &lt;arg&gt;</code> Azure Resource Group (defaults to value from: <code>AZURE_RESOURCE_GROUP_NAME</code>, <code>AZURE_DEFAULTS_GROUP</code> environment variables) <code>--azure-subscription &lt;arg&gt;</code> Azure Resource Group (defaults to value from: <code>AZURE_SUBSCRIPTION_ID</code>) <code>--base-domain-resource-group &lt;arg&gt;</code> and <code>--base-domain-subscription &lt;arg&gt;</code> To address case when parent hosted zone managed in different AWS account <code>--prefer-local</code> Instructs not to use hubctl state in S3 bucket <code>--dns-update</code> Instructs bubble DNS service to update TTL on existing DNS record (instead of requesting new random record) <code>--bubbles-secret-key &lt;arg&gt;</code> User provides bubble dns secret that will proof his ownership on stack. Otherwise value from .env file will be used"},{"location":"hubctl/cli/hubctl-stack-configure/#environment-variables","title":"Environment Variables","text":"<p>Flags specific to <code>env</code> parameters</p> Flag Description Required <code>-f --file &lt;arg&gt;</code> Ask for variables from only specific hubfiles (defaults to <code>HUB_FILES</code> variable in <code>.env</code> file,  can repeat multiple time) <code>--defaults</code> Instructs not to confirm user input for environment variables (reserved for non-interactive usage, such as CI server)"},{"location":"hubctl/cli/hubctl-stack-configure/#kubernetes","title":"Kubernetes","text":"<p>Flags specific to <code>kubernetes</code> parameters</p> Flag Description Required <code>--kubeconfig &lt;arg&gt;</code> Path to kubeconfig. Otherwise <code>KUBECONFIG</code> environment variable will be used. <code>--kubecontext &lt;arg&gt;</code> Use specific context inside kubeconfig. Otherwise current will be used <code>--current-kubecontext</code>  or <code>--kubecontext _</code> Explicitly says to use current kube-context <p>Note: If you want to run configure from the pod (inside kubernetes). This extension configure stack to rely on service account of the pod</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#components-deprecated","title":"Components (deprecated)","text":"<p>Please use new command: <code>hubctl stack init</code> instead</p> Flag Description Required <code>-f --file &lt;arg&gt;</code> Instructs to use specific hubfiles (defaults to <code>HUB_FILES</code> variable in <code>.env</code> file,  can repeat multiple time) <code>-c --component &lt;arg&gt;</code> Ask to download a specific component only (can repeat multiple times, defaults to all components defined in hubfiles) <code>--override</code> Write over files if component already exists <p>Note: If you want to run configure from the pod (inside kubernetes). This extension configure stack to rely on service account of the pod</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#dyi-configuration","title":"DYI Configuration","text":"<p>Can I build my own configuration script for my custom case? Or override behavior of existing one? Yes just follow couple of simple steps</p> <ol> <li>Create file: <code>&lt;working-dir&gt;/.hub/&lt;requirement&gt;/configure</code> and add execution rights</li> <li>Write your script using: <code>shell</code> (preferably), <code>bash</code> or general purpose language of your choice.</li> <li>Add reference to the hub.yaml</li> </ol> <pre><code># example\nmkdir -p \".hub/mysuperextension\"\ntouch \".hub/mysuperextension/configure\"\nchmod +x \".hub/mysuperextension/configure\"\n</code></pre> <p>then feel free to add reference that looks like the following to the <code>hub.yaml</code></p> <pre><code>extensions:\n  configure:\n  - mysuperextension\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-configure/#usage-example","title":"Usage Example","text":"<p>Configure stack before deployment</p> <pre><code>hubctl stack configure\n</code></pre> <p>Reload GCP configuration, and refresh TTL for bubble DNS service</p> <pre><code>hubctl stack configure -r \"gcp\"\n</code></pre> <p>Configure refresh kubeconfig for kubernetes cluster (if access rotated)</p> <pre><code>hubctl stack configure -r \"kubernetes\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-configure/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack init</code></li> <li><code>hubctl stack deploy</code></li> <li><code>hubctl stack ls</code></li> <li><code>hubctl stack rm</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-deploy/","title":"Command: <code>hubctl stack deploy</code>","text":"<p>Runs deployment for entire stack or updates deployment of one or few components</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#command-parameters","title":"Command Parameters","text":"Flag Description Required <code>-c --component &lt;component&gt;</code> Run deployment for one  component or multiple (supplied as comma separated value) <code>-o --offset &lt;component&gt;</code> Start deployment from specific component (handy when you want to restart deployment, and want to skip few from the beginning in the runlist) <code>-l --limit &lt;component&gt;</code> Stop deployment after desired (opposite to <code>--offset</code> flag) <code>--profile</code> Choose a specific deployment provider (defaults to <code>HUB_PROFILE</code> in <code>.env</code> file) <code>--tty</code> or <code>--no-tty</code> Instructs if user wants to group deployment outputs per component"},{"location":"hubctl/cli/hubctl-stack-deploy/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-deploy/#advanced-usage","title":"Advanced usage","text":""},{"location":"hubctl/cli/hubctl-stack-deploy/#hooks-for-before-deployment-and-after-deployment","title":"Hooks for before-deployment and after-deployment","text":"<p>It is possible if user will decide to add one or more deployment hooks. This hooks will be executed before or after the deployment has been done.</p> <p>These deployment hooks has been defined via hubfile</p> <pre><code>extensions:\n  deploy:\n    before:\n    - &lt;extension&gt;\n    after:\n    - &lt;extension&gt;\n</code></pre> <p>example:</p> <pre><code>extensions:\n  deploy:\n    before:\n    - kubernetes\n    after:\n    - inventory-configmap\n</code></pre> <p>Example above will run a kubernetes extension before the deployment to check connectivity to the desired cluster. It will also instruct a <code>hub</code> to save deployment state inside of the kubenretes cluster as a <code>configmap</code>. This is viable alternative to the object storage and can be handy to store copy of a state for on-prem deployments.</p> <p>At the moment there are few extensions that supports before deployment or after deployemnt</p> Extension Description Before After <code>kubernetes</code> Checks connectivity to existing kubernetes cluster before actual deployment (helps with deployment success rate) x x <code>aws-metering</code> Provides integration to aws marketplace metering x <code>inventory-configmap</code> Save a copy of a deployment state in the configmap of a kubernetes cluster. Adds some extra persistence for on-prem deployments as they might not have object storage bucket access to store state there x"},{"location":"hubctl/cli/hubctl-stack-deploy/#define-run-list","title":"Define run-list","text":"<p>By default run-list has been derived from the components definition following the algorithm:</p> <ol> <li>Component listed as dependency should run before the component that depends on it</li> <li>Component without dependency should run in the order of declaration</li> </ol> <p>However user can overwrite order by defining a custom run-list in the <code>hub.yaml</code> file</p> <p>Component run-list order has been defined in hubfile. It looks like below.  Then the User will maintain run-list order when they add or remove the component</p> <pre><code>lifecycle:\n  order:\n  - component1\n  - component2\n  # ...\n  - componentN\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-deploy/#dyi-deployment-hook","title":"DYI deployment hook","text":"<p>Q: Can I add my own deployment hook? A: Yes, easy!</p> <ol> <li>Create a file in the <code>.hub/&lt;extension&gt;/before-deploy</code> and add execution rights</li> <li>Implement hook using shell (preferably), bash, or language of your choice</li> </ol> <p>Q: Which shell hooks I can build? A: Make sure you follow the naming convention for file name</p> Script Description <code>before-deploy</code> Executed before deployment operation, fail with error code non 0 to stop deployment from happening <code>after-deploy</code> Executed before deployment operation, fail with error code non 0 to mark deployment as failed. Useful when you apply some deployment tests <code>before-undeploy</code> Executed before un-deployment operation, fail with error code non 0 to stop un-deployment from happening <code>after-undeploy</code> Executed before un-deployment operation, fail with error code non 0. Useful if you want to check that all resources has been deleted and grab user attention on some cloud junk"},{"location":"hubctl/cli/hubctl-stack-deploy/#executors","title":"Executors","text":"<p>There are few ways how to run a deployment, It primarilly depends on if this is a desire of the user where they want to have all desired provisioning tools setup and keep updated periodically. User also might  want to run deployment from CI server etc. This is why we have got different deployment profiles</p> <p>Executor has been configured in <code>.env</code> file via environment variable <code>HUB_DEPLOY_PROFILE</code>. This variable has been set during the <code>configure</code> time, but can be changed by editing <code>.env</code> file</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#executor-local","title":"Executor: <code>local</code>","text":"<p>This profile has been preferable when user wants to run all automation from their local workstation. User also have got all provisioning tools required by the stack (such as <code>terraform</code>, <code>helm</code> or <code>kustomize</code>) installed locally. This profile gives fastest feedback if something goes wrong and direct tools to troubleshoot</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#executor-toolbox","title":"Executor: <code>toolbox</code>","text":"<p>If you have a docker locally then you may not want to install all provisioning tools. Instead <code>toolbox</code> profile will run a special Docker container with all tools installed and then mount your working diretory inside. This deployment profile is handy to work in a team and  address works on my workstation issues as every team member will work with exactly the same toolchain that comes with toolbox container</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#executor-pod","title":"Executor: <code>pod</code>","text":"<p>This is evolution of a toolbox profile. Instead, if you have a Kubernetes cluster at your disposal, you may want to run an automation task as a Kubernetes native pod. This pod will do the following</p> <ol> <li>Run a <code>toolbox</code> container in a Kubernetes namespace <code>automation-tasks</code></li> <li>Copy a working directory inside of a <code>pod</code></li> <li>Copy credentials such as <code>aws</code> or <code>kubernetes</code></li> <li>Run automation task</li> <li>Collect the result and store locally state</li> <li>Shut down the container</li> </ol>"},{"location":"hubctl/cli/hubctl-stack-deploy/#diy-executor","title":"DIY executor","text":"<p>If you want to build your own deployment profile, then put a script into the <code>.hub/profiles/&lt;profile-name&gt;</code> directory and add execution rights. Then update environment variable <code>HUB_DEPLOY_PROFILE</code> in the <code>.env</code></p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#usage-example","title":"Usage Example","text":"<p>To deploy all components in the run-list:</p> <pre><code>hubctl stack deploy\n</code></pre> <p>To deploy specific components with order defined in the runlist</p> <pre><code>hubctl stack deploy -c \"external-dns,cert-manager\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-deploy/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack undeploy</code></li> <li><code>hubctl stack configure</code></li> <li><code>hubctl stack init</code></li> <li><code>hubctl stack ls</code></li> <li><code>hubctl stack rm</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-elaborate/","title":"Command: <code>hubctl stack elaborate</code>","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/cli/hubctl-stack-init/","title":"Command: <code>hubctl stack init</code>","text":"<p>Initialize a new stack configuration in the user working directory</p>"},{"location":"hubctl/cli/hubctl-stack-init/#command-parameters","title":"Command Parameters","text":"Flag Description Required <code>-f --file &lt;hubfile&gt;</code> path (or URL) to hubfile with stack definitions. This argument can repeat multile times x <code>-s --state &lt;statefile&gt;</code> Path or URL to <code>--force</code> Specify this fag if current stack has been already initialized. This flag will overwrite existing configuration"},{"location":"hubctl/cli/hubctl-stack-init/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-init/#usage-example","title":"Usage Example","text":"<p>Example on how to initialize a new stack to deploy a GKE cluster</p> <pre><code>mkdir \"my-gke-cluster\"\ncd \"my-gke-cluster\"\nhubctl stack init -f \"https://raw.githubusercontent.com/epam/hubctl-google-stacks/main/gke-empty-cluster/hub.yaml\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-init/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack configure</code></li> <li><code>hubctl stack deploy</code></li> <li><code>hubctl stack ls</code></li> <li><code>hubctl stack rm</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-ls/","title":"Command: <code>hubctl stack ls</code>","text":"<p>Useful command when you have deployment multiple stacks from the one working directory it will help you to navigate across them</p> <p>It prints stack domain name as an identifier and marks which has been set as a active with the <code>*</code> symbol</p> <p>See example below</p> <pre><code>hubctl stack ls\n# ACTIVE  STACK                 STATUS      TIMESTAMP\n# *       disastrous-lundy-871  undeployed  2023-04-13T13:11:50\n#         funny-ray-ray-795     deployed    2023-04-13T13:09:14\n</code></pre> <p>Most likely the stack has been initialized with <code>hubctl stack init</code> command however not yet configured (<code>hubctl stack configure</code>)</p>"},{"location":"hubctl/cli/hubctl-stack-ls/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack init</code></li> <li><code>hubctl stack configure</code></li> <li><code>hubctl stack set</code></li> <li><code>hubctl stack rm</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-rm/","title":"Command: <code>hubctl stack rm</code>","text":"<p>This command is basically deletes stack configuration created via <code>hubctl stack init</code> or <code>hubctl stack configure</code> commands.</p> <p>This command won't undeploy a stack if it has been deployed</p> <p>Common usage scenario is actually a clean up your working directory from stacks that has been previously undeployed and you don't have use of them anymore</p>"},{"location":"hubctl/cli/hubctl-stack-rm/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack init</code></li> <li><code>hubctl stack configure</code></li> <li><code>hubctl stack ls</code></li> <li><code>hubctl stack set</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-set/","title":"Command: <code>hubctl stack set</code>","text":"<p>Set stack by it's name as a current.</p> <p>Example</p> <pre><code>hubctl stack ls\n# ACTIVE  STACK                 STATUS      TIMESTAMP\n# *       disastrous-lundy-871  undeployed  2023-04-13T13:11:50\n#         funny-ray-ray-795     deployed    2023-04-13T13:09:14\n\nhubctl stack set \"funny-ray-ray-795\"\n\nhubctl stack ls\n# ACTIVE  STACK                 STATUS      TIMESTAMP\n#         disastrous-lundy-871  undeployed  2023-04-13T13:11:50\n# *       funny-ray-ray-795     deployed    2023-04-13T13:09:14\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-set/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack init</code></li> <li><code>hubctl stack configure</code></li> <li><code>hubctl stack ls</code></li> <li><code>hubctl stack rm</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-undeploy/","title":"Command: <code>hubctl stack undeploy</code>","text":"<p>Reverse deployment operation for entire stack or particular components</p> <p>Because <code>undeploy</code> is a reverse operation to <code>deploy</code>, you might want to check out article for <code>hubctl stack deploy</code> sections about executors and deployment hooks.</p>"},{"location":"hubctl/cli/hubctl-stack-undeploy/#command-parameters","title":"Command Parameters","text":"Flag Description Required <code>-c --component &lt;component&gt;</code> Start un-deployment for one  component or multiple (supplied as comma separated value) <code>-o --offset &lt;component&gt;</code> Start un-deployment from specific component (handy when you want to restart un-deployment, and want to skip few from the beginning in the runlist) <code>-l --limit &lt;component&gt;</code> Stop un-deployment after desired (opposite to <code>--offset</code> flag) <code>--profile</code> Choose a specific un-deployment provider (defaults to <code>HUB_PROFILE</code> in <code>.env</code> file) <code>--tty</code>  or <code>--no-tty</code> Instructs if user wants to group outputs per component ]"},{"location":"hubctl/cli/hubctl-stack-undeploy/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-undeploy/#usage-example","title":"Usage Example","text":"<p>To un-deploy all components in the runlist:</p> <pre><code>hubctl stack undeploy\n</code></pre> <p>To un-deploy specific components with order defined in the run-list</p> <pre><code>hubctl stack undeploy -c \"external-dns,cert-manager\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-undeploy/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack deploy</code></li> <li><code>hubctl stack init</code></li> <li><code>hubctl stack configure</code></li> <li><code>hubctl stack rm</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack/","title":"Command: <code>hubctl stack</code>","text":"<p>Helps you to manage your stack deployments</p>"},{"location":"hubctl/cli/hubctl-stack/#sub-commands","title":"Sub-commands","text":"<p>Extensions provides following commands:</p> Command Description <code>hubctl stack init</code> Initialise a new stack deployment in the working directory <code>hubctl stack configure</code> Manage configuration before the deployment <code>hubctl stack deploy</code> Apply deployment to target infrastructure <code>hubctl stack undeploy</code> Reverse deployment action <code>hubctl stack ls</code> See other stacks that has been initialized for the working directory <code>hubctl stack set</code> Change a different current stack <code>hubctl stack rm</code> Delete configuration of a stack from working directory. This commands is irreversive, and doesn't run <code>undeploy</code>"},{"location":"hubctl/cli/hubctl-stack/#advanced-commands","title":"Advanced Commands","text":"<p>These commands intended for advanced usage</p> Command Description <code>hubctl stack backup</code> Stack backup/restore management (*if \"backup\" verb supported by at least one component in the stack) <code>hubctl stack elaborate</code> Reconcile defined parameters and a state <code>hubctl stack deploy</code> Apply deployment to target infrastructure <code>hubctl stack invoke</code> Execute other verb rather than <code>deploy</code>, <code>undeploy</code> or <code>backup</code>. (*if verb supported by at least one component in the stack) <code>hubctl stack explain</code> Command reserved for state and parameters diagnostics"},{"location":"hubctl/cli/hubctl-stack/#common-flags","title":"Common Flags","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-toolbox/","title":"Command: <code>hubctl toolbox</code>","text":"<p>This command will run a toolbox container in interactive mode and will let you to deploy stack without having to install all necessary tools besides a docker</p> <p>Actually this command performs the following actions</p> <ol> <li>Pull a docker image</li> <li>Use current directory as a working directory inside of the image</li> <li>Run a toolbox in interactive shell</li> </ol>"},{"location":"hubctl/cli/hubctl-toolbox/#command-parameters","title":"Command Parameters","text":"Flag Description Default <code>-i --toolbox-image &lt;docker-image&gt;</code> Use docker image for a docker toolbox var: <code>HUB_TOOLBOX_IMAGE</code> or <code>ghcr.io/epam/hub-toolbox:base</code>"},{"location":"hubctl/cli/hubctl-toolbox/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-toolbox/#usage-example","title":"Usage Example","text":"<p>To start a toolbox container and run a deployment from inside</p> <pre><code>hubctl toolbox\n# wait a docker pull\n# see a docker shell instead\nhubctl stack deploy\nexit\n</code></pre>"},{"location":"hubctl/cli/hubctl-toolbox/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack</code></li> <li><code>hubctl show</code></li> </ul>"},{"location":"hubctl/components/","title":"Components","text":"<p>Component is a piece of software that can be deployed and undeployed that actually makes sense. Components could be anything - hubctl is not tied to any particular automation technology the only requirements are:</p> <ul> <li>Automation code that hubctl knows how to deploy. This can be as simple as shell script or more advanced such as ARM template or Terraform.</li> <li><code>hub-component.yaml</code> that describes component requirements, input and output parameters. Parameters can be passed to the automation code via environment variables or via templates.</li> </ul> <p>Optionally component could have:</p> <ul> <li><code>Template</code> - probably  way how to inject parameters from <code>hub-componet.yaml</code> to automation. Hubctl supports both string replacement and go-templates. </li> <li><code>pre-deploy</code> and <code>post-deploy</code> hooks - scripts that will be executed before and after component deployment.</li> </ul>"},{"location":"hubctl/components/#automation-code","title":"Automation Code","text":"<p>By design hubctl is not tied to any particular automation technology. However we have got prebuilt support for most popular automation tools</p>"},{"location":"hubctl/components/#shell-script","title":"Shell Script","text":"<p>Most flexible way and the most simple one. You only need to define a two scripts and pass parameters via environment variables.</p> <ul> <li><code>deploy.sh</code> - script that will be executed during component deployment</li> <li><code>undeploy.sh</code> - script that will reverse deployment. Every component should have undeploy script.</li> </ul> <p>Configuration can be passwd via environment variables defined in <code>hub-component.yaml</code> file. Hubctl will not pass any arguments to the scripts</p>"},{"location":"hubctl/components/#helm","title":"Helm","text":"<p>Helm is a package manager for Kubernetes. Hubctl will automatically detect Helm charts when component contains a <code>values.yaml</code> file.</p>"},{"location":"hubctl/components/arm/","title":"ARM Deployment Template","text":"<p>ARM templates are used to deploy resources to Azure. They are written in JSON and can be used to deploy a single resource or a set of resources. They can be used to deploy resources to a new resource group or to an existing resource group. They can be used to deploy resources to a new subscription or to an existing subscription.</p> <p>Hubctl can deploy ARM templates as a component. Hubctl will use the Azure CLI to deploy the ARM template.</p>"},{"location":"hubctl/components/arm/#arm-conventions","title":"ARM Conventions","text":"<p>To enable hubctl to recognize component as an ARM deployment component, User should add <code>arm</code> requirements to <code>hub-component.yaml</code> file:</p> <pre><code>requires:\n- azure\n- arm\n</code></pre>"},{"location":"hubctl/components/arm/#input-parameters","title":"Input parameters","text":"<p>There are number of well-known parameters that can be used to configure ARM deployment. These parameters are defined in <code>hub-component.yaml</code> file. Today there is no strict convention for parameter names. User is free to choose any parameter name they like, however these parameters should be bound to the specific environment variables.</p> Variable Description Required Passed from <code>.env</code> <code>ARM_TEMPLATE</code> Local file or URI to the ARM Deployment Template. If not set then hubctl will try to find deployment template by schema in component directory <code>ARM_DEPLOYMENT_NAME</code> Name associated to the ARM Deployment. If not set then name of the component will be used <code>ARM_PARAMETER_FILES</code> Space separated list to ARM Deployment Parameter files. If file cannot be found it will be ignored <code>ARM_PARAMETER_paramName</code> Hubctl will read all environment variables prefixed with <code>ARM_PARAMETERS_</code> to set ARM deployment parameters. In this example hubctl will set a parameter <code>parameterName</code> with the value of environment variable <code>ARN_PARAMETER_paramName</code> <code>ARM_PARAM_paramName</code> Same as <code>ARM_PARAMETER_paramName</code> <code>AZURE_RESOURCE_GROUP_NAME</code> Name of the target resource group. If not set then resource group defined during <code>hub stack configure -r \"azure\"</code> will be used <p>Note: <code>ARM_PARAMETER_</code> and <code>ARM_PARAM_</code> are aliases for the same parameter. User can use either one of them. These environment variables works similar to well known Terraform variables <code>TF_VAR_</code>.</p>"},{"location":"hubctl/components/arm/#deployment-hooks","title":"Deployment Hooks","text":"<ul> <li><code>pre-deploy</code> to trigger action before ARM Deployment template will be created</li> <li><code>post-deploy</code> to trigger action after ARM Deployment template will be created</li> <li><code>pre-undeploy</code> to trigger action before ARM Deployment template will be deleted</li> <li><code>post-undeploy</code> to trigger action before ARM Deployment template will be deleted</li> </ul> <p>Note: pre and post deployment scripts should have execution rights</p>"},{"location":"hubctl/components/arm/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> <li>Hub Component Terraform</li> </ul>"},{"location":"hubctl/components/helm/","title":"Helm Component","text":"<p>Helm is a popular packaging technology for Kubernetes applications. We do provide our own opinionated way how to deploy helm components.</p>"},{"location":"hubctl/components/helm/#component-conventions","title":"Component Conventions","text":"<p>If component follows the conventions below, then hubctl will know how to deploy  it.</p>"},{"location":"hubctl/components/helm/#helm-detection","title":"Helm Detection","text":"<p>When you want to use helm deployment add the following definition to the <code>hub-component.yaml</code></p> <pre><code>requires:\n- kubernetes\n- helm\n</code></pre> <p>and place one one of the following files in the component directory:  <code>values.yaml</code>, <code>values.yaml.template</code> or <code>values.yaml.gotemplate</code></p> <p>Then hubctl will be able detect this component as helm component and call provisioning script: helm-component-deploy .</p>"},{"location":"hubctl/components/helm/#input-parameters","title":"Input parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required <code>DOMAIN_NAME</code> FQDN of a stack. We use this parameter as a natural id of the deployment (defaults to implicit variable <code>HUB_DOMAIN_NAME</code>). Usage of this variables requires user to define a parameter <code>dns.domain</code> in <code>hub-component.yaml</code>. Yet we advice to use instead an implicit variable <code>HUB_DOMAIN_NAME</code> instead <code>COMPONENT_NAME</code> Corresponds to parameter <code>hub.componentName</code> parameter, however can be overriden in <code>hub-component.yaml</code>. Hub will use this variable as a helm release name x <code>NAMESPACE</code> Target kubernetes namespace x <code>HELM_CHART</code> This can have multiple values, that corresponds to the helm chart location. Corresponds to the helm chart tarball, directory or a chart name in the repository x <code>HELM_REPO</code> Instructs hubctl to download helm chart from the helm repository <code>HELM_CHART_VERSION</code> Addes a version constraint to the helm chart install. This variable works in conjunction with <code>HELM_REPO</code> <code>HELM_CHART_USERNAME</code> and <code>HELM_CHART_PASSWORD</code> Username and password for helm chart repository basic auth <code>CHART_VALUES_FILE</code> Instructs hubctl that it must use concrete values file inside of the helm chart as the base and only override with parameters from <code>values.yaml</code> in the component root directory. Alternatively if this variable has prefix <code>http</code> or <code>https</code> then the file. Additional values files can be referenced by adding a whitespace (or new line) separated reference <code>CRD</code> URL or local path to the CRD file (if not located in <code>&lt;component root&gt;/crds</code> directory) <code>HELM_OPTS</code> Helm command arguments, defautls to <code>--create-namespace --wait</code>"},{"location":"hubctl/components/helm/#environment-variable-helm_chart","title":"Environment variable: <code>HELM_CHART</code>","text":"<p>Helm chart which user wants to deploy can be resolved via variable <code>HELM_CHART</code>. This variable corresponds to the following value:</p> <ul> <li>Path to the local directory with the helm chart (relative to the <code>&lt;component root&gt;</code> or <code>&lt;component root&gt;/charts</code> directory)</li> <li>Path to the local directory with the helm chart (relative to the <code>&lt;component root&gt;</code> or <code>&lt;component root&gt;/charts</code> directory )</li> <li>Name of the helm chart in the helm repository (requires user to define: <code>HELM_REPO</code> and <code>HELM_CHART_VERSION</code>)</li> </ul>"},{"location":"hubctl/components/helm/#deployment-hooks","title":"Deployment hooks","text":"<p>User can define pre and post deployment</p> <ul> <li><code>pre-deploy</code> or <code>pre-deploy.sh</code> to trigger action before helm install</li> <li><code>post-deploy</code> or <code>post-deploy.sh</code> to trigter action after successful helm install</li> <li><code>pre-undeploy</code> or <code>pre-undeploy.sh</code> to trigger action before helm delete</li> <li><code>post-undeploy</code> or <code>post-undeploy.sh</code> to trigger action after helm successful delete</li> </ul> <p>Note: pre and post deployment scripts should have execution rights</p>"},{"location":"hubctl/components/helm/#custom-resources","title":"Custom Resources","text":"<p>We do advise not to deploy CRD with the helm chart. Because component <code>undeploy</code> (and <code>helm delete</code> correspondingly) will also delete CRDs. Deletion of CRD will also delete custom resources that may have been deployed by the user after this component has been deployed. Instead we advise to put your CRDs in to the  <code>&lt;component root&gt;/crds</code> directory. In this case, CRDs will be managed separately from the helm chart</p> <ol> <li>CRDs will be deploymed before the helm chart</li> <li>CRDs will not be deleted after component will be undeployed. Which means you can redeploy the component without dropping user custom resources</li> </ol>"},{"location":"hubctl/components/helm/#examples","title":"Examples","text":"<p>Nginx web server example. This is an example of a <code>hub-component.yaml</code> that will install a helm chart without any modifications. Complete code for nginx component can be found here</p> <pre><code>---\nversion: 1\nkind: component\n\nrequires:\n  - helm\n\nprovides:\n  - nginx\n  - ingress\n\nparameters:\n  - name: component.ingress\n    parameters:\n      - name: namespace\n        value: ingress\n        env: NAMESPACE\n      - name: class\n        value: nginx\n\n  - name: component.nginx\n    parameters:\n      - name: isDefaultIngress\n        value: false\n      - name: replicaCount\n        value: 1\n      - name: serviceType\n        value: LoadBalancer\n      - name: image\n        value: nginx/nginx-ingress\n      - name: imageTag\n        value: 2.2.2\n\n  - name: component.nginx.helm\n    parameters:\n      - name: chart\n        value: \"nginx-ingress\"\n        env: HELM_CHART\n      - name: repo\n        value: https://helm.nginx.com/stable\n        env: HELM_REPO\n      - name: version\n        value: 0.13.2\n        env: HELM_CHART_VERSION\n\ntemplates:\n  files:\n    - \"*.template\"\n</code></pre> <p>Note: helm chart parameters values must be defined in the <code>values.yaml</code>, <code>values.yaml.template</code> or <code>values.yaml.gotemplate</code> file</p>"},{"location":"hubctl/components/helm/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> <li>Kubernetes Configuration</li> </ul>"},{"location":"hubctl/components/kubernetes/","title":"Kubernetes Component","text":"<p>Kubenretes is a far popular technology to run containers. We do love Kubernetes and provide  first class support with the <code>hubctl</code>. So <code>hubctl</code> will manage access credentials and provide naming conventions for Kubernetes.</p>"},{"location":"hubctl/components/kubernetes/#when-component-requires-kubenretes","title":"When component requires kubenretes","text":"<p>Here we provide conventions required for component if it requires kubenretes. These conventions repeat conventions for helm extensions and kustomize extensions</p> <p>File <code>hub-component.yaml</code> of the component should require <code>kubernetes</code> and expose few of the parameters as the environment variabels</p> <pre><code>requires:\n- kubernetes\nparameters:\n- name: dns.domain\n  env: HUB_DOMAIN_NAME\n- name: kubernetes.namespace # this parameter name can be anything\n  value: kube-system         # this is example of kubenretes namespace\n  env: NAMESPACE\n</code></pre> <p>More about required parameters has been described below</p> <p>Note: kubeconfig should exist before, kubernetes cluster context should match to the <code>dns.domain</code> of your stack</p>"},{"location":"hubctl/components/kubernetes/#input-parameters","title":"Input parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required Passed from <code>.env</code> <code>HUB_DOMAIN_NAME</code> Hub naming convention requires <code>dns.domain</code> parameter to match to kubeconfig context that corresponds to the stack, fallbacks to legacy <code>DOMAIN_NAME</code> env var. If not defined in <code>hub-component.yaml</code> manifest will be derived from stack x <code>NAMESPACE</code> Target kubernetes namespace x <p>There are additional environment variables, depends on your cloud type</p>"},{"location":"hubctl/components/kubernetes/#kubeconfig-helper-script","title":"Kubeconfig helper script","text":"<p>Because components de-facto has been deployed by the shell scripts. So it is natural to provide helper functionality for Kubernetes in the form of script as well.</p> <p><code>bin/kubeconfig</code> is a script that helps with kubeconfig management. This sript has been available in the <code>PATH</code> of every component that has been deployed.</p> <ul> <li><code>kubeconfig cp</code> - writes to stdout (or file) the extracted copy of a one context and user credentials. It will rename to the value of (<code>HUB_STACK_DOMAIN</code>) to follow to the <code>hubctl</code> conventions for kubernetes.</li> <li><code>kubeconfig test</code> - will test connectivity to the kubernetes cluster</li> </ul>"},{"location":"hubctl/components/kubernetes/#when-component-provides-kubenretes","title":"When component provides kubenretes","text":"<p>This is useful when component actually deploys a new instance of the Kubenretes cluster. Then the component has been responsible to provide outputs of a kubenretes cluster in a standard form (standard output parameters and kubeconfig). So, this can be used by following components in the runlist that requires kubernetes. This is a bit of extra effort but it will also ensure that component that requires kubernetes (and possible written by someone else) will know how to get deployed into the Kubenretes cluster providen by your component</p> <p>There are various ways how Kubenretes cluster can be deployed. So, information in the <code>hub-component.yaml</code> file will be different</p>"},{"location":"hubctl/components/kubernetes/#example-for-gke","title":"Example for <code>GKE</code>","text":"<p>The minimalistic GKE cluster should provide following</p> <pre><code>provides:\n- kubernetes\noutputs:\n  - name: dns.domain\n  - name: kubernetes.gke.cluster\n  - name: kubernetes.api.endpoint\n</code></pre>"},{"location":"hubctl/components/kubernetes/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> <li>Component Helm</li> <li>Component Kustomize</li> </ul>"},{"location":"hubctl/components/kustomize/","title":"Kustomize Component","text":"<p>Kustomize is a popular packaging technology for Kubernetes applications. It relies on the series of patches. Hub can provide some additional templatng capabilities as well as some smarter resource creation capabilities</p>"},{"location":"hubctl/components/kustomize/#component-conventions","title":"Component Conventions","text":""},{"location":"hubctl/components/kustomize/#kustomize-detection","title":"Kustomize Detection","text":"<p>Because kustomize has been part of <code>kubectl -k ...</code> this compoenent doesn't require any specific configuration besides just a kubernetes. So hubfile should have</p> <pre><code>requires:\n- kubernetes\n</code></pre> <p>Kustomize component has been detected by hubctl if component has following files in it's root directory:  <code>kustomization.yaml</code>, <code>kustomization.yaml.template</code> or <code>kustomization.yaml.gotemplate</code></p> <p>Then hubctl will be able detect this component as helm component and call provisioning script: hub-component-kustomize</p>"},{"location":"hubctl/components/kustomize/#input-parameters","title":"Input parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required <code>DOMAIN_NAME</code> FQDN of a stack. We use this parameter as a natural id of the deployment (defaults to implicit variable <code>HUB_DOMAIN_NAME</code>). Usage of this variables requires user to define a parameter <code>dns.domain</code> in <code>hub-component.yaml</code>. Yet we advice to use instead an implicit variable <code>HUB_DOMAIN_NAME</code> instead <code>NAMESPACE</code> Target kubernetes namespace x <code>HUB_KUSTOMIZE_TARBALL_URL</code> Download kustomize base from the tarball. It will unpack tarball into <code>&lt;component root&gt;/kustomize</code> directory. Then you can refer resources or bases from this directory in your <code>kustomization.yaml</code> file <code>HUB_KUSTOMIZE_TARBALL_SUBPATH</code> Works in conjuction with <code>HUB_KUSTOMIZE_TARBALL_URL</code>, it instructs to unpack to the <code>&lt;component root&gt;/kustomize</code> a subpath inside the tarball <code>HUB_KUSTOMIZE_RESOURCES</code> Necessary when resources referenced in <code>kustomize.yaml</code> file must be downloaded before deployment. This variable contains whitespace separted list of URI or local file locations <code>CRD</code> URL or local path to the CRD file (if not located in <code>&lt;component root&gt;/crds</code> directory)"},{"location":"hubctl/components/kustomize/#deployment-hooks","title":"Deployment hooks","text":"<p>User can define pre and post deployment</p> <ul> <li><code>pre-deploy</code> to trigger action before helm install</li> <li><code>post-deploy</code> to trigter action after successful helm install</li> <li><code>pre-undeploy</code> to trigger action before helm delete</li> <li><code>post-undeploy</code> to trigger action after helm successful delete</li> </ul> <p>Note: pre and post deployment scripts should have execution rights</p>"},{"location":"hubctl/components/kustomize/#custom-resources","title":"Custom Resources","text":"<p>We do advise not to deploy CRD with the helm chart. Because component <code>undeploy</code> (and <code>helm delete</code> correspondingly) will also delete CRDs. Deletion of CRD will also delete custom resources that may have been deployed by the user after this component has been deployed. Instead we advise to put your CRDs in to the  <code>&lt;component root&gt;/crds</code> directory. In this case, CRDs will be managed separately from the helm chart</p> <ol> <li>CRDs will be deploymed before the helm chart</li> <li>CRDs will not be deleted after component will be undeployed. Which means you can redeploy the component without dropping user custom resources</li> </ol>"},{"location":"hubctl/components/kustomize/#examples","title":"Examples","text":"<p><code>//TODO</code></p>"},{"location":"hubctl/components/kustomize/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> <li>Kubernetes Configuration</li> </ul>"},{"location":"hubctl/components/makefile/","title":"Makefile Component","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/components/terraform/","title":"Terraform Component","text":""},{"location":"hubctl/components/terraform/#terraform","title":"Terraform","text":"<p>Terraform is a one of our favorite ways how to interact with IaaS services. Hubctl will automatically detect Terraform code when component contains one or more <code>*.tf</code> files.</p> <p>Parameters should be passed as Terraform variables in the form of:</p> <ul> <li><code>TF_VAR_</code> prefixed environment variables defined in <code>hub-component.yaml</code> file</li> <li>Template for <code>terraform.tfvars</code> file</li> </ul> <p>Deployment hooks can be defined via:</p> <ul> <li><code>pre-deploy.sh</code> and <code>post-deploy.sh</code> scripts</li> <li><code>pre-unploy.sh</code> and <code>post-unploy.sh</code> scripts</li> <li><code>import.sh</code> a special script that to import existing resources into Terraform state.</li> </ul> <p>Note: <code>import.sh</code> maybe a necessary step to allow manage non-idempotent resources such as AWS S3 bucket. Before running terraform deployment that will fail you may want to import bucket if it already exists.</p>"},{"location":"hubctl/components/terraform2/","title":"Terraform Component","text":"<p>Terraform is a popular infrastruture as code technology often used to deploy cloud resources. We do provide our own opinionated way how to deploy Terraform. In this case you can follow simple conventions and you don't require to write a deployment scripts</p>"},{"location":"hubctl/components/terraform2/#component-conventions","title":"Component Conventions","text":"<p>If component follows the conventions below, then hubctl will know how to deploy  it.</p> <p>Minimalistic terraform component will look like this:</p> <p>Hubctl will automatically detect Terraform code when component contains one or more <code>*.tf</code> files.</p> <pre><code>./\n\u251c\u2500\u2500 hub-component.yaml  # component manifest\n\u2514\u2500\u2500 main.tf             # terraform code\n</code></pre>"},{"location":"hubctl/components/terraform2/#configuration","title":"Configuration","text":"<p>Terraform variables can be supplied in two ways:</p> <ol> <li>Terraform variables can be defined by component parameter and exported as <code>TF_VAR_*</code> environment variable (recommended way)</li> <li>Terraform variables can be defined in <code>*.tfvars</code> or <code>*.tfvars.template</code> file</li> </ol>"},{"location":"hubctl/components/terraform2/#parameters","title":"Parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required Passed from <code>.env</code> <code>COMPONENT_NAME</code> Corresponds to parameter <code>hub.componentName</code> parameter, however can be overriden in <code>hub-component.yaml</code>. Hub will use this variable as a helm release name x <code>HUB_DOMAIN_NAME</code> FQDN of a stack. We use this parameter as a natural id of the deployment x x <code>HUB_CLOUD_PROVIDER</code> Tells hubctl to use different backends for terraform. We currently support: <code>aws</code>, <code>azure</code> or <code>gcp</code> x x <code>HUB_STATE_BUCKET</code> Object storage bucket to be be used for terraform state x x <code>HUB_STATE_REGION</code> Region for terraform state bucket x x <p>There are additional environment variables, depends on your cloud type</p>"},{"location":"hubctl/components/terraform2/#aws-specific-variables","title":"AWS specific variables","text":"<p>These variables has been set during <code>hubctl stack configure</code> state and defined in <code>.env</code> file. You don't have to refer it for your component, however you can overwrite.</p> Variable Description Required <code>AWS_PROFILE</code> AWS name of the profile. Referenced from <code>.env</code> file. However you can override it in <code>hub-component.yaml</code> file x"},{"location":"hubctl/components/terraform2/#azure-specific-variables","title":"Azure specific variables","text":"<p>These variables has been set during <code>hubctl stack configure</code> state and defined in <code>.env</code> file. These are the minimum viable variables expected by our terraform deploymenet script</p> Variable Description Required <code>ARM_CLIENT_ID</code> The client(application) ID of an App Registration in the tenant <code>ARM_CLIENT_SECRET</code> A client secret that was generated for the App Registration <code>ARM_SUBSCRIPTION_ID</code> Access an Azure subscription value from within a Terraform script <code>ARM_TENANT_ID</code> ARM Tenant id <p>Full list of environment variables for azure can be found here: https://www.terraform.io/docs/language/settings/backends/azurerm.html</p>"},{"location":"hubctl/components/terraform2/#gcp-specific-variables","title":"GCP specific variables","text":"Variable Description Required <code>GOOGLE_APPLICATION_CREDENTIALS</code> Default applicaiton credentials (ADC) see details here <code>GOOGLE_PROJECT</code> For to refer google project ID. See details here <p>Full reference of supported variables available here: https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/provider_reference#full-reference</p>"},{"location":"hubctl/components/terraform2/#deployment-hooks","title":"Deployment hooks","text":"<p>User can define pre and post deployment</p> <ul> <li><code>pre-deploy</code> to trigger action before helm install</li> <li><code>post-deploy</code> to trigter action after successful helm install</li> <li><code>pre-undeploy</code> to trigger action before helm delete</li> <li><code>post-undeploy</code> to trigger action after helm successful delete</li> <li><code>import</code> a special script that to import existing resources into Terraform state.</li> </ul> <p>Note: <code>import</code> maybe a necessary step to allow manage non-idempotent resources such as AWS S3 bucket. Before running terraform deployment that will fail you may want to import bucket if it already exists.</p> <p>Note: deployment hooks should have execution rights </p>"},{"location":"hubctl/components/terraform2/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> </ul>"},{"location":"stacks/","title":"Stacks Overview","text":"<p>This page will contain overview of available stacks</p>"},{"location":"tutorials/","title":"Getting Started","text":"<p>Got hubctl installed? Great! Now let's get started with a quick tutorial.</p>"},{"location":"tutorials/020-shell-component/","title":"DIY Component","text":"<p>This tutorial will show you how to create a component from scratch. We will start with a minimalistic component and then we will add more features to it.</p> <p>Component is the minimal deployment unit that hubctl can manage. Good component should have few properties:</p> <ul> <li>Idenmpotent - component with the same parameters can be deployed with the same result multiple times. If component has been deployed, then it can be deployed again without any side effects.</li> <li>Generic - good component reusable this means generic enough. <code>hub-component.yaml</code> provides such abstraction. Then specific configuration will be defined via <code>hub.yaml</code> or <code>parameters.yaml</code> file on the stack level.</li> </ul> <p>Stack consists of one or multiple components. Good stack defines</p> <ul> <li>Components definition and deployment order</li> <li>Parameters that are passed to the components from environment</li> <li>Parameters that are passed between components</li> <li>Optional deployment hooks that can be used to execute custom logic before or after deployment of the component or a stack</li> </ul>"},{"location":"tutorials/020-shell-component/#component-structure","title":"Component structure","text":"<p>Each component knows how to deploy itself and export facts about deployment configuration in the well-known form of parameters. So other component would use this as an input.</p> <p>Hub component contains the following:</p> <ol> <li><code>hub-component.yaml</code> - file with input and output parameters</li> <li><code>deploy</code> and <code>undeploy</code> provisioning scripts. This however optional if component is using well known deployment tool such as <code>terraform</code>, <code>helm</code> or <code>kustomize</code>.</li> </ol> <p>In the nutshell - parameters defined in <code>hub-component.yaml</code> abstracts user from concrete provisioning technology and allows maintainer of the component improve or even change provisioning technology without breaking compatibility with the other components.</p>"},{"location":"tutorials/020-shell-component/#deploy-a-minimalistic-component","title":"Deploy a minimalistic component","text":"<ol> <li>Create a new directory <code>components/hello-shell</code></li> <li>Create a file <code>components/hello-shell/hub-component.yaml</code> and add minimalistic content</li> </ol> <pre><code>kind: component\nversion: 1\nparameters:\n- name: hub.componentName\n  env: COMPONENT_NAME\n</code></pre> <ol> <li>Create a <code>deploy.sh</code> file and add execution rights to it. Here is an example</li> </ol> <pre><code>cat &lt;&lt; EOF &gt; `components/hello-shell/deploy.sh`\n#!/bin/sh\necho \"Component $COMPONENT_NAME deployed successfully!\"\nEOF\nchmod +x `components/hello-shell/deploy.sh`\n</code></pre> <ol> <li>Create deployment reverse script: <code>undeploy.sh</code></li> </ol> <pre><code>cat &lt;&lt; EOF &gt; `components/hello-shell/undeploy.sh`\n#!/bin/sh\necho \"Component: $COMPONENT_NAME has been successfully undeployed\"\nEOF\nchmod +x `components/hello-shell/undeploy.sh`\n</code></pre> <ol> <li>Add a component reference to Hubfile (<code>hub.yaml</code>)</li> </ol> <pre><code>kind: stack\nversion: 1\ncomponents:\n- name: hello-shell\n  source:\n    dir: components/hello-shell\n</code></pre> <ol> <li>And we are ready to deploy</li> </ol> <pre><code>hubctl stack init -f `hub.yaml`\nhubctl stack deploy\n</code></pre>"},{"location":"tutorials/020-shell-component/#add-a-parameter","title":"Add a parameter","text":"<ol> <li>Add new parameter to the <code>components/hello-shell/hub-component.yaml</code></li> </ol> <pre><code>kind: component\nversion: 1\nparameters:\n- name: hub.componentName\n  env: COMPONENT_NAME\n- name: message\n  value: foo\n  env: MESSAGE\n</code></pre> <ol> <li>Modify <code>components/hello-shell/deploy.sh</code> script. You should get something like</li> </ol> <pre><code>#!/bin/sh\necho \"Component $COMPONENT_NAME is saying: $MESSAGE\"\necho \"Component $COMPONENT_NAME deployed successfully!\"\n</code></pre> <ol> <li>Add parameters to the hubfile (<code>hub.yaml</code>) to include parameter</li> </ol> <pre><code>kind: stack\nversion: 1\nmeta:\n  name: My first deployment\ncomponents:\n- name: my-first-component\n  source:\n    dir: components/hello-shell\nparameters:\n- name: message\n  value: bar\n</code></pre> <ol> <li>Run a deployment</li> </ol> <pre><code>hubctl stack deploy\n#\n# Component my-first-component is saying: bar\n# Component my-first-component deployed successfully!\n</code></pre>"},{"location":"tutorials/020-shell-component/#add-a-second-component-and-override-the-parameter","title":"Add a second component and override the parameter","text":"<p>Modify a hubfile so it would look as the following:</p> <pre><code>kind: stack\nversion: 1\nmeta:\n  name: My first deployment\ncomponents:\n- name: my-first-component\n  source:\n    dir: components/hello-shell\n- name: my-second-component\n  source:\n    dir: components/hello-shell\nparameters:\n- name: message\n  value: bar\n- name: message\n  component: my-second-component\n  value: baz\n</code></pre> <ol> <li>Run deployment</li> </ol> <pre><code>hubctl stack deploy\n# Component my-first-component is saying: bar\n# Component my-first-component deployed successfully!\n# Component my-second-component is saying: baz\n# Component my-second-component deployed successfully!\n</code></pre>"},{"location":"tutorials/020-shell-component/#add-a-template-to-the-component","title":"Add a template to the component","text":"<ol> <li>Add a file that would look like the following</li> </ol> <pre><code>cat &lt;&lt; EOF &gt; `components/hello-shell/message.txt.template`\nThe cryptic message says: ${message}\nEOF\n</code></pre> <ol> <li>Update <code>components/hello-shell/hub-component.yaml</code> so it would look like:</li> </ol> <pre><code>kind: component\nversion: 1\nparameters:\n- name: hub.componentName\n  env: COMPONENT_NAME\n- name: message\n  value: foo\n  env: MESSAGE\ntemplates:\n  files:\n  - \"*.template\"\n</code></pre> <ol> <li>Modify <code>components/hello-shell/deploy.sh</code> so it would look like the following</li> </ol> <pre><code>#!/bin/sh\necho \"Component $COMPONENT_NAME is saying: $MESSAGE\"\n# here we interact with template file... it has been already rendered\ncat \"message.txt\"\n\necho \"Component $COMPONENT_NAME deployed successfully!\"\n</code></pre> <ol> <li>Deploy the stack</li> </ol> <pre><code>hubctl stack deploy\n# Component my-first-component is saying: bar\n# The cryptic message says: bar\n# Component my-first-component deployed successfully!\n# Component my-second-component is saying: baz\n# The cryptic message says: baz\n# Component my-second-component deployed successfully!\n</code></pre>"},{"location":"tutorials/020-shell-component/#technology-specific-components","title":"Technology specific components","text":"<p>This article is not a reference guide, we do skip many things... Now we will jump into the more advanced topics. Until then we were writing a sudo component using a free form. Now we will use arguably oppinionated deployment steps however, you don't required to write your own deployment script</p> <p>At present we support following technologies</p> <ul> <li>Component Helm</li> <li>Component Kustomize</li> <li>Component Terraform</li> <li>Component ARM Deployment Template</li> </ul>"}]}