{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hubctl","text":"<p>Hubctl helps to manage your infrastructure as code by allowing to split your infrastructure into reusable components.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Built in support for all popular infrastructure automation tools (such as Terraform, Kustomize, Helm, ARM etc)</li> <li>Supports multiple cloud providers (AWS, Azure, GCP, Kubernetes)</li> <li>Manages, deployments, backups, parameters</li> <li>Extensible with plugins and automation hooks</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install hubctl follow the instructions on the installation page.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>To get started with hubctl, follow the quickstart guide.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Hubctl overview</li> <li>Components</li> <li>Stacks</li> <li>Extensions</li> <li>Toolbox</li> <li>Hooks</li> </ul>"},{"location":"install/","title":"Install","text":"<p>This page will show how to install hubctl on your local workstation</p> <p>There are few ways to install hubctl:</p> <ol> <li>Download binary</li> <li>Homebrew Formula</li> </ol>"},{"location":"install/#download-binary","title":"Download binary","text":"<p>To download the latest of hubctl run the following</p>"},{"location":"install/#curl","title":"cURL","text":"<pre><code>curl -LJ \"https://github.com/epam/hubctl/releases/latest/download/hubctl_$(uname -s)_$(uname -m).tar.gz\" \\|\n  tar xz -C /tmp &amp;&amp; sudo mv /tmp/hubctl /usr/local/bin\n</code></pre>"},{"location":"install/#wget","title":"Wget","text":"<pre><code>wget \"https://github.com/epam/hubctl/releases/latest/download/hubctl_$(uname -s)_$(uname -m).tar.gz\" -O - |\\\n  tar xz -C /tmp &amp;&amp; sudo mv /tmp/hubctl /usr/local/bin\n</code></pre>"},{"location":"install/#homebrew-formula","title":"Homebrew Formula","text":"<pre><code>brew tap epam/tap\nbrew install epam/tap/hubctl\n</code></pre>"},{"location":"install/#extensions","title":"Extensions","text":"<p>Extensions are the plugins for hubctl. It provides additional functionality to hubctl. To install extensions run:</p> <pre><code>hubctl extensions install\n</code></pre> <p>There are few common tools used across all extensions. Other tools are component specific</p> <ul> <li>bash</li> <li>curl</li> <li>jq</li> <li>yq v4</li> </ul>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>Some components and extensions requires additional tools to be installed:</p> <ul> <li>AWS CLI - for components that requires <code>aws</code></li> <li>Azure CLI - for component that requires <code>azure</code></li> <li>Gcloud SDK - for component that requires <code>gcp</code></li> <li>kubectl - for components that requires <code>kubernetes</code></li> <li>Terraform - for components that requires <code>terraform</code></li> <li>Helm - for components that requires <code>helm</code></li> <li>Kustomize*</li> <li>Node.js - to activate <code>hubctl pull</code> extension</li> <li>[Docker CLI] - to active <code>hubctl toolbox</code> extension</li> </ul> <p>Special note for Kustomize: by default kustomize has been shipped together with kubectl (<code>kubectl -k ...</code>) However if user has a kustomize installed. Hubctl will use it instead.</p>"},{"location":"install/#whats-next","title":"What's Next","text":"<ul> <li>See our Getting Started guide</li> </ul>"},{"location":"use-cases/","title":"When do you need hubctl?","text":"<p>When we created a Hubctl we had an idea to promote the best practices for infrastructure as code. We wanted to create a tool that would help us to manage our infrastructure as code in a consistent and repeatable way.</p>"},{"location":"use-cases/#package-manager-for-the-cloud","title":"Package manager for the Cloud","text":"<p>Operating Systems have got a package managers for ages now like <code>homebrew</code> for Mac and <code>choco</code> for Windows. It is able to download and install packages, resolve dependencies etc. But there is no such package manager for the cloud deployments.</p> <p>Today we organize our infrastructure as code in the form of Terraform, Kustomize, Helm, ARM etc. Each of these tools solves solves a specific problem. When you find yourself in the situation when you need to multiple tools for your deployment, you end up with a lot of boilerplate code. Hubctl solves this problem by these integrations and provides a single interface to manage your infrastructure.</p>"},{"location":"use-cases/#break-up-monolithic-deployments","title":"Break-up monolithic deployments","text":"<p>We have seen when application deployment code was 60% of entire codebase. This makes deployment code a biggest component of your entire application. Similar to applications today split into microservices, we can also split our infrastructure into multiple components. This makes it easier to manage and maintain.</p> <p>Hubctl provides mechanisms to manage your deployment as a stack of components. Each component can be deployed and managed independently and can use it's own deployment tool.</p>"},{"location":"use-cases/#disposable-infrastructure","title":"Disposable Infrastructure","text":"<p>Hubctl provides you with a single place where you can deploy multiple environments for your application and dispose it when you don't need it.</p>"},{"location":"hubctl/","title":"Overview","text":"<p>Hubctl is stack composition and lifecycle tool:</p> <ul> <li>template and stack creation, stack deploy / undeploy / backup lifecycle;</li> <li>stack and component parameters, output variables, and state;</li> </ul>"},{"location":"hubctl/#components","title":"Components","text":"<p>Hubctl core experience is about connecting various pieces of software - called components into a stack, each component developed independently yet designed to work together, via common set of parameters for inputs and outputs. See more about components here</p>"},{"location":"hubctl/#stacks","title":"Stacks","text":"<p>In real life we rarely deploy just a single component. We usually need to take several components and stack them together into a coherent deployment unit that actually makes sense to deploy</p> <p>To deploy a stack hubctl needs a <code>hub.yaml</code> file that lists the components and parameters that are needed to deploy the stack.</p>"},{"location":"hubctl/cli/","title":"Command <code>hubctl</code>","text":"<p>By default hubctl is a CLI tool that provides a set of commands to manage stacks and deployments</p> Command Description <code>hubctl stack</code> Commands to manage your deployment <code>hubctl show</code> Show parameters of a deployed stack <code>hubctl toolbox</code> Starts a local toolbox container and mounts current file system inside"},{"location":"hubctl/cli/#common-flags","title":"Common Flags","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-show/","title":"Command: <code>hubctl show</code>","text":"<p>Helps to browse parameters for deployment</p>"},{"location":"hubctl/cli/hubctl-show/#parameters","title":"Parameters","text":"Flag Description Required <code>-q  -jq --query</code> Apply a <code>jq</code> style filter query to the command results <code>-o --split</code> By default, input and output parameters of a stack has been merged. If you want to split them into two different group to view specifically input or output parameters, then use this flag <code>-m --machine</code> By default parameters exported in a flat manner as a Key-Value pair. Yet you may want instead to present parameters as a <code>.</code> (dot) delimited objects. This can significantly simplify scripting when you want to wire deployment outputs with your specific automation <code>-c --component</code> Show input and ouptut parameters of a specific component in the stack. <code>--</code> For advanced case: when you want to supply some <code>jq</code> native arguments to the <code>hubctl show</code> command. Check out <code>jq --help</code> for allowed values"},{"location":"hubctl/cli/hubctl-show/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-show/#usage-example","title":"Usage Example","text":"<p>To show all parameters of a stac</p> <pre><code>hubctl show\n</code></pre> <p>To show domain name of a stack</p> <pre><code>hubctl show -q '.parameters.dns.domain'\n</code></pre> <p>To show password of a <code>mysql</code> component in the stack</p> <pre><code>hubctl show -c 'mysql' -q '.outputs.component.mysql.password'\n</code></pre>"},{"location":"hubctl/cli/hubctl-show/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack</code></li> <li><code>hubctl toolbox</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-backup/","title":"Command: <code>hubctl stack invoke</code>","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/cli/hubctl-stack-configure/","title":"Command: <code>hubctl stack configure</code>","text":"<p>Reads configuration information in one or multiple hubfiles referenced by the command <code>hubctl stack init</code> and applies configuration before the stack deployment.</p> <p>When hubfile will require parameter supplied bia environment variable (<code>fromEnv</code>) ,for instance passwords or access credentials, then this command will save value for this variable in <code>.env</code> file. You can change this value later by modifying <code>.env</code> file.</p> <p>Upon completion of configure command execution will ensure that all stack input parameters has been defined.</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#configuration-requirements","title":"Configuration requirements","text":"<p>Input parameters can be supplied by various scripts. Which exactly and it's order has been defined in hubfile via requirements</p> <pre><code>extensions:\n  configure:\n  - env\n  - gcp\n</code></pre> <p>List of supported requirements for configuration</p> Requirement Description <code>gcp</code> Configures stack for deployment to GCP. Will bootstrap a DNS zone (optionally relying to bubble dns service) and a GCS bucket to store state <code>aws</code> Configures stack for deployment to AWS. Will bootstrap a Route53 zone (optionally relying to bubble dns service) and a S3 bucket to store state. This will make sure that credentials has been reachable for the deployment <code>azure</code> Similar to <code>aws</code> and <code>gcp</code> will configure stack for Microsoft Azure Cloud deployment <code>env</code> Ensures that all environment variables (<code>fromEnv</code>) has been defined by the user <code>kubernetes</code> Reserved when user already have got a running Kubernetes cluster. This requirement may conflict if stack will actually deploy a new cluster. This requirement will ensure that kubernetes credentials stored in kubeconfig has been reachable by the kubeconfig by creating py of just one kube-context in <code>.hub/env</code> directory <code>components</code> DEPRECATED. Functionality of this requirement has been moved to  <code>hubctl stack init</code> command <code>backup</code> Activate backup/restore functionality for the stack (note that at least one component should accept verb <code>backup</code>)"},{"location":"hubctl/cli/hubctl-stack-configure/#command-parameters","title":"Command Parameters","text":"<p>These parameters applies across all extension commands. If hubfile contains additional requirements then there may be additional command parameters</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#common-parameters","title":"Common parameters","text":"Flag Description Required <code>-r --requirement &lt;arg&gt;</code> Specific one or multiple (this parameter can repeat) requirements to apply for reconfiguration. If no requirements provided, then this means all requirements as specified in hubfile <code>--profile &lt;arg&gt;</code> Set specific deployment profile <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-configure/#google-cloud-platform","title":"Google Cloud Platform","text":"<p>Flags specific to <code>gcp</code> parameters</p> Flag Description Required <code>--gcp-project-id  &lt;arg&gt;</code> Override project id in <code>.env</code> file <code>--gcs-bucket-name  &lt;arg&gt;</code> Override GCS bucket name (defaults to: <code>gs://&lt;project_id&gt;-superhub</code>) <code>--domain-name &lt;arg&gt;</code> Instructs to use a specific domain name (otherwise will be autogenerated by bubble DNS service)"},{"location":"hubctl/cli/hubctl-stack-configure/#amazon-web-services","title":"Amazon Web Services","text":"<p>Flags specific to <code>aws</code> parameters</p> Flag Description Required <code>--aws-region &lt;arg&gt;</code> Use specific AWS region (otherwise default from AWS profile will be used) <code>--aws-profile &lt;arg&gt;</code> Use specific AWS profile (otherwise current or default profile will be used) <code>--aws-profile &lt;arg&gt;</code> Use specific AWS profile (otherwise current or default profile will be used) <code>--domain-name &lt;arg&gt;</code> Instructs to use a specific domain name (otherwise will be autogenerated by bubble DNS service) <code>--base-domain-aws-profile &lt;arg&gt;</code> To address case when parent hosted zone managed in different AWS account <code>--prefer-local</code> Instructs not to use hubctl state in S3 bucket <code>--dns-update</code> Instructs bubble DNS service to update TTL on existing DNS record (instead of requesting new random record) <code>--bubbles-secret-key &lt;arg&gt;</code> User provides bubble dns secret that will proof his ownership on stack. Otherwise value from .env file will be used"},{"location":"hubctl/cli/hubctl-stack-configure/#microsoft-azure-cloud","title":"Microsoft Azure Cloud","text":"<p>Flags specific to <code>azure</code> parameters</p> Flag Description Required <code>--azure-region &lt;arg&gt;</code> Use specific Azure region (otherwise default from AWS profile will be used) <code>--azure-resource-group &lt;arg&gt;</code> Azure Resource Group (defaults to value from: <code>AZURE_RESOURCE_GROUP_NAME</code>, <code>AZURE_DEFAULTS_GROUP</code> environment variables) <code>--azure-subscription &lt;arg&gt;</code> Azure Resource Group (defaults to value from: <code>AZURE_SUBSCRIPTION_ID</code>) <code>--base-domain-resource-group &lt;arg&gt;</code> and <code>--base-domain-subscription &lt;arg&gt;</code> To address case when parent hosted zone managed in different AWS account <code>--prefer-local</code> Instructs not to use hubctl state in S3 bucket <code>--dns-update</code> Instructs bubble DNS service to update TTL on existing DNS record (instead of requesting new random record) <code>--bubbles-secret-key &lt;arg&gt;</code> User provides bubble dns secret that will proof his ownership on stack. Otherwise value from .env file will be used"},{"location":"hubctl/cli/hubctl-stack-configure/#environment-variables","title":"Environment Variables","text":"<p>Flags specific to <code>env</code> parameters</p> Flag Description Required <code>-f --file &lt;arg&gt;</code> Ask for variables from only specific hubfiles (defaults to <code>HUB_FILES</code> variable in <code>.env</code> file,  can repeat multiple time) <code>--defaults</code> Instructs not to confirm user input for environment variables (reserved for non-interactive usage, such as CI server)"},{"location":"hubctl/cli/hubctl-stack-configure/#kubernetes","title":"Kubernetes","text":"<p>Flags specific to <code>kubernetes</code> parameters</p> Flag Description Required <code>--kubeconfig &lt;arg&gt;</code> Path to kubeconfig. Otherwise <code>KUBECONFIG</code> environment variable will be used. <code>--kubecontext &lt;arg&gt;</code> Use specific context inside kubeconfig. Otherwise current will be used <code>--current-kubecontext</code> or <code>--kubecontext _</code> Explicitly says to use current kube-context <p>Note: If you want to run configure from the pod (inside kubernetes). This extension configure stack to rely on service account of the pod</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#components-deprecated","title":"Components (deprecated)","text":"<p>Please use new command: <code>hubctl stack init</code> instead</p> Flag Description Required <code>-f --file &lt;arg&gt;</code> Instructs to use specific hubfiles (defaults to <code>HUB_FILES</code> variable in <code>.env</code> file,  can repeat multiple time) <code>-c --component &lt;arg&gt;</code> Ask to download a specific component only (can repeat multiple times, defaults to all components defined in hubfiles) <code>--override</code> Write over files if component already exists <p>Note: If you want to run configure from the pod (inside kubernetes). This extension configure stack to rely on service account of the pod</p>"},{"location":"hubctl/cli/hubctl-stack-configure/#dyi-configuration","title":"DYI Configuration","text":"<p>Can I build my own configuration script for my custom case? Or override behavior of existing one? Yes just follow couple of simple steps</p> <ol> <li>Create file: <code>&lt;working-dir&gt;/.hub/&lt;requirement&gt;/configure</code> and add execution rights</li> <li>Write your script using: <code>shell</code> (preferably), <code>bash</code> or general purpose language of your choice.</li> <li>Add reference to the hub.yaml</li> </ol> <pre><code># example\nmkdir -p \".hub/mysuperextension\"\ntouch \".hub/mysuperextension/configure\"\nchmod +x \".hub/mysuperextension/configure\"\n</code></pre> <p>then feel free to add reference that looks like the following to the <code>hub.yaml</code></p> <pre><code>extensions:\n  configure:\n  - mysuperextension\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-configure/#usage-example","title":"Usage Example","text":"<p>Configure stack before deployment</p> <pre><code>hubctl stack configure\n</code></pre> <p>Reload GCP configuration, and refresh TTL for bubble DNS service</p> <pre><code>hubctl stack configure -r \"gcp\"\n</code></pre> <p>Configure refresh kubeconfig for kubernetes cluster (if access rotated)</p> <pre><code>hubctl stack configure -r \"kubernetes\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-configure/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack init</code></li> <li><code>hubctl stack deploy</code></li> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-deploy/","title":"Command: <code>hubctl stack deploy</code>","text":"<p>Runs deployment for entire stack or updates deployment of one or few components</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#command-parameters","title":"Command Parameters","text":"Flag Description Required <code>-c --component &lt;component&gt;</code> Run deployment for one  component or multiple (supplied as comma separated value) <code>-o --offset &lt;component&gt;</code> Start deployment from specific component (handy when you want to restart deployment, and want to skip few from the beginning in the runlist) <code>-l --limit &lt;component&gt;</code> Stop deployment after desired (opposite to <code>--offset</code> flag) <code>--profile</code> Choose a specific deployment provider (defaults to <code>HUB_PROFILE</code> in <code>.env</code> file) <code>--tty</code> or <code>--no-tty</code> Instructs if user wants to group deployment outputs per component"},{"location":"hubctl/cli/hubctl-stack-deploy/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-deploy/#advanced-usage","title":"Advanced usage","text":""},{"location":"hubctl/cli/hubctl-stack-deploy/#hooks-for-before-deployment-and-after-deployment","title":"Hooks for before-deployment and after-deployment","text":"<p>It is possible if user will decide to add one or more deployment hooks. This hooks will be executed before or after the deployment has been done.</p> <p>These deployment hooks has been defined via hubfile</p> <pre><code>extensions:\n  deploy:\n    before:\n    - &lt;extension&gt;\n    after:\n    - &lt;extension&gt;\n</code></pre> <p>example:</p> <pre><code>extensions:\n  deploy:\n    before:\n    - kubernetes\n    after:\n    - inventory-configmap\n</code></pre> <p>Example above will run a kubernetes extension before the deployment to check connectivity to the desired cluster. It will also instruct a <code>hub</code> to save deployment state inside of the kubenretes cluster as a <code>configmap</code>. This is viable alternative to the object storage and can be handy to store copy of a state for on-prem deployments.</p> <p>At the moment there are few extensions that supports before deployment or after deployemnt</p> Extension Description Before After <code>kubernetes</code> Checks connectivity to existing kubernetes cluster before actual deployment (helps with deployment success rate) x x <code>aws-metering</code> Provides integration to aws marketplace metering x <code>inventory-configmap</code> Save a copy of a deployment state in the configmap of a kubernetes cluster. Adds some extra persistence for on-prem deployments as they might not have object storage bucket access to store state there x"},{"location":"hubctl/cli/hubctl-stack-deploy/#define-run-list","title":"Define run-list","text":"<p>By default run-list has been derived from the components definition following the algorithm:</p> <ol> <li>Component listed as dependency should run before the component that depends on it</li> <li>Component without dependency should run in the order of declaration</li> </ol> <p>However user can overwrite order by defining a custom run-list in the <code>hub.yaml</code> file</p> <p>Component run-list order has been defined in hubfile. It looks like below.  Then the User will maintain run-list order when they add or remove the component</p> <pre><code>lifecycle:\n  order:\n  - component1\n  - component2\n  # ...\n  - componentN\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-deploy/#dyi-deployment-hook","title":"DYI deployment hook","text":"<p>Q: Can I add my own deployment hook? A: Yes, easy!</p> <ol> <li>Create a file in the <code>.hub/&lt;extension&gt;/before-deploy</code> and add execution rights</li> <li>Implement hook using shell (preferably), bash, or language of your choice</li> </ol> <p>Q: Which shell hooks I can build? A: Make sure you follow the naming convention for file name</p> Script Description <code>before-deploy</code> Executed before deployment operation, fail with error code non 0 to stop deployment from happening <code>after-deploy</code> Executed before deployment operation, fail with error code non 0 to mark deployment as failed. Useful when you apply some deployment tests <code>before-undeploy</code> Executed before un-deployment operation, fail with error code non 0 to stop un-deployment from happening <code>after-undeploy</code> Executed before un-deployment operation, fail with error code non 0. Useful if you want to check that all resources has been deleted and grab user attention on some cloud junk"},{"location":"hubctl/cli/hubctl-stack-deploy/#executors","title":"Executors","text":"<p>There are few ways how to run a deployment, It primarilly depends on if this is a desire of the user where they want to have all desired provisioning tools setup and keep updated periodically. User also might  want to run deployment from CI server etc. This is why we have got different deployment profiles</p> <p>Executor has been configured in <code>.env</code> file via environment variable <code>HUB_DEPLOY_PROFILE</code>. This variable has been set during the <code>configure</code> time, but can be changed by editing <code>.env</code> file</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#executor-local","title":"Executor: <code>local</code>","text":"<p>This profile has been preferable when user wants to run all automation from their local workstation. User also have got all provisioning tools required by the stack (such as <code>terraform</code>, <code>helm</code> or <code>kustomize</code>) installed locally. This profile gives fastest feedback if something goes wrong and direct tools to troubleshoot</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#executor-toolbox","title":"Executor: <code>toolbox</code>","text":"<p>If you have a docker locally then you may not want to install all provisioning tools. Instead <code>toolbox</code> profile will run a special Docker container with all tools installed and then mount your working diretory inside. This deployment profile is handy to work in a team and  address works on my workstation issues as every team member will work with exactly the same toolchain that comes with toolbox container</p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#executor-pod","title":"Executor: <code>pod</code>","text":"<p>This is evolution of a toolbox profile. Instead, if you have a Kubernetes cluster at your disposal, you may want to run an automation task as a Kubernetes native pod. This pod will do the following</p> <ol> <li>Run a <code>toolbox</code> container in a Kubernetes namespace <code>automation-tasks</code></li> <li>Copy a working directory inside of a <code>pod</code></li> <li>Copy credentials such as <code>aws</code> or <code>kubernetes</code></li> <li>Run automation task</li> <li>Collect the result and store locally state</li> <li>Shut down the container</li> </ol>"},{"location":"hubctl/cli/hubctl-stack-deploy/#diy-executor","title":"DIY executor","text":"<p>If you want to build your own deployment profile, then put a script into the <code>.hub/profiles/&lt;profile-name&gt;</code> directory and add execution rights. Then update environment variable <code>HUB_DEPLOY_PROFILE</code> in the <code>.env</code></p>"},{"location":"hubctl/cli/hubctl-stack-deploy/#usage-example","title":"Usage Example","text":"<p>To deploy all components in the run-list:</p> <pre><code>hubctl stack deploy\n</code></pre> <p>To deploy specific components with order defined in the runlist</p> <pre><code>hubctl stack deploy -c \"external-dns,cert-manager\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-deploy/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack undeploy</code></li> <li><code>hubctl stack configure</code></li> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-elaborate/","title":"Command: <code>hubctl stack elaborate</code>","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/cli/hubctl-stack-init/","title":"Command: <code>hubctl stack init</code>","text":"<p>Initialize a new stack configuration in the user working directory</p>"},{"location":"hubctl/cli/hubctl-stack-init/#command-parameters","title":"Command Parameters","text":"Flag Description Required <code>-f --file &lt;hubfile&gt;</code> path (or URL) to hubfile with stack definitions. This argument can repeat multile times x <code>-s --state &lt;statefile&gt;</code> Path or URL to <code>--force</code> Specify this fag if current stack has been already initialized. This flag will overwrite existing configuration"},{"location":"hubctl/cli/hubctl-stack-init/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-init/#usage-example","title":"Usage Example","text":"<p>Example on how to initialize a new stack to deploy a GKE cluster</p> <pre><code>mkdir \"my-gke-cluster\"\ncd \"my-gke-cluster\"\nhubctl stack init -f \"https://raw.githubusercontent.com/epam/hubctl-google-stacks/main/gke-empty-cluster/hub.yaml\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-init/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack configure</code></li> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-invoke/","title":"Command: <code>hubctl stack invoke</code>","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/cli/hubctl-stack-ls/","title":"Command: <code>hubctl stack ls</code>","text":"<p>Useful command when you have deployment multiple stacks from the one working directory it will help you to navigate across them</p> <p>It prints stack domain name as an identifier and marks which has been set as a active with the <code>*</code> symbol</p> <p>See example below</p> <pre><code>hubctl stack ls\n# ACTIVE  STACK                 STATUS      TIMESTAMP\n# *       disastrous-lundy-871  undeployed  2023-04-13T13:11:50\n#         funny-ray-ray-795     deployed    2023-04-13T13:09:14\n</code></pre> <p>Most likely the stack has been initialized with <code>hubctl stack init</code> command however not yet configured (<code>hubctl stack configure</code>)</p>"},{"location":"hubctl/cli/hubctl-stack-ls/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack set</code></li> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-rm/","title":"Command: <code>hubctl stack rm</code>","text":"<p>This command is basically deletes stack configuration created via <code>hubctl stack init</code> or <code>hubctl stack configure</code> commands.</p> <p>This command won't undeploy a stack if it has been deployed</p> <p>Common usage scenario is actually a clean up your working directory from stacks that has been previously undeployed and you don't have use of them anymore</p>"},{"location":"hubctl/cli/hubctl-stack-rm/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-set/","title":"Command: <code>hubctl stack set</code>","text":"<p>Set stack by it's name as a current.</p> <p>Example</p> <pre><code>hubctl stack ls\n# ACTIVE  STACK                 STATUS      TIMESTAMP\n# *       disastrous-lundy-871  undeployed  2023-04-13T13:11:50\n#         funny-ray-ray-795     deployed    2023-04-13T13:09:14\n\nhubctl stack set \"funny-ray-ray-795\"\n\nhubctl stack ls\n# ACTIVE  STACK                 STATUS      TIMESTAMP\n#         disastrous-lundy-871  undeployed  2023-04-13T13:11:50\n# *       funny-ray-ray-795     deployed    2023-04-13T13:09:14\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-set/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack ls</code></li> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack-undeploy/","title":"Command: <code>hubctl stack undeploy</code>","text":"<p>Reverse deployment operation for entire stack or particular components</p> <p>Because <code>undeploy</code> is a reverse operation to <code>deploy</code>, you might want to check out article for <code>hubctl stack deploy</code> sections about executors and deployment hooks.</p>"},{"location":"hubctl/cli/hubctl-stack-undeploy/#command-parameters","title":"Command Parameters","text":"Flag Description Required <code>-c --component &lt;component&gt;</code> Start un-deployment for one  component or multiple (supplied as comma separated value) <code>-o --offset &lt;component&gt;</code> Start un-deployment from specific component (handy when you want to restart un-deployment, and want to skip few from the beginning in the run list) <code>-l --limit &lt;component&gt;</code> Stop un-deployment after desired (opposite to <code>--offset</code> flag) <code>--profile</code> Choose a specific un-deployment provider (defaults to <code>HUB_PROFILE</code> in <code>.env</code> file) <code>--tty</code> or <code>--no-tty</code> Instructs if user wants to group outputs per component"},{"location":"hubctl/cli/hubctl-stack-undeploy/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-stack-undeploy/#usage-example","title":"Usage Example","text":"<p>To un-deploy all components in the runlist:</p> <pre><code>hubctl stack undeploy\n</code></pre> <p>To un-deploy specific components with order defined in the run-list</p> <pre><code>hubctl stack undeploy -c \"external-dns,cert-manager\"\n</code></pre>"},{"location":"hubctl/cli/hubctl-stack-undeploy/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack deploy</code></li> <li><code>hubctl stack rm</code></li> <li><code>hubctl stack</code></li> </ul>"},{"location":"hubctl/cli/hubctl-stack/","title":"Command: <code>hubctl stack</code>","text":"<p>Helps you to manage your stack deployments</p>"},{"location":"hubctl/cli/hubctl-stack/#sub-commands","title":"Sub-commands","text":"<p>Extensions provides following commands:</p> Command Description <code>hubctl stack init</code> Initialise a new stack deployment in the working directory <code>hubctl stack configure</code> Manage configuration before the deployment <code>hubctl stack deploy</code> Apply deployment to target infrastructure <code>hubctl stack undeploy</code> Reverse deployment action <code>hubctl stack ls</code> See other stacks that has been initialized for the working directory <code>hubctl stack set</code> Change a different current stack <code>hubctl stack rm</code> Delete configuration of a stack from working directory. This commands is non-reversible, and doesn't run <code>undeploy</code>"},{"location":"hubctl/cli/hubctl-stack/#advanced-commands","title":"Advanced Commands","text":"<p>These commands intended for advanced usage</p> Command Description <code>hubctl stack backup</code> Stack backup/restore management (*if \"backup\" verb supported by at least one component in the stack) <code>hubctl stack elaborate</code> Reconcile defined parameters and a state <code>hubctl stack invoke</code> Execute other verb rather than <code>deploy</code>, <code>undeploy</code> or <code>backup</code>. (*if verb supported by at least one component in the stack) <code>hubctl stack explain</code> Command reserved for state and parameters diagnostics"},{"location":"hubctl/cli/hubctl-stack/#common-flags","title":"Common Flags","text":"<p>These parameters applies across all extension commands</p> Flag Description Required <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-toolbox/","title":"Command: <code>hubctl toolbox</code>","text":"<p>This command will run a toolbox container in interactive mode and will let you to deploy stack without having to install all necessary tools besides a docker</p> <p>Actually this command performs the following actions</p> <ol> <li>Pull a docker image</li> <li>Use current directory as a working directory inside of the image</li> <li>Run a toolbox in interactive shell</li> </ol>"},{"location":"hubctl/cli/hubctl-toolbox/#command-parameters","title":"Command Parameters","text":"Flag Description Default <code>-i --toolbox-image &lt;docker-image&gt;</code> Use docker image for a docker toolbox var: <code>HUB_TOOLBOX_IMAGE</code> or <code>ghcr.io/epam/hub-toolbox:base</code>"},{"location":"hubctl/cli/hubctl-toolbox/#common-parameters","title":"Common Parameters","text":"<p>These parameters applies across all extension commands</p> Flag Description <code>-V --verbose</code> extra verbosity for diagnostics <code>-h --help</code> print help and usage message"},{"location":"hubctl/cli/hubctl-toolbox/#usage-example","title":"Usage Example","text":"<p>To start a toolbox container and run a deployment from inside</p> <pre><code>hubctl toolbox\n# wait a docker pull\n# see a docker shell instead\nhubctl stack deploy\nexit\n</code></pre>"},{"location":"hubctl/cli/hubctl-toolbox/#see-also","title":"See also","text":"<ul> <li><code>hubctl stack</code></li> <li><code>hubctl show</code></li> </ul>"},{"location":"hubctl/design-and-architecture/","title":"Design and Architecture","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/extensions/","title":"Extensions","text":"<p>Lorem ipsum...</p>"},{"location":"hubctl/hooks/","title":"Hooks","text":"<p>Lorem ipsum...</p>"},{"location":"reference/","title":"Hubfile","text":"<p>Hubfiles defines a stack, parameters and components. Each component has it's own manifest. </p> <ul> <li>Stack manifest file <code>hub.yaml</code> and optional <code>param.yaml</code> defined on the top level. </li> <li>Components are defined in the <code>components</code> directory. Each have a hubfile <code>hub-component.yaml</code> that defines the structure of the component and rules how to deploy it. </li> </ul>"},{"location":"reference/#directory-structure","title":"Directory Structure","text":"<p>While directory structure has not been fixed. yet we recommend the following:</p> <pre><code>\u251c\u2500\u2500 bin\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 deployment-hook.sh       \n\u251c\u2500\u2500 components\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 component1\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 hub-component.yaml\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 deploy.sh\n\u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 undeploy.sh\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 component2\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 hub-component.yaml\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 main.tf\n\u251c\u2500\u2500 hub.yaml\n\u2514\u2500\u2500 params.yaml\n</code></pre> <p>In this example the<code>component1</code> uses shell to deploy. It <code>deploy.sh</code> and <code>undeploy.sh</code>. </p> <p>The <code>component2</code> is using Terraform, and contains <code>*.tf</code> file (or files)</p> <p>Hubfile <code>hub.yaml</code> can define a deployment hooks, something that needs to be executed before or after individual component deployment. This webhook has been placed in the <code>bin</code> directory.</p>"},{"location":"reference/#best-practice","title":"Best Practice","text":"<p>Parameter definitions for entire stack can be quite large. For convenience parameters of the stack into the <code>params.yaml</code> or in the group of <code>params-*.yaml</code> files. Then you can refer additional files in the <code>hub.yaml</code> as the following:</p> <pre><code>extension:\n  include:\n  - params.yaml\n</code></pre> <p>See more in hubctl extensions</p> <p>Note: this is a good practice to split parameters from <code>hub.yaml</code> into it's own file <code>params.yaml</code> or even a series of <code>params.yaml</code> files. The parameter files can be referenced in <code>hub.yaml</code> as the following</p>"},{"location":"reference/#see-also","title":"See Also","text":"<ul> <li>Hubfiles</li> <li>Hubctl Components</li> <li>Stack Extensions</li> </ul>"},{"location":"reference/components/","title":"Components","text":"<p>Component is a piece of software that can be deployed and undeployed that actually makes sense. Components could be anything - hubctl is not tied to any particular automation technology the only requirements are:</p> <ul> <li>Automation code that hubctl knows how to deploy. This can be as simple as shell script or more advanced such as ARM template or Terraform.</li> <li><code>hub-component.yaml</code> that describes component requirements, input and output parameters. Parameters can be passed to the automation code via environment variables or via templates.</li> </ul> <p>Optionally component could have:</p> <ul> <li><code>Template</code> - probably  way how to inject parameters from <code>hub-componet.yaml</code> to automation. Hubctl supports both string replacement and go-templates.</li> <li><code>pre-deploy</code> and <code>post-deploy</code> hooks - scripts that will be executed before and after component deployment.</li> </ul>"},{"location":"reference/components/#automation-code","title":"Automation Code","text":"<p>By design hubctl is not tied to any particular automation technology. However we have got prebuilt support for most popular automation tools</p>"},{"location":"reference/components/#shell-script","title":"Shell Script","text":"<p>Most flexible way and the most simple one. You only need to define a two scripts and pass parameters via environment variables.</p> <ul> <li><code>deploy.sh</code> - script that will be executed during component deployment</li> <li><code>undeploy.sh</code> - script that will reverse deployment. Every component should have undeploy script.</li> </ul> <p>Configuration can be passwd via environment variables defined in <code>hub-component.yaml</code> file. Hubctl will not pass any arguments to the scripts</p>"},{"location":"reference/components/#helm","title":"Helm","text":"<p>Helm is a package manager for Kubernetes. Hubctl will automatically detect Helm charts when component contains a <code>values.yaml</code> file.</p>"},{"location":"reference/components/arm/","title":"ARM Deployment Template","text":"<p>ARM templates are used to deploy resources to Azure. They are written in JSON and can be used to deploy a single resource or a set of resources. They can be used to deploy resources to a new resource group or to an existing resource group. They can be used to deploy resources to a new subscription or to an existing subscription.</p> <p>Hubctl can deploy ARM templates as a component. Hubctl will use the Azure CLI to deploy the ARM template.</p>"},{"location":"reference/components/arm/#arm-conventions","title":"ARM Conventions","text":"<p>To enable hubctl to recognize component as an ARM deployment component, User should add <code>arm</code> requirements to <code>hub-component.yaml</code> file:</p> <pre><code>requires:\n- azure\n- arm\n</code></pre>"},{"location":"reference/components/arm/#input-parameters","title":"Input parameters","text":"<p>There are number of well-known parameters that can be used to configure ARM deployment. These parameters are defined in <code>hub-component.yaml</code> file. Today there is no strict convention for parameter names. User is free to choose any parameter name they like, however these parameters should be bound to the specific environment variables.</p> Variable Description Required Passed from <code>.env</code> <code>ARM_TEMPLATE</code> Local file or URI to the ARM Deployment Template. If not set then hubctl will try to find deployment template by schema in component directory <code>ARM_DEPLOYMENT_NAME</code> Name associated to the ARM Deployment. If not set then name of the component will be used <code>ARM_PARAMETER_FILES</code> Space separated list to ARM Deployment Parameter files. If file cannot be found it will be ignored <code>ARM_PARAMETER_paramName</code> Hubctl will read all environment variables prefixed with <code>ARM_PARAMETERS_</code> to set ARM deployment parameters. In this example hubctl will set a parameter <code>parameterName</code> with the value of environment variable <code>ARN_PARAMETER_paramName</code> <code>ARM_PARAM_paramName</code> Same as <code>ARM_PARAMETER_paramName</code> <code>AZURE_RESOURCE_GROUP_NAME</code> Name of the target resource group. If not set then resource group defined during <code>hub stack configure -r \"azure\"</code> will be used <p>Note: <code>ARM_PARAMETER_</code> and <code>ARM_PARAM_</code> are aliases for the same parameter. User can use either one of them. These environment variables works similar to well known Terraform variables <code>TF_VAR_</code>.</p>"},{"location":"reference/components/arm/#deployment-hooks","title":"Deployment Hooks","text":"<ul> <li><code>pre-deploy</code> to trigger action before ARM Deployment template will be created</li> <li><code>post-deploy</code> to trigger action after ARM Deployment template will be created</li> <li><code>pre-undeploy</code> to trigger action before ARM Deployment template will be deleted</li> <li><code>post-undeploy</code> to trigger action before ARM Deployment template will be deleted</li> </ul> <p>Note: pre and post deployment scripts should have execution rights</p>"},{"location":"reference/components/arm/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> </ul>"},{"location":"reference/components/helm/","title":"Helm Component","text":"<p>Helm is a popular packaging technology for Kubernetes applications. We do provide our own opinionated way how to deploy helm components.</p>"},{"location":"reference/components/helm/#component-conventions","title":"Component Conventions","text":"<p>If component follows the conventions below, then hubctl will know how to deploy it.</p>"},{"location":"reference/components/helm/#helm-detection","title":"Helm Detection","text":"<p>When you want to use helm deployment add the following definition to the <code>hub-component.yaml</code></p> <pre><code>requires:\n- kubernetes\n- helm\n</code></pre> <p>and place one one of the following files in the component directory: <code>values.yaml</code>, <code>values.yaml.template</code> or <code>values.yaml.gotemplate</code></p> <p>Then hubctl will be able detect this component as helm component and call provisioning script: helm-component-deploy .</p>"},{"location":"reference/components/helm/#input-parameters","title":"Input parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required <code>DOMAIN_NAME</code> FQDN of a stack. We use this parameter as a natural id of the deployment (defaults to implicit variable <code>HUB_DOMAIN_NAME</code>). Usage of this variables requires user to define a parameter <code>dns.domain</code> in <code>hub-component.yaml</code>. Yet we advice to use instead an implicit variable <code>HUB_DOMAIN_NAME</code> instead <code>COMPONENT_NAME</code> Corresponds to parameter <code>hub.componentName</code> parameter, however can be overriden in <code>hub-component.yaml</code>. Hub will use this variable as a helm release name x <code>NAMESPACE</code> Target kubernetes namespace x <code>HELM_CHART</code> This can have multiple values, that corresponds to the helm chart location. Corresponds to the helm chart tarball, directory or a chart name in the repository x <code>HELM_REPO</code> Instructs hubctl to download helm chart from the helm repository <code>HELM_CHART_VERSION</code> Addes a version constraint to the helm chart install. This variable works in conjunction with <code>HELM_REPO</code> <code>HELM_CHART_USERNAME</code> and <code>HELM_CHART_PASSWORD</code> Username and password for helm chart repository basic auth <code>CHART_VALUES_FILE</code> Instructs hubctl that it must use concrete values file inside of the helm chart as the base and only override with parameters from <code>values.yaml</code> in the component root directory. Alternatively if this variable has prefix <code>http</code> or <code>https</code> then the file. Additional values files can be referenced by adding a whitespace (or new line) separated reference <code>CRD</code> URL or local path to the CRD file (if not located in <code>&lt;component root&gt;/crds</code> directory) <code>HELM_OPTS</code> Helm command arguments, defautls to <code>--create-namespace --wait</code>"},{"location":"reference/components/helm/#environment-variable-helm_chart","title":"Environment variable: <code>HELM_CHART</code>","text":"<p>Helm chart which user wants to deploy can be resolved via variable <code>HELM_CHART</code>. This variable corresponds to the following value:</p> <ul> <li>Path to the local directory with the helm chart (relative to the <code>&lt;component root&gt;</code> or <code>&lt;component root&gt;/charts</code> directory)</li> <li>Path to the local directory with the helm chart (relative to the <code>&lt;component root&gt;</code> or <code>&lt;component root&gt;/charts</code> directory )</li> <li>Name of the helm chart in the helm repository (requires user to define: <code>HELM_REPO</code> and <code>HELM_CHART_VERSION</code>)</li> </ul>"},{"location":"reference/components/helm/#deployment-hooks","title":"Deployment hooks","text":"<p>User can define pre and post deployment</p> <ul> <li><code>pre-deploy</code> or <code>pre-deploy.sh</code> to trigger action before helm install</li> <li><code>post-deploy</code> or <code>post-deploy.sh</code> to trigter action after successful helm install</li> <li><code>pre-undeploy</code> or <code>pre-undeploy.sh</code> to trigger action before helm delete</li> <li><code>post-undeploy</code> or <code>post-undeploy.sh</code> to trigger action after helm successful delete</li> </ul> <p>Note: pre and post deployment scripts should have execution rights</p>"},{"location":"reference/components/helm/#custom-resources","title":"Custom Resources","text":"<p>We do advise not to deploy CRD with the helm chart. Because component <code>undeploy</code> (and <code>helm delete</code> correspondingly) will also delete CRDs. Deletion of CRD will also delete custom resources that may have been deployed by the user after this component has been deployed. Instead we advise to put your CRDs in to the <code>&lt;component root&gt;/crds</code> directory. In this case, CRDs will be managed separately from the helm chart</p> <ol> <li>CRDs will be deploymed before the helm chart</li> <li>CRDs will not be deleted after component will be undeployed. Which means you can redeploy the component without dropping user custom resources</li> </ol>"},{"location":"reference/components/helm/#examples","title":"Examples","text":"<p>Nginx web server example. This is an example of a <code>hub-component.yaml</code> that will install a helm chart without any modifications. Complete code for nginx component can be found here</p> <pre><code>---\nversion: 1\nkind: component\nrequires:\n  - kubernetes\n  - helm\nprovides:\n  - nginx\n  - ingress\nparameters:\n  - name: ingress.namespace\n    value: ingress\n    env: NAMESPACE\n  - name: ingress.class\n    value: nginx\n  - name: helm\n    parameters:\n      - name: chart\n        value: nginx-ingress\n        env: HELM_CHART\n      - name: repo\n        value: https://helm.nginx.com/stable\n        env: HELM_REPO\n      - name: version\n        value: 0.13.2\n        env: HELM_CHART_VERSION\ntemplates:\n  files:\n    - values.yaml.template\n</code></pre> <p>Note: helm chart parameters values must be defined in the <code>values.yaml.template</code> alternatively you can run <code>values.yaml.gotemplate</code> file</p>"},{"location":"reference/components/helm/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> <li>Kubernetes Configuration</li> </ul>"},{"location":"reference/components/kubernetes/","title":"Kubernetes Component","text":"<p>Kubenretes is a far popular technology to run containers. We do love Kubernetes and provide  first class support with the <code>hubctl</code>. So <code>hubctl</code> will manage access credentials and provide naming conventions for Kubernetes.</p>"},{"location":"reference/components/kubernetes/#when-component-requires-kubenretes","title":"When component requires kubenretes","text":"<p>Here we provide conventions required for component if it requires kubenretes. These conventions repeat conventions for helm extensions and kustomize extensions</p> <p>File <code>hub-component.yaml</code> of the component should require <code>kubernetes</code> and expose few of the parameters as the environment variabels</p> <pre><code>requires:\n- kubernetes\nparameters:\n- name: dns.domain\n  env: HUB_DOMAIN_NAME\n- name: kubernetes.namespace # this parameter name can be anything\n  value: kube-system         # this is example of kubenretes namespace\n  env: NAMESPACE\n</code></pre> <p>More about required parameters has been described below</p> <p>Note: kubeconfig should exist before, kubernetes cluster context should match to the <code>dns.domain</code> of your stack</p>"},{"location":"reference/components/kubernetes/#input-parameters","title":"Input parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required Passed from <code>.env</code> <code>HUB_DOMAIN_NAME</code> Hub naming convention requires <code>dns.domain</code> parameter to match to kubeconfig context that corresponds to the stack, fallbacks to legacy <code>DOMAIN_NAME</code> env var. If not defined in <code>hub-component.yaml</code> manifest will be derived from stack x <code>NAMESPACE</code> Target kubernetes namespace x <p>There are additional environment variables, depends on your cloud type</p>"},{"location":"reference/components/kubernetes/#kubeconfig-helper-script","title":"Kubeconfig helper script","text":"<p>Because components de-facto has been deployed by the shell scripts. So it is natural to provide helper functionality for Kubernetes in the form of script as well.</p> <p><code>bin/kubeconfig</code> is a script that helps with kubeconfig management. This sript has been available in the <code>PATH</code> of every component that has been deployed.</p> <ul> <li><code>kubeconfig cp</code> - writes to stdout (or file) the extracted copy of a one context and user credentials. It will rename to the value of (<code>HUB_STACK_DOMAIN</code>) to follow to the <code>hubctl</code> conventions for kubernetes.</li> <li><code>kubeconfig test</code> - will test connectivity to the kubernetes cluster</li> </ul>"},{"location":"reference/components/kubernetes/#when-component-provides-kubenretes","title":"When component provides kubenretes","text":"<p>This is useful when component actually deploys a new instance of the Kubenretes cluster. Then the component has been responsible to provide outputs of a kubenretes cluster in a standard form (standard output parameters and kubeconfig). So, this can be used by following components in the runlist that requires kubernetes. This is a bit of extra effort but it will also ensure that component that requires kubernetes (and possible written by someone else) will know how to get deployed into the Kubenretes cluster providen by your component</p> <p>There are various ways how Kubenretes cluster can be deployed. So, information in the <code>hub-component.yaml</code> file will be different</p>"},{"location":"reference/components/kubernetes/#example-for-gke","title":"Example for <code>GKE</code>","text":"<p>The minimalistic GKE cluster should provide following</p> <pre><code>provides:\n- kubernetes\noutputs:\n  - name: dns.domain\n  - name: kubernetes.gke.cluster\n  - name: kubernetes.api.endpoint\n</code></pre>"},{"location":"reference/components/kubernetes/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> <li>Component Helm</li> <li>Component Kustomize</li> </ul>"},{"location":"reference/components/kustomize/","title":"Kustomize Component","text":"<p>Kustomize is a popular packaging technology for Kubernetes applications. It relies on the series of patches. Hub can provide some additional templatng capabilities as well as some smarter resource creation capabilities</p>"},{"location":"reference/components/kustomize/#component-conventions","title":"Component Conventions","text":""},{"location":"reference/components/kustomize/#kustomize-detection","title":"Kustomize Detection","text":"<p>Because kustomize has been part of <code>kubectl -k ...</code> this compoenent doesn't require any specific configuration besides just a kubernetes. So hubfile should have</p> <pre><code>requires:\n- kubernetes\n</code></pre> <p>Kustomize component has been detected by hubctl if component has following files in it's root directory:  <code>kustomization.yaml</code>, <code>kustomization.yaml.template</code> or <code>kustomization.yaml.gotemplate</code></p> <p>Then hubctl will be able detect this component as helm component and call provisioning script: hub-component-kustomize</p>"},{"location":"reference/components/kustomize/#input-parameters","title":"Input parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required <code>DOMAIN_NAME</code> FQDN of a stack. We use this parameter as a natural id of the deployment (defaults to implicit variable <code>HUB_DOMAIN_NAME</code>). Usage of this variables requires user to define a parameter <code>dns.domain</code> in <code>hub-component.yaml</code>. Yet we advice to use instead an implicit variable <code>HUB_DOMAIN_NAME</code> instead <code>NAMESPACE</code> Target kubernetes namespace x <code>HUB_KUSTOMIZE_TARBALL_URL</code> Download kustomize base from the tarball. It will unpack tarball into <code>&lt;component root&gt;/kustomize</code> directory. Then you can refer resources or bases from this directory in your <code>kustomization.yaml</code> file <code>HUB_KUSTOMIZE_TARBALL_SUBPATH</code> Works in conjuction with <code>HUB_KUSTOMIZE_TARBALL_URL</code>, it instructs to unpack to the <code>&lt;component root&gt;/kustomize</code> a subpath inside the tarball <code>HUB_KUSTOMIZE_RESOURCES</code> Necessary when resources referenced in <code>kustomize.yaml</code> file must be downloaded before deployment. This variable contains whitespace separted list of URI or local file locations <code>CRD</code> URL or local path to the CRD file (if not located in <code>&lt;component root&gt;/crds</code> directory)"},{"location":"reference/components/kustomize/#deployment-hooks","title":"Deployment hooks","text":"<p>User can define pre and post deployment</p> <ul> <li><code>pre-deploy</code> to trigger action before helm install</li> <li><code>post-deploy</code> to trigter action after successful helm install</li> <li><code>pre-undeploy</code> to trigger action before helm delete</li> <li><code>post-undeploy</code> to trigger action after helm successful delete</li> </ul> <p>Note: pre and post deployment scripts should have execution rights</p>"},{"location":"reference/components/kustomize/#custom-resources","title":"Custom Resources","text":"<p>We do advise not to deploy CRD with the helm chart. Because component <code>undeploy</code> (and <code>helm delete</code> correspondingly) will also delete CRDs. Deletion of CRD will also delete custom resources that may have been deployed by the user after this component has been deployed. Instead we advise to put your CRDs in to the  <code>&lt;component root&gt;/crds</code> directory. In this case, CRDs will be managed separately from the helm chart</p> <ol> <li>CRDs will be deploymed before the helm chart</li> <li>CRDs will not be deleted after component will be undeployed. Which means you can redeploy the component without dropping user custom resources</li> </ol>"},{"location":"reference/components/kustomize/#examples","title":"Examples","text":"<p><code>//TODO</code></p>"},{"location":"reference/components/kustomize/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> <li>Kubernetes Configuration</li> </ul>"},{"location":"reference/components/lifecycle/","title":"Section <code>lifecycle</code>","text":"<pre><code>lifecycle:\n  verbs:  # add custom verbs for `hub invoke`\n  - deploy\n  - undeploy\n  bare: true  # set to allow components without deploy or undeploy implementation\n              # usefull for creating synthetic outputs\n  readyConditions:\n  - dns: api.${dns.domain}              # resolvable\n    url:  https://api.${dns.domain}/v1  # returns something other than HTTP 500\n    waitSeconds: 600  # how long to wait for the condition\n    pauseSeconds: 0   # pause before starting poll loop\n  options:\n    random:\n      bytes: 128  # see Manifest &gt; Outputs &gt; Securing outputs\n</code></pre>"},{"location":"reference/components/makefile/","title":"Makefile Component","text":"<p>Lorem ipsum...</p>"},{"location":"reference/components/shell/","title":"Shell Component","text":"<p>Shell component is a component that can be deployed using shell scripts. This is the easiest and most flexible way how to deploy a component. </p> <p>Minimal component structure would look liek the following</p> <pre><code>./\n\u251c\u2500\u2500 hub-component.yaml  # component manifest\n\u251c\u2500\u2500 deploy.sh           # shell script to deploy the component\n\u2514\u2500\u2500 undeploy.sh         # shell script to undeploy the component\n</code></pre>"},{"location":"reference/components/shell/#conventions","title":"Conventions","text":"<p>There are no specific variables that are expected to be passed to the shell script. </p> <p>Scripts expected:</p> <ul> <li><code>deploy.sh</code> - script to deploy the component (mandatory)</li> <li><code>undeploy.sh</code> - script to undeploy the component (mandatory)</li> <li><code>&lt;verb&gt;.sh</code> - any other script that can be used to perform any other action</li> </ul> <p>You can define additional variables in the <code>hub-component.yaml</code> file.</p> <pre><code>lifecycle:\n    verbs:\n    - deploy\n    - undeploy\n    - bar-verb\n</code></pre> <p>You can call this verb by running the following command</p> <pre><code>hubctl stack invoke \"foo-component\" \"bar-verb\"\n</code></pre>"},{"location":"reference/components/shell/#best-practices","title":"Best practices","text":"<p>Component should always have a <code>undeploy.sh</code> script. Good design says the deployment of any component should be revertible (verb: undeploy)</p> <p>Parametrise your shell scripts via environment variables. You can define environment variables in the <code>hub-component.yaml</code> file.</p> <p>Parametrsise your configuration via templates.</p>"},{"location":"reference/components/shell/#see-also","title":"See Also","text":"<ul> <li>hub stack</li> <li>hub stack invoke</li> </ul>"},{"location":"reference/components/terraform/","title":"Terraform Component","text":"<p>Terraform is a popular infrastruture as code technology often used to deploy cloud resources. We do provide our own opinionated way how to deploy Terraform. In this case you can follow simple conventions and you don't require to write a deployment scripts</p>"},{"location":"reference/components/terraform/#component-conventions","title":"Component Conventions","text":"<p>If component follows the conventions below, then hubctl will know how to deploy it.</p> <p>Minimalistic terraform component will look like this:</p> <p>Hubctl will automatically detect Terraform code when component contains one or more <code>*.tf</code> files.</p> <pre><code>./\n\u251c\u2500\u2500 hub-component.yaml  # component manifest\n\u2514\u2500\u2500 main.tf             # terraform code\n</code></pre>"},{"location":"reference/components/terraform/#configuration","title":"Configuration","text":"<p>Terraform variables can be supplied in two ways:</p> <ol> <li>Terraform variables can be defined by component parameter and exported as <code>TF_VAR_*</code> environment variable (recommended way)</li> <li>Terraform variables can be defined in <code>*.tfvars</code> or <code>*.tfvars.template</code> file</li> </ol>"},{"location":"reference/components/terraform/#parameters","title":"Parameters","text":"<p>As every script, helm deployment scripts has been controlled via set off well-known environment variables. These variables should be defined in parameters section of <code>hub-component.yaml</code>. List of expected environment variables</p> Variable Description Required Passed from <code>.env</code> <code>COMPONENT_NAME</code> Corresponds to parameter <code>hub.componentName</code> parameter, however can be overriden in <code>hub-component.yaml</code>. Hub will use this variable as a helm release name x <code>HUB_DOMAIN_NAME</code> FQDN of a stack. We use this parameter as a natural id of the deployment x x <code>HUB_CLOUD_PROVIDER</code> Tells hubctl to use different backends for terraform. We currently support: <code>aws</code>, <code>azure</code> or <code>gcp</code> x x <code>HUB_STATE_BUCKET</code> Object storage bucket to be be used for terraform state x x <code>HUB_STATE_REGION</code> Region for terraform state bucket x x <p>There are additional environment variables, depends on your cloud type</p>"},{"location":"reference/components/terraform/#aws-specific-variables","title":"AWS specific variables","text":"<p>These variables has been set during <code>hubctl stack configure</code> state and defined in <code>.env</code> file. You don't have to refer it for your component, however you can overwrite.</p> Variable Description Required <code>AWS_PROFILE</code> AWS name of the profile. Referenced from <code>.env</code> file. However you can override it in <code>hub-component.yaml</code> file x"},{"location":"reference/components/terraform/#azure-specific-variables","title":"Azure specific variables","text":"<p>These variables has been set during <code>hubctl stack configure</code> state and defined in <code>.env</code> file. These are the minimum viable variables expected by our terraform deploymenet script</p> Variable Description Required <code>ARM_CLIENT_ID</code> The client(application) ID of an App Registration in the tenant <code>ARM_CLIENT_SECRET</code> A client secret that was generated for the App Registration <code>ARM_SUBSCRIPTION_ID</code> Access an Azure subscription value from within a Terraform script <code>ARM_TENANT_ID</code> ARM Tenant id <p>Full list of environment variables for azure can be found here</p>"},{"location":"reference/components/terraform/#gcp-specific-variables","title":"GCP specific variables","text":"Variable Description Required <code>GOOGLE_APPLICATION_CREDENTIALS</code> Default applicaiton credentials (ADC) see details here <code>GOOGLE_PROJECT</code> For to refer google project ID. See details here <p>Full reference of supported variables available here</p>"},{"location":"reference/components/terraform/#deployment-hooks","title":"Deployment hooks","text":"<p>User can define pre and post deployment</p> <ul> <li><code>pre-deploy</code> to trigger action before helm install</li> <li><code>post-deploy</code> to trigter action after successful helm install</li> <li><code>pre-undeploy</code> to trigger action before helm delete</li> <li><code>post-undeploy</code> to trigger action after helm successful delete</li> <li><code>import</code> a special script that to import existing resources into Terraform state.</li> </ul> <p>Note: <code>import</code> maybe a necessary step to allow manage non-idempotent resources such as AWS S3 bucket. Before running terraform deployment that will fail you may want to import bucket if it already exists. Note: deployment hooks should have execution rights</p>"},{"location":"reference/components/terraform/#see-also","title":"See also","text":"<ul> <li>Hub Components</li> </ul>"},{"location":"reference/manifests/","title":"Hubfile","text":"<p>Sometimes called as hub manifest. is a YAML file that describes a stack or a component. It is a source of truth for hubctl deployment. We will use both names interchangeably.</p> <p>There are two types of manifests:</p>"},{"location":"reference/manifests/#component-manifest","title":"Component manifest","text":"<p>Defined as <code>hub-component.yaml</code></p> <p>Located in the component directory. This file has the following structure:</p> <ul> <li>Requirements, that the component expects from environment or another (upstream) component</li> <li>What are the component input and output parameters</li> <li>Additional verbs (besides <code>deploy</code> and <code>undeploy</code>) that can be executed on the component</li> <li>Describes templates used by the component</li> </ul> <p>See more about component manifest in here.</p>"},{"location":"reference/manifests/#stack-manifest","title":"Stack manifest","text":"<p>Defined as: <code>hub.yaml</code>, <code>params.yaml</code>, <code>params-*.yaml</code>. </p> <p>Stack manifest describes how one or multiple components are deployed together. It has the following structure:</p> <ul> <li>Requirements from environment</li> <li>Defines components list and dependencies between them</li> <li>Defines stack input and output parameters</li> <li>Defines deployment hooks</li> </ul> <p>See more about stack manifest in here.</p>"},{"location":"reference/manifests/#see-also","title":"See Also","text":"<ul> <li>Component manifest</li> <li>Stack manifest</li> </ul>"},{"location":"reference/manifests/component/","title":"Hubfile Reference","text":"<p>On top level stack manifest contains following sections:</p> <pre><code>kind: component                            # mandatory, defines a component manifest                         \nversion: 1                                 # mandatory, manifest schema version\nmeta:                                      # optional, see Meta        \n  name: foo-component                      # optional, component name\n  brief: Foo component                     # optional, brief description of the component        \n  license: Apache 2.0                      # optional, license applied to component distribution\nrequires:                                  # optional, list of requirements for component can be provided by environment (stack), or another component\n- gcp                                      # example of component requirement\n- terraform                                # example of component requirement\nprovides:                                  # optional, list of capabilities provided by component\n- bucket                                   # example of component capability\nparameters:\n- name: hub.componentName                  # optional, special parameter that always bounds to component name defined in `hub.yaml`\n- name: bucket.name                        # mandatory, parameter name\n  value: ${hub.componentName}              # example, shows how to default \n  env: TF_VAR_name                         # optional, mapping to environment variable for use deployment script\n- name: bucket.region                      # example, shows mandatory paramer that have now default value\n- name: gcp.serviceAccount\n  empty: allow                             # example shows optional parameter that ca nbe empty\noutputs:                                   # optional, list of outputs provided by component\n- name: bucket.endpoint                    # mandatory, output name\n  value: https://storage.googleapis.com    # example, shows predefined output, parameter interpolation syntax is supported\n  breif: Well-knows GCP bucket endpoint    # optional, brief description for output\n- name: bucket.region                      \n  fromTfVar: location                      # example, shows how to map output to terraform variable\n- name: bucket.accessKey\n  fromTfVar: sensitive_access_key_id       # example, shows how to map output to sensitive variable\n- name: bucket.name                        # example, shows how to forward component parameter to output\ntemplates:                                 # optional, list of templates provided by component\n  kind: curly                              # mandatory, other values [mustache, go]\n  files:                                   # mandatory, list of template files, supports globs\n  - \"*.template\"                           # example of template files in current \nlifecycle:\n  verbs:                                   # optional, add custom verbs for `hub invoke`. Defaults to [deploy, undeploy]\n  - deploy\n  - undeploy\n  - backup                                  \n  bare: true                                # optional, instruction to allow component without deploy or undeploy implementation\n  readyConditions:                          # optional, conditions to check before declaring component deployed\n  - dns: api.${dns.domain}                  # optional, checks if dns name has been resolved\n    url:  https://api.${dns.domain}/v1      # optional, uses http ping GET to check if url is available\n    pauseSeconds: 0                         # optional, pause in seconds before starting poll loop\n\n</code></pre>"},{"location":"reference/manifests/component/#component-manifest","title":"Component manifest:","text":"<p>Component manifest section described on more details</p> <ul> <li>meta: name, description, version, etc.</li> <li>requires </li> <li>provides</li> <li>parameters: inputs, defaults, mapping to OS environment</li> <li>outputs</li> <li>templates: where are the templates</li> <li>lifecycle: verbs, fine-tuning for hubctl</li> </ul>"},{"location":"reference/manifests/component/#see-also","title":"See Also","text":"<ul> <li>Stack Manifest</li> </ul>"},{"location":"reference/manifests/component/lifecycle/","title":"Section <code>lifecycle</code>","text":"<p>Lifecycle, is a set of instructions to hubctl to control component deployment</p> <pre><code>lifecycle:\n  verbs:                                # optional, add custom verbs for `hub invoke`. Defaults to [deploy, undeploy]\n  - deploy\n  - undeploy\n  bare: true                            # optional, instruction to allow component without deploy or undeploy implementation\n  readyConditions:                      # optional, conditions to check before declaring component deployed\n  - dns: api.${dns.domain}              # optional, checks if dns name has been resolved\n    url:  https://api.${dns.domain}/v1  # optional, uses http ping GET to check if url is available\n    pauseSeconds: 0                     # optional, pause in seconds before starting poll loop\n  options:                              # optional\n    random:                             # optional\n      bytes: 128                        # optional, see Manifest &gt; Outputs &gt; Securing outputs\n</code></pre>"},{"location":"reference/manifests/component/lifecycle/#see-also","title":"See Also","text":"<ul> <li>Component Manifest</li> </ul>"},{"location":"reference/manifests/component/meta/","title":"Section: <code>meta</code>","text":"<p>This section defines metadata for the component manifest. Metadata can be captured by automation tools</p> <pre><code>version: 1                            # mandatory, component manifest schema version\nkind: component                       # mandatory, defines a component manifest\nmeta:                                 # optional, metadata for the component\n  name: happy-meal                    # optional human readable name\n  brief: Happy Meal                   # optional, brief description of the component\n  license: Apache 2.0                 # optional, license applied to component distribution\n</code></pre> <p>Every component must define at least manifest <code>version</code> and <code>kind</code>. Other fields are optional.</p> <p>We took inspiration for manifest design from Kubernetes resources. However we do not enforce mandatory <code>metadata.name</code>. Everything besides <code>metadata</code> is optional and intended to be used by automation tools.</p>"},{"location":"reference/manifests/component/meta/#see-also","title":"See Also:","text":"<ul> <li>Component manifest</li> <li>Parameters</li> </ul>"},{"location":"reference/manifests/component/outputs/","title":"Section <code>outputs</code>","text":"<p>To bind input parameters of the <code>pgweb</code> to specific PostgreSQL, use <code>depends</code>:</p> <pre><code>outputs:\n- name: ingress.hosts                     # mandatory, name of output parameter\n  brief: Ingress FQDN                     # optional, propagated to stack level outputs\n  value: ${dns.name}.${dns.baseDomain}    # optional, either `value` or `fromTfVar` must be defined\n  fromTfVar: fqdn                         # optional, either `value` or `fromTfVar` must be defined\n  kind: secret/token                      # optional, secret/&lt;kind&gt; is the only supported variation\n</code></pre> <p>When more than a single instance of the same component is deployed in the stack - think two PostgreSQL databases, then there is an ambiguity because both components provides same outputs, ie. <code>endpoint</code> and <code>password</code>.</p> <p>Where <code>brief</code> and <code>kind</code> will be propagated to stack level outputs if component:output syntax is used on hub.yaml level.</p>"},{"location":"reference/manifests/component/outputs/#computed-outputs","title":"Computed Outputs","text":"<p>When you need to output parameters from the deployment script (<code>deploy.sh</code>). Use the following syntax:</p> <pre><code>\ncat &lt;&lt; EOF\n\nOutputs:\nserver_uptime = $(uptime)\n\nEOF\n</code></pre> <p>And then link this with the <code>hub-component.yaml</code>:</p> <pre><code>outputs:\n- name: message.uptime\n  fromTfVar: server_uptime\n</code></pre> <p>Hubctl component deployment reads stdout for a specific Terraform like pattern. Once detected, it will capture response.</p>"},{"location":"reference/manifests/component/outputs/#outputs-from-file","title":"Outputs from File","text":"<p>To read outputs from a file use the following syntax, where parameter value prefixed with <code>file://</code>. See example below:</p> <pre><code>outputs:\n- name: message.uptime\n  fromFile: file://uptime.txt\n</code></pre>"},{"location":"reference/manifests/component/outputs/#see-also","title":"See Also","text":"<ul> <li>Component Manifest</li> <li>Stack Outputs</li> </ul>"},{"location":"reference/manifests/component/parameters/","title":"Section <code>parameters</code>","text":"<p>Parameters are used to configure stack and components in both stack manifest (<code>hub.yaml</code>) and component manifest (<code>hub-component.yaml</code>).</p> <p>Parameters have a tree-like structure where leafs have values and nodes should have nested parameters:</p> <pre><code>parameters:\n- name: cloud.kind\n  value: aws                          # set to value provided by user\n- name: cloud.regions                 # this parameter is only set for component `foo`\n  component: foo                      \n  value: [us-east-1, us-east-2]\n- name: kubernetes                    # nested parameters for kubernetes \n  parameters: \n  - name: worker.size\n    fromEnv: KUBERNETES_WORKER_SIZE   # Source value form environment variable\n    default: m5.large                 # Use default if value not provided\n</code></pre> <p>Native YAML syntax could be used to short-circuit nested declarations. The above is effectively flattened into list of parameters:</p> <pre><code>cloud.kind\ncloud.regions\nkubernetes.worker.size\n</code></pre> <p>The values are in most cases plain text / scalar type, yet we support arrays and maps - data types native to JSON and YAML.</p>"},{"location":"reference/manifests/component/parameters/#resolve-parameter-value","title":"Resolve parameter value","text":"<p>Here we specify parameter types and their interpretation.</p> <p>This is the most common type of parameter. It is used to set parameter value to a literal:</p> <pre><code>parameters:\n- name: kubernetes.namespace\n  value: kube-system\n</code></pre> <p>with interpolation</p> <pre><code>parameters:\n- name: dns.domain\n  value: example.com\n- name: ingress.hosts\n  value: www.${dns.domain}\n  # resolves to: www.example.com\n</code></pre> <p>or multiline parameters </p> <pre><code>parameters:\n- name: ingress.hosts\n  value: |\n    example.com\n    www.example.com\n</code></pre>"},{"location":"reference/manifests/component/parameters/#parameter-fromenv","title":"Parameter <code>fromEnv</code>","text":"<p>Stack Level only</p> <p>This parameter only forks for stack manifests (<code>hub.yaml</code> and <code>params-*.yaml</code>). It allows to set parameter value from environment variable:</p> <pre><code>parameters\n- name: kubernetes.namespace\n  fromEnv: NAMESPACE\n  default: kube-system\n</code></pre> <p>Parameter above will set value of parameter <code>kubernetes.namespace</code> to value of environment variable <code>NAMESPACE</code></p> <p>During <code>hubctl stack configure</code> user will be prompted to provide value for parameter <code>kubernetes.namespace</code> with default value <code>kube-system</code>. </p>"},{"location":"reference/manifests/component/parameters/#parameter-env","title":"Parameter <code>env</code>","text":"<p>Component Level only</p> <p>This parameter only works for component manifests (<code>hub-component.yaml</code>). It allows to set environment variables from parameter value:</p> <pre><code>parameters:\n- name: kubernetes.namespace\n  env: NAMESPACE\n  value: kube-system\n</code></pre> <p>Parameter above will define environment variable <code>NAMESPACE</code> with value <code>kube-system</code> as a default (unless stack will provide different name)</p>"},{"location":"reference/manifests/component/parameters/#parameter-fromfile","title":"Parameter <code>fromFile</code>","text":"<p>Parameter value could be read from file <code>fromFile: config/stage/password</code>.</p>"},{"location":"reference/manifests/component/parameters/#cel-expressions","title":"CEL expressions","text":"<p>Parameter <code>value</code> support CEL expressions enclosed in <code>#{}</code> such as:</p> <pre><code>parameters:\n- name: cloud.availabilityZones\n- name: cloud.availabilityZones.count\n  value: \"#{len(cloud.availabilityZones)}\"\n</code></pre> <p>CEL has some unexpected results for corner cases, use <code>hubctl cel</code> to debug.</p>"},{"location":"reference/manifests/component/parameters/#parameter-kind","title":"Parameter <code>kind</code>","text":"<p>All parameters can be derived from primarily from values or other components. These parameters resolved during the deployment. Until you are not care for specific parameter kind then leave it out.</p> <p>However there are special case parameters. In this case you define a special attribute <code>kind</code> to specify how parameter should be resolved.</p>"},{"location":"reference/manifests/component/parameters/#parameter-kind-user","title":"Parameter <code>kind: user</code>","text":"<p>There are high-level user-provided parameters - the facts <code>user</code> do care about: which cloud and cloud account to use, what region to deploy to, etc.</p>"},{"location":"reference/manifests/component/parameters/#parameter-kind-link","title":"Parameter <code>kind: link</code>","text":"<p>In general, preferred approach to resolve parameters provided as outputs from the component is through <code>components.depends</code> attribute. However sometimes you need to change parameter name as they are not match. </p> <p>To map output to a different name use <code>kind: link</code> parameter. The interpretation of <code>value</code> will be deferred until parameter is used:</p> <pre><code>parameters:\n- name: backend.image\n  value: ${ecr:docker.image}\n  kind: link\n</code></pre> <p><code>ecr</code> is a component deployed prior to <code>backend</code>. There are several ECRs thus output is fully qualified.</p>"},{"location":"reference/manifests/component/parameters/#see-also","title":"See also","text":"<ul> <li>Stack Manifest</li> <li>Component Manifest</li> <li>CEL expressions</li> </ul>"},{"location":"reference/manifests/component/provides/","title":"Section <code>provides</code>","text":"<p>This is a high level instruction to broadcast to the other components that after this component has been deployed, there is a new capability (or capabilities).</p> <pre><code>provides:     # optional\n- bucket      # example of provided capability\n</code></pre> <p>Capability is an arbitrary string. This string will be recognized by the other component in requires section.</p>"},{"location":"reference/manifests/component/provides/#access-provides-from-component","title":"Access Provides from Component","text":"<p>When component wants to check capabilities provided by environment or by other component. It can use:</p> <ul> <li>Well-known environment variable <code>HUB_PROVIDES</code> - same format as above.</li> <li>Well-known parameter <code>hub.provides</code> - whitespace separated list of capabilities</li> </ul> <p>Where parameter is a good choice for <code>deploy.sh</code> or <code>pre-deploy.sh</code>, or deployment hooks scripts. While parameter can be checked for instance by <code>gotemplate</code></p>"},{"location":"reference/manifests/component/provides/#best-practice","title":"Best Practice","text":"<p>Both <code>provides</code> and <code>requires</code> component maintainers agree on the exact capability string. They also agree on well-defined <code>outputs</code> which component will provide together with the capability. In the other words <code>requires</code> and <code>provides</code> defines mutual contract between components on what parameters to expect from each other.</p> <p>For instance, when component provides capability <code>bucket</code> it should also provide following outputs:</p> <pre><code>outputs:\n- name: bucket.endpoint\n- name: bucket.region\n- name: bucket.name\n- name: bucket.accessKey\n- name: bucket.secretKey\n</code></pre> <p>This will make such components as minio and gsbucket virtually interchangeable.</p> <p>There are a lot of parameters. You don't need all of them to output. Some parameters can be consumed by the input. However, component that will require either <code>minio</code> or <code>gsbucket</code>, it may expect these parameters will be provided.</p>"},{"location":"reference/manifests/component/provides/#see-also","title":"See Also","text":"<ul> <li>Requires</li> <li>Component Manifest</li> </ul>"},{"location":"reference/manifests/component/requires/","title":"Section <code>requires</code>","text":"<pre><code>requires:\n- aws\n- kubernetes\n</code></pre> <p>Component does not live in the vacuum. Some components expects certain capabilities provided by the upstream component or the environment</p> <p>Built-in requirements:</p> <ul> <li><code>aws</code></li> <li><code>azure</code></li> <li><code>gcp</code></li> <li><code>kubernetes</code></li> <li><code>helm</code></li> <li><code>terraform</code></li> </ul> <p>Component can define a requirement provided by another component. These requirements are not limited to the list above</p>"},{"location":"reference/manifests/component/templates/","title":"Section <code>templates</code>","text":"<pre><code>templates:\n  kind: curly                         # mandatory, mustache go\n  directories:                        # optional, list of directories to search for templates\n  - config                            # example of directory name\n  files:                              # mandatory, list of template files, supports globs\n  - \"*.template\"                      # example of template files in current component directory\n  extra:                              # optional, to support multiple template kinds\n  - kind: mustache                    # optional, additional template kind\n    files:                            # mandatory, list of template files, supports globs\n    - terraform/*.tfvars.template     # example of Terraform variable templates in directory `terraform`\n  - kind: go                          # example of Go template\n    files:                            \n    - helm/values*.yaml.gotemplate    # example of Helm values template\n</code></pre> <p>Note: either <code>directory</code> or <code>files</code> must be specified</p>"},{"location":"reference/manifests/component/templates/#template-kind","title":"Template Kind","text":"<p>Hubctl supports several kinds of templates</p> <ul> <li><code>curly</code> - String replacement template with format <code>${param}</code> in the file. This is the default template kind.</li> <li><code>mustache</code> - String replacement template with format <code>{{param}}</code></li> <li><code>go</code> - Go template with format <code>{{.param}}</code></li> </ul>"},{"location":"reference/manifests/component/templates/#kind-curly","title":"Kind: <code>curly</code>","text":"<p>A simple syntax where parameter name for substitution is included between curly brackets <code>${}</code>, ie. <code>${kubernetes.api.endpoint}</code>.</p> <p>Substitution may include encoding function <code>${param/encoding}</code> where <code>encoding</code> is one of:  <code>json</code>, <code>yaml</code>, <code>bcrypt</code>, <code>base64</code>. Multiple encodings are supported, processed in the order above: <code>${dex.passwordDb.password/bcrypt/base64}</code>.</p>"},{"location":"reference/manifests/component/templates/#kind-mustache","title":"Kind: <code>mustache</code>","text":"<p>Parameter name enclosed in <code>{{}}</code>. Because of conflict with <code>.</code> special meaning in mustache, it must be replaced with <code>_</code>, for example <code>{{component_cert-manager_issuerEmail}}</code>.</p>"},{"location":"reference/manifests/component/templates/#kind-go","title":"Kind: <code>go</code>","text":"<p>Full-featured Golang templates with <code>-</code> in parameter name replaced with <code>_</code>, for example <code>{{.cert_manager.issuerEmail}}</code>.</p> <p>Note: parameter name starts with <code>.</code> symbol</p> <p>Sprig Functions are available for use in go templates.</p>"},{"location":"reference/manifests/component/templates/#best-practice","title":"Best practice","text":"<ul> <li>Use <code>template</code> file extension for <code>curly</code> or <code>mustache</code> templates</li> <li>Use <code>gotemplate</code> file extension for <code>go</code> templates</li> </ul> <p>Before deployment, Hubctl will subtract template file extension and use the rest as a destination file name.</p>"},{"location":"reference/manifests/component/templates/#see-also","title":"See Also","text":"<ul> <li>Parameters</li> <li>Component manifest</li> <li>Golang templates</li> <li>Sprig Functions</li> </ul>"},{"location":"reference/manifests/stack/","title":"Stack Manifest","text":"<p>Stack manifest describes how one or multiple components are deployed together. It a either a <code>hub.yaml</code> file or combination of <code>hub.yaml</code> and <code>parameter-*.yaml</code> files.</p> <p>Below you will find compolete stack manifest example</p> <pre><code>meta:\n  kind: stack                                                 # mandatory, defines a stack manifest\n  version: 1                                                  # stack manifest schema version\nrequires:                                                     # optional, list of requirements form environment\n- kubernetes                                                  # example of stack requires\ncomponents:                                                   # mandatory, list of components\n- name: cert-manager                                          # mandatory, name of the component\n  source:                                                     # mandatory, component source\n    dir: components/cert-manager                              # mandatory, local path where to find component\n- name: knative-serving\n    source:\n      dir: components/knative-serving\n    git:                                                      # optional, git source to download component from\n      remote: https://github.com/epam/kubeflow-components.git # mandatory, git repository remote url\n      subDir: knative-serving                                 # mandatory, subdirectory in the repository\n      ref: develop                                            # optional, git reference (branch, tag, commit)\n    depends:                                                  # optional, component dependency\n    - cert-manager                                            # example of upstream dependency\nlifecycle:                                                    # optional, lifecycle verbs\n  verbs:                                                      # optional, list of verbs component supports (by default: deploy, undeploy)\n  - deploy                                                    # mandatory, deploy verb\n  - undeploy                                                  # mandatory, undeploy verb\n  - custom-verb                                               # optional, custom verb\n  order:                                                      # optional, order of deployment\n  - cert-manager                                              # example of deployment order, if not defined then deployment order derived from components definitions\n  - knative-serving\nparameters:                                                   # optional, stack input parameters (best practice, split to separate file or files)\n- name: dns.domain                                            # mandatory, parameter name\n  value: localhost                                            # optional, value for parameter\n- name: certmanager.namespace\n  component: cert-manager                                     # optional, component name, if not defined then parameter is global for all components\n  default: v1.11.0                                            # optional, default value for parameter\n  fromEnv: CERTMANAGER_NAMESPACE                              # optional, parameter value is taken from environment variable, this approach allows not to store exact value in version control. Useful for sensitive parameters.\n- name: ingress.hosts\n  empty: allow                                                # optional, to highlight parameter that can be empty\n  fromEnv: INGRESS_HOSTS                                      # good idea to pass value for empty parameters from environment variable\n  brief: Lorem ipsum                                          # optional, brief description for parameter\noutputs:                                                      # optional, stack output parameters\n- name: foo                                                   # mandatory, output name\n  value: http://localhost:${pgweb.port}                       # mandatory, output value, supports interpolation\n  brief: Lorem ipsum                                          # optional, brief description for output       \n</code></pre> <p>Note: if optional section defined, it may have mandatory attributes</p> <p>Follow each section separately to get more details:</p> <ul> <li>meta: name, brief</li> <li>components references: what and where are the components</li> <li>requires and provides</li> <li>parameters: stack inputs, mappings</li> <li>outputs of a stack</li> <li>lifecycle: verbs, optional and mandatory components, conditional deployment</li> <li>extensions: verbs, optional and mandatory components, conditional deployment</li> </ul>"},{"location":"reference/manifests/stack/#see-also","title":"See Also","text":"<ul> <li>Component Manifest</li> </ul>"},{"location":"reference/manifests/stack/components/","title":"Section <code>components</code>","text":"<pre><code>components:\n- name: external-dns\n  source:\n    dir: components/external-dns\n    git:\n      remote: https://github.com/epam/hub-kubeflow-components.git\n      ref: main\n      subDir: external-dns\n  depends:\n  - cert-manager\n</code></pre> <p>Above you can see <code>external-dns</code> component sources are under <code>./components/external-dns/</code> directory.</p> <p>Section <code>components.source.git</code> section is optional. If not specified then <code>hubctl stack init</code> will not pull the component from git repository if this component does not exist. This operation happens during <code>hubctl stack init</code></p> <p>Section <code>components.depends</code> defines dependency between components. This takes effect on the:</p> <ul> <li>Components deployment run-list <code>hubctl</code> will schedule component deployment in the order of dependency and then in order of declaration. User can overwrite order by declaring section <code>lifecycle.order</code> in stack manifest.</li> <li>Parameters resolution. Let's say there are two components who output the same parameter. Section <code>depends</code> will tell to <code>hubctl</code> which component parameters must be taken as input.</li> </ul>"},{"location":"reference/manifests/stack/components/#component-deployment-hooks","title":"Component Deployment Hooks","text":"<p>Sometimes before or after a component deployment, User need to perform an action that extends the component and often is environment or context-specific. To achieve that component lifecycle hooks were introduced. This approach allows keeping components KISS and if-less. Please refer to the example below:</p> <pre><code>components:\n- name: external-dns\n  source:\n    dir: components/external-dns\n  hooks:                                # optional\n  - file: bin/do-something              # rmandatory, relative to stack manifest file\n    brief: Some description of my hook  # optional, brief description for hook\n    error: ignore                       # optional, default is `error: fail`\n    triggers:                           # mandatory, when hook should be triggered. Accepts wildcards sich as `*-deploy` or `post-*`\n    - pre-deploy\n    - post-undeploy\n</code></pre> <p>There are 2 hooks in the example:</p> <ul> <li>File <code>pre-deploy-hook</code> from the <code>.hub</code> directory relative to the directory where the Hub manifest file is located (<code>hub.yaml</code>) will be executed BEFORE <code>external-dns</code> component is deployed. <code>error: ignore</code> means that stack deployment will continue even if there is an error in the hook (it exits with non 0 exit code)</li> <li>File <code>post-deploy-hook</code> from the <code>.hub</code> directory relative to the directory where the Hub manifest file is located (<code>hub.yaml</code>) will be executed AFTER <code>external-dns</code> component is deployed.</li> </ul> <p>Additionally,</p> <ul> <li><code>triggers</code> array also supports regular expressions, such as <code>*-deploy</code> or <code>post-*</code></li> <li>All hooks matching the expression will be executed, and hook order from the <code>hooks</code> list will be maintained.</li> </ul>"},{"location":"reference/manifests/stack/extensions/","title":"Section <code>extension</code>","text":"<p>This section is not exposed into parameters</p> <p>This section will has been dedicated to various hubctl extensions. Hubctl will ignore syntax checks inside of this section. However various extensions may require a specific structure.</p> <pre><code>extensions:                               # optional\n  include:                                # optional, additional parameter files         \n  - params.yaml \n  - params-env.yaml\n  init:                              # optional, steps activated during `hubctl stack init`\n  - bin/my-custom-init.sh            # example, you can define custom scripts here\n  configure:                              # optional, steps activated during `hubctl stack configure`\n  - aws\n  - kubernetes\n  - bin/my-custom-configure.sh            # example, you can define custom scripts here\n  deploy:\n    before:\n    - kubernetes                          # optional, steps activated on `hubctl stack deploy` but before actual deployment of components\n    - bin/my-custom-pre-deploy.sh         # example, you can define custom scripts here\n    after:                                # optional, steps activated on `hubctl stack deploy` but after actual deployment of components\n    - inventory-configmap               \n  undeploy:                               # optional, steps activated during `hubctl stack undeploy`\n    before:\n    - bin/my-custom-pre-undeploy.sh\n    after:\n    - bin/my-custom-post-undeploy.sh\n</code></pre>"},{"location":"reference/manifests/stack/extensions/#referring-another-stack-manifest-file","title":"Referring another stack manifest file","text":"<p>Note: This is a good practice to split parameters from hub.yaml into it's own file params.yaml or even a series of params.yaml files. The parameter files can be referenced in hub.yaml as the following</p> <pre><code>extension:\n  inclue:\n  - params.yaml\n</code></pre>"},{"location":"reference/manifests/stack/lifecycle/","title":"Section <code>lifecycle</code>","text":"<pre><code>lifecycle:                             # optional\n  verbs:                               # optional, verbs supported by stack (if omited, then limited to verbs deploy and undeploy)\n  - deploy          \n  - undeploy\n  order:                               # optional, user defined order of components in which it must be deployed. If omitted then order will be derived form component dependencies followed by component order in stack manifest\n  - kubernetes                         # example names of components\n  - traefik\n  - kube-dashboard\n  mandatory:                           # optional, list of mandatory components. by default all components are optional\n  - kubernetes\n  optional:                             # optional, list of optional components. by default all components are optional\n  - kube-dashboard\n  requires:                             # optional, section to define optional rquirements\n    optional:                           # see Lifecycle &gt; Deploy &gt; Optional requirements\n    - vault\n  readyConditions:                      # optional, list of conditions to check before component is considered ready\n  - dns: api.${dns.domain}              # resolvable\n    url:  https://api.${dns.domain}/v1  # returns something other than HTTP 500\n    waitSeconds: 600                    # how long to wait for the condition\n    pauseSeconds: 0                     # pause before starting poll loop\n</code></pre>"},{"location":"reference/manifests/stack/meta/","title":"Section: <code>meta</code>","text":"<p>This section defines metadata for the stack manifest. Metadata can be captured by automation tools</p> <pre><code>version: 1                            # mandatory, stack manifest schema version\nkind: stack                           # mandatory, defines a stack manifest\nmeta:                                 # optional\n  name: happy-meal                    # optional human readable name\n  brief: Happy Meal                   # optional, brief description of the stack\n  fromStack: ../../stacks/base-stack  # optional, see FromStack\n  license: Apache 2.0                 # optional, license applied to stack distribution\n</code></pre> <p>Every stack must define at least manifest <code>version</code> and <code>kind</code>. Other fields are optional.</p> <p>Section <code>meta.fromStack</code> can enable inheritance of stack manifest from another stack. This will enable stack to inherit parameters values from another stack.</p>"},{"location":"reference/manifests/stack/meta/#see-also","title":"See Also","text":"<ul> <li>Stack Manifest</li> </ul>"},{"location":"reference/manifests/stack/outputs/","title":"Section <code>outputs</code>","text":"<p>Stack outputs can be defined as the following</p> <pre><code>outputs:\n- name: ingress.hosts                     # mandatory, name of output parameter\n  brief: Ingress FQDN                     # optional, meaningful description\n  value: ${dns.name}.${dns.baseDomain}    # mandatory, output of a stack\n</code></pre>"},{"location":"reference/manifests/stack/outputs/#see-also","title":"See Also","text":"<ul> <li>Stack Manifest</li> <li>Component Outputs</li> </ul>"},{"location":"reference/manifests/stack/parameters/","title":"Section <code>parameters</code>","text":"<p>Parameters are used to configure stack and components in both stack manifest (<code>hub.yaml</code>) and component manifest (<code>hub-component.yaml</code>).</p> <p>Parameters have a tree-like structure where leafs have values and nodes should have nested parameters:</p> <pre><code>parameters:\n- name: cloud.kind\n  value: aws                          # set to value provided by user\n- name: cloud.regions                 # this parameter is only set for component `foo`\n  component: foo                      \n  value: [us-east-1, us-east-2]\n- name: kubernetes                    # nested parameters for kubernetes \n  parameters: \n  - name: worker.size\n    fromEnv: KUBERNETES_WORKER_SIZE   # Source value form environment variable\n    default: m5.large                 # Use default if value not provided\n</code></pre> <p>Native YAML syntax could be used to short-circuit nested declarations. The above is effectively flattened into list of parameters:</p> <pre><code>cloud.kind\ncloud.regions\nkubernetes.worker.size\n</code></pre> <p>The values are in most cases plain text / scalar type, yet we support arrays and maps - data types native to JSON and YAML.</p>"},{"location":"reference/manifests/stack/parameters/#resolve-parameter-value","title":"Resolve parameter value","text":"<p>Here we specify parameter types and their interpretation.</p> <p>This is the most common type of parameter. It is used to set parameter value to a literal:</p> <pre><code>parameters:\n- name: kubernetes.namespace\n  value: kube-system\n</code></pre> <p>with interpolation</p> <pre><code>parameters:\n- name: dns.domain\n  value: example.com\n- name: ingress.hosts\n  value: www.${dns.domain}\n  # resolves to: www.example.com\n</code></pre> <p>or multiline parameters </p> <pre><code>parameters:\n- name: ingress.hosts\n  value: |\n    example.com\n    www.example.com\n</code></pre>"},{"location":"reference/manifests/stack/parameters/#parameter-fromenv","title":"Parameter <code>fromEnv</code>","text":"<p>Stack Level only</p> <p>This parameter only forks for stack manifests (<code>hub.yaml</code> and <code>params-*.yaml</code>). It allows to set parameter value from environment variable:</p> <pre><code>parameters\n- name: kubernetes.namespace\n  fromEnv: NAMESPACE\n  default: kube-system\n</code></pre> <p>Parameter above will set value of parameter <code>kubernetes.namespace</code> to value of environment variable <code>NAMESPACE</code></p> <p>During <code>hubctl stack configure</code> user will be prompted to provide value for parameter <code>kubernetes.namespace</code> with default value <code>kube-system</code>. </p>"},{"location":"reference/manifests/stack/parameters/#parameter-env","title":"Parameter <code>env</code>","text":"<p>Component Level only</p> <p>This parameter only works for component manifests (<code>hub-component.yaml</code>). It allows to set environment variables from parameter value:</p> <pre><code>parameters:\n- name: kubernetes.namespace\n  env: NAMESPACE\n  value: kube-system\n</code></pre> <p>Parameter above will define environment variable <code>NAMESPACE</code> with value <code>kube-system</code> as a default (unless stack will provide different name)</p>"},{"location":"reference/manifests/stack/parameters/#parameter-fromfile","title":"Parameter <code>fromFile</code>","text":"<p>Parameter value could be read from file <code>fromFile: config/stage/password</code>.</p>"},{"location":"reference/manifests/stack/parameters/#cel-expressions","title":"CEL expressions","text":"<p>Parameter <code>value</code> support CEL expressions enclosed in <code>#{}</code> such as:</p> <pre><code>parameters:\n- name: cloud.availabilityZones\n- name: cloud.availabilityZones.count\n  value: \"#{len(cloud.availabilityZones)}\"\n</code></pre> <p>CEL has some unexpected results for corner cases, use <code>hubctl cel</code> to debug.</p>"},{"location":"reference/manifests/stack/parameters/#parameter-kind","title":"Parameter <code>kind</code>","text":"<p>All parameters can be derived from primarily from values or other components. These parameters resolved during the deployment. Until you are not care for specific parameter kind then leave it out.</p> <p>However there are special case parameters. In this case you define a special attribute <code>kind</code> to specify how parameter should be resolved.</p>"},{"location":"reference/manifests/stack/parameters/#parameter-kind-user","title":"Parameter <code>kind: user</code>","text":"<p>There are high-level user-provided parameters - the facts <code>user</code> do care about: which cloud and cloud account to use, what region to deploy to, etc.</p>"},{"location":"reference/manifests/stack/parameters/#parameter-kind-link","title":"Parameter <code>kind: link</code>","text":"<p>In general, preferred approach to resolve parameters provided as outputs from the component is through <code>components.depends</code> attribute. However sometimes you need to change parameter name as they are not match. </p> <p>To map output to a different name use <code>kind: link</code> parameter. The interpretation of <code>value</code> will be deferred until parameter is used:</p> <pre><code>parameters:\n- name: backend.image\n  value: ${ecr:docker.image}\n  kind: link\n</code></pre> <p><code>ecr</code> is a component deployed prior to <code>backend</code>. There are several ECRs thus output is fully qualified.</p>"},{"location":"reference/manifests/stack/parameters/#see-also","title":"See also","text":"<ul> <li>Stack Manifest</li> <li>Component Manifest</li> <li>CEL expressions</li> </ul>"},{"location":"reference/manifests/stack/requires/","title":"Section <code>requires</code>","text":"<pre><code>requires:\n- aws\n- kubernetes\n</code></pre> <p>Stack does not live in the vacuum. There are certain capabilities it requires from the environment before it ca nbe deployed.</p> <p>Some examples of requirements:</p> <ul> <li><code>aws</code></li> <li><code>azure</code></li> <li><code>gcp</code></li> <li><code>kubernetes</code></li> </ul> <p>This list is not fixed we work on continuously expanding it.</p>"},{"location":"reference/manifests/stack/requires/#see-also","title":"See Also","text":"<ul> <li>Stack Manifest</li> <li>Component Requires</li> </ul>"},{"location":"stacks/","title":"Stacks","text":"<p>Lorem ipsum...</p>"},{"location":"toolbox/","title":"Toolbox","text":"<p>Lorem ipsum...</p>"},{"location":"tutorials/","title":"Getting Started","text":"<p>Got hubctl installed? Great! Now let's get started with a quick tutorial.</p>"},{"location":"tutorials/010-hello-hubctl/","title":"Getting Started","text":"<p>This page will show how to start using hubctl</p>"},{"location":"tutorials/010-hello-hubctl/#installation","title":"Installation","text":"<p>How to install hubctl on your local workstation you can find here </p>"},{"location":"tutorials/010-hello-hubctl/#first-use","title":"First use","text":"<p>Create an empty directory</p> <pre><code>hubctl stack init -f \"hub.yaml\"\nhubctl stack configure\nhubctl stack deploy\n</code></pre> <p>See more about this example here</p>"},{"location":"tutorials/010-hello-hubctl/#whats-next","title":"What's Next?","text":""},{"location":"tutorials/020-shell-component/","title":"DIY Component","text":"<p>This tutorial will show you how to create a component from scratch. We will start with a minimalistic component and then we will add more features to it.</p> <p>Component is the minimal deployment unit that hubctl can manage. Good component should have few properties:</p> <ul> <li>Idenmpotent - component with the same parameters can be deployed with the same result multiple times. If component has been deployed, then it can be deployed again without any side effects.</li> <li>Generic - good component reusable this means generic enough. <code>hub-component.yaml</code> provides such abstraction. Then specific configuration will be defined via <code>hub.yaml</code> or <code>parameters.yaml</code> file on the stack level.</li> </ul> <p>Stack consists of one or multiple components. Good stack defines</p> <ul> <li>Components definition and deployment order</li> <li>Parameters that are passed to the components from environment</li> <li>Parameters that are passed between components</li> <li>Optional deployment hooks that can be used to execute custom logic before or after deployment of the component or a stack</li> </ul>"},{"location":"tutorials/020-shell-component/#component-structure","title":"Component structure","text":"<p>Each component knows how to deploy itself and export facts about deployment configuration in the well-known form of parameters. So other component would use this as an input.</p> <p>Hub component contains the following:</p> <ol> <li><code>hub-component.yaml</code> - file with input and output parameters</li> <li><code>deploy</code> and <code>undeploy</code> provisioning scripts. This however optional if component is using well known deployment tool such as <code>terraform</code>, <code>helm</code> or <code>kustomize</code>.</li> </ol> <p>In the nutshell - parameters defined in <code>hub-component.yaml</code> abstracts user from concrete provisioning technology and allows maintainer of the component improve or even change provisioning technology without breaking compatibility with the other components.</p>"},{"location":"tutorials/020-shell-component/#deploy-a-minimalistic-component","title":"Deploy a minimalistic component","text":"<ol> <li>Create a new directory <code>components/hello-shell</code></li> <li>Create a file <code>components/hello-shell/hub-component.yaml</code> and add minimalistic content</li> </ol> <pre><code>kind: component\nversion: 1\nparameters:\n- name: hub.componentName\n  env: COMPONENT_NAME\n</code></pre> <ol> <li>Create a <code>deploy.sh</code> file and add execution rights to it. Here is an example</li> </ol> <pre><code>cat &lt;&lt; EOF &gt; `components/hello-shell/deploy.sh`\n#!/bin/sh\necho \"Component $COMPONENT_NAME deployed successfully!\"\nEOF\nchmod +x `components/hello-shell/deploy.sh`\n</code></pre> <ol> <li>Create deployment reverse script: <code>undeploy.sh</code></li> </ol> <pre><code>cat &lt;&lt; EOF &gt; `components/hello-shell/undeploy.sh`\n#!/bin/sh\necho \"Component: $COMPONENT_NAME has been successfully undeployed\"\nEOF\nchmod +x `components/hello-shell/undeploy.sh`\n</code></pre> <ol> <li>Add a component reference to Hubfile (<code>hub.yaml</code>)</li> </ol> <pre><code>kind: stack\nversion: 1\ncomponents:\n- name: hello-shell\n  source:\n    dir: components/hello-shell\n</code></pre> <ol> <li>And we are ready to deploy</li> </ol> <pre><code>hubctl stack init -f `hub.yaml`\nhubctl stack deploy\n</code></pre>"},{"location":"tutorials/020-shell-component/#add-a-parameter","title":"Add a parameter","text":"<ol> <li>Add new parameter to the <code>components/hello-shell/hub-component.yaml</code></li> </ol> <pre><code>kind: component\nversion: 1\nparameters:\n- name: hub.componentName\n  env: COMPONENT_NAME\n- name: message\n  value: foo\n  env: MESSAGE\n</code></pre> <ol> <li>Modify <code>components/hello-shell/deploy.sh</code> script. You should get something like</li> </ol> <pre><code>#!/bin/sh\necho \"Component $COMPONENT_NAME is saying: $MESSAGE\"\necho \"Component $COMPONENT_NAME deployed successfully!\"\n</code></pre> <ol> <li>Add parameters to the hubfile (<code>hub.yaml</code>) to include parameter</li> </ol> <pre><code>kind: stack\nversion: 1\nmeta:\n  name: My first deployment\ncomponents:\n- name: my-first-component\n  source:\n    dir: components/hello-shell\nparameters:\n- name: message\n  value: bar\n</code></pre> <ol> <li>Run a deployment</li> </ol> <pre><code>hubctl stack deploy\n#\n# Component my-first-component is saying: bar\n# Component my-first-component deployed successfully!\n</code></pre>"},{"location":"tutorials/020-shell-component/#add-a-second-component-and-override-the-parameter","title":"Add a second component and override the parameter","text":"<p>Modify a hubfile so it would look as the following:</p> <pre><code>kind: stack\nversion: 1\nmeta:\n  name: My first deployment\ncomponents:\n- name: my-first-component\n  source:\n    dir: components/hello-shell\n- name: my-second-component\n  source:\n    dir: components/hello-shell\nparameters:\n- name: message\n  value: bar\n- name: message\n  component: my-second-component\n  value: baz\n</code></pre> <ol> <li>Run deployment</li> </ol> <pre><code>hubctl stack deploy\n# Component my-first-component is saying: bar\n# Component my-first-component deployed successfully!\n# Component my-second-component is saying: baz\n# Component my-second-component deployed successfully!\n</code></pre>"},{"location":"tutorials/020-shell-component/#add-a-template-to-the-component","title":"Add a template to the component","text":"<ol> <li>Add a file that would look like the following</li> </ol> <pre><code>cat &lt;&lt; EOF &gt; `components/hello-shell/message.txt.template`\nThe cryptic message says: ${message}\nEOF\n</code></pre> <ol> <li>Update <code>components/hello-shell/hub-component.yaml</code> so it would look like:</li> </ol> <pre><code>kind: component\nversion: 1\nparameters:\n- name: hub.componentName\n  env: COMPONENT_NAME\n- name: message\n  value: foo\n  env: MESSAGE\ntemplates:\n  files:\n  - \"*.template\"\n</code></pre> <ol> <li>Modify <code>components/hello-shell/deploy.sh</code> so it would look like the following</li> </ol> <pre><code>#!/bin/sh\necho \"Component $COMPONENT_NAME is saying: $MESSAGE\"\n# here we interact with template file... it has been already rendered\ncat \"message.txt\"\n\necho \"Component $COMPONENT_NAME deployed successfully!\"\n</code></pre> <ol> <li>Deploy the stack</li> </ol> <pre><code>hubctl stack deploy\n# Component my-first-component is saying: bar\n# The cryptic message says: bar\n# Component my-first-component deployed successfully!\n# Component my-second-component is saying: baz\n# The cryptic message says: baz\n# Component my-second-component deployed successfully!\n</code></pre>"},{"location":"tutorials/020-shell-component/#technology-specific-components","title":"Technology specific components","text":"<p>This article is not a reference guide, we do skip many things... Now we will jump into the more advanced topics. Until then we were writing a sudo component using a free form. Now we will use arguably oppinionated deployment steps however, you don't required to write your own deployment script</p> <p>At present we support following technologies</p> <ul> <li>Component Helm</li> <li>Component Kustomize</li> <li>Component Terraform</li> <li>Component ARM Deployment Template</li> </ul>"}]}